[
    {
        "problem": "\nYou are given two integers $x$ and $y$.\n\nOutput two integers: the minimum of $x$ and $y$, followed by the maximum of $x$ and $y$.\n\nInput Format:\nThe first line contains a single integer $t$ ($1 \\leq t \\leq 100$) \u2014 the number of test cases.\n\nThe only line of each test case contains two space-separated integers $x$ and $y$ ($0 \\leq x, y \\leq 9$).\n\nOutput Format:\nFor each test case, output two integers: the minimum of $x$ and $y$, followed by the maximum of $x$ and $y$.\n\nTags:\n['implementation', 'sortings']\n\nTime Limit: 1000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "10\n1 9\n8 4\n1 4\n3 4\n2 0\n2 4\n6 9\n3 3\n0 0\n9 9",
                "output": "1 9\n4 8\n1 4\n3 4\n0 2\n2 4\n6 9\n3 3\n0 0\n9 9"
            }
        ]
    },
    {
        "problem": "\nYou are given a string $s$ consisting of lowercase English letters.\n\nRearrange the characters of $s$ to form a new string $r$ that is not equal to $s$, or report that it's impossible.\n\nInput Format:\nThe first line contains a single integer $t$ ($1 \\leq t \\leq 1000$) \u2014 the number of test cases.\n\nThe only line of each test case contains a string $s$ of length at most $10$ consisting of lowercase English letters.\n\nOutput Format:\nFor each test case, if no such string $r$ exists as described in the statement, output \"NO\" (without quotes).\n\nOtherwise, output \"YES\" (without quotes). Then, output one line \u2014 the string $r$, consisting of letters of string $s$.\n\nYou can output \"YES\" and \"NO\" in any case (for example, strings \"yEs\", \"yes\", and \"Yes\" will be recognized as a positive response).\n\nIf multiple answers are possible, you can output any of them.\n\nTags:\n['implementation', 'strings']\n\nTime Limit: 1000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "8\ncodeforces\naaaaa\nxxxxy\nco\nd\nnutdealer\nmwistht\nhhhhhhhhhh",
                "output": "YES\nforcodesec\nNO\nYES\nxxyxx\nYES\noc\nNO\nYES\nundertale\nYES\nthtsiwm\nNO"
            }
        ]
    },
    {
        "problem": "\nThere is a clock labeled with the numbers $1$ through $12$ in clockwise order, as shown below.\n\n![](CDN_BASE_URL/d18290022594db5fbc2eb2c94222b5d4)\n\nIn this example, $(a,b,c,d)=(2,9,10,6)$, and the strings intersect.\n\nAlice and Bob have four distinct integers $a$, $b$, $c$, $d$ not more than $12$. Alice ties a red string connecting $a$ and $b$, and Bob ties a blue string connecting $c$ and $d$. Do the strings intersect? (The strings are straight line segments.)\n\nInput Format:\nThe first line contains a single integer $t$ ($1 \\leq t \\leq 5940$) \u2014 the number of test cases.\n\nThe only line of each test case contains four distinct integers $a$, $b$, $c$, $d$ ($1 \\leq a, b, c, d \\leq 12$).\n\nOutput Format:\nFor each test case, output \"YES\" (without quotes) if the strings intersect, and \"NO\" (without quotes) otherwise.\n\nYou can output \"YES\" and \"NO\" in any case (for example, strings \"yEs\", \"yes\", and \"Yes\" will be recognized as a positive response).\n\nTags:\n['implementation']\n\nTime Limit: 1000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "15\n2 9 10 6\n3 8 9 1\n1 2 3 4\n5 3 4 12\n1 8 2 10\n3 12 11 8\n9 10 12 1\n12 1 10 2\n3 12 6 9\n1 9 8 4\n6 7 9 12\n7 12 9 6\n10 12 11 1\n3 9 6 12\n1 4 3 5",
                "output": "YES\nNO\nNO\nYES\nYES\nNO\nNO\nNO\nNO\nNO\nNO\nYES\nYES\nYES\nYES"
            }
        ]
    },
    {
        "problem": "\nYou are given a binary string$^{\\dagger}$. Please find the minimum number of pieces you need to cut it into, so that the resulting pieces can be rearranged into a sorted binary string.\n\n![](CDN_BASE_URL/f49d41e3510eec9591123a65ee9389ab)\n\nNote that:\n\n  * each character must lie in exactly one of the pieces;    * the pieces must be contiguous substrings of the original string;    * you must use all the pieces in the rearrangement. \n\n$^{\\dagger}$ A binary string is a string consisting of characters $\\texttt{0}$ and $\\texttt{1}$. A sorted binary string is a binary string such that all characters $\\texttt{0}$ come before all characters $\\texttt{1}$.\n\nInput Format:\nThe first line contains a single integer $t$ ($1 \\leq t \\leq 500$) \u2014 the number of test cases.\n\nThe only line of each test case contains a single string $s$ ($1 \\leq |s| \\leq 500$) consisting of characters $\\texttt{0}$ and $\\texttt{1}$, where $|s|$ denotes the length of the string $s$.\n\nOutput Format:\nFor each test case, output a single integer \u2014 the minimum number of pieces needed to be able to rearrange the string into a sorted binary string.\n\nTags:\n['dp', 'greedy', 'implementation', 'sortings', 'strings']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "6\n11010\n00000000\n1\n10\n0001111\n0110",
                "output": "3\n1\n1\n2\n1\n2"
            }
        ]
    },
    {
        "problem": "\nTimur is in a car traveling on the number line from point $0$ to point $n$. The car starts moving from point $0$ at minute $0$.\n\nThere are $k+1$ signs on the line at points $0, a_1, a_2, \\dots, a_k$, and Timur knows that the car will arrive there at minutes $0, b_1, b_2, \\dots, b_k$, respectively. The sequences $a$ and $b$ are strictly increasing with $a_k = n$.\n\n![](CDN_BASE_URL/bacc58f5d5013f5922e96a1311487b97)\n\nBetween any two adjacent signs, the car travels with a constant speed. Timur has $q$ queries: each query will be an integer $d$, and Timur wants you to output how many minutes it takes the car to reach point $d$, rounded down to the nearest integer.\n\nInput Format:\nThe first line contains a single integer $t$ ($1 \\leq t \\leq 10^4$) \u2014 the number of test cases.\n\nThe first line of each test case contains three integers $n$, $k$, and $q$, ($k \\leq n \\leq 10^9$; $1 \\leq k, q \\leq 10^5$) \u2014 the final destination, the number of points Timur knows the time for, and the number of queries respectively.\n\nThe second line of each test case contains $k$ integers $a_i$ ($1 \\leq a_i \\leq n$; $a_i < a_{i+1}$ for every $1 \\leq i \\leq k-1$; $a_k = n$).\n\nThe third line of each test case contains $k$ integers $b_i$ ($1 \\leq b_i \\leq 10^9$; $b_i < b_{i+1}$ for every $1 \\leq i \\leq k-1$).\n\nEach of the following $q$ lines contains a single integer $d$ ($0 \\leq d \\leq n$) \u2014 the distance that Timur asks the minutes passed for.\n\nThe sum of $k$ over all test cases doesn't exceed $10^5$, and the sum of $q$ over all test cases doesn't exceed $10^5$.\n\nOutput Format:\nFor each query, output a single integer \u2014 the number of minutes passed until the car reaches the point $d$, rounded down.\n\nTags:\n['binary search', 'math', 'sortings']\n\nTime Limit: 3000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "4\n10 1 3\n10\n10\n0\n6\n7\n10 2 4\n4 10\n4 7\n6\n4\n2\n7\n1000000000 1 1\n1000000000\n1000000000\n99999999\n6 1 3\n6\n5\n2\n6\n5",
                "output": "0 6 7 \n5 4 2 5 \n99999999 \n1 5 4"
            }
        ]
    },
    {
        "problem": "\nGiven an integer $r$, find the number of lattice points that have a Euclidean distance from $(0, 0)$ greater than or equal to $r$ but strictly less than $r+1$.\n\nA lattice point is a point with integer coordinates. The Euclidean distance from $(0, 0)$ to the point $(x,y)$ is $\\sqrt{x^2 + y^2}$.\n\nInput Format:\nThe first line contains a single integer $t$ ($1 \\leq t \\leq 1000$) \u2014 the number of test cases.\n\nThe only line of each test case contains a single integer $r$ ($1 \\leq r \\leq 10^5$).\n\nThe sum of $r$ over all test cases does not exceed $10^5$.\n\nOutput Format:\nFor each test case, output a single integer \u2014 the number of lattice points that have an Euclidean distance $d$ from $(0, 0)$ such that $r \\leq d < r+1$.\n\nTags:\n['binary search', 'brute force', 'dfs and similar', 'geometry', 'implementation', 'math']\n\nTime Limit: 1000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "6\n1\n2\n3\n4\n5\n1984",
                "output": "8\n16\n20\n24\n40\n12504"
            }
        ]
    },
    {
        "problem": "\nYou are given an array $a$ consisting of $n$ nonnegative integers.\n\nYou can swap the elements at positions $i$ and $j$ if $a_i~\\mathsf{XOR}~a_j < 4$, where $\\mathsf{XOR}$ is the [bitwise XOR operation](https://en.wikipedia.org/wiki/Bitwise_operation#XOR).\n\nFind the lexicographically smallest array that can be made with any number of swaps.\n\nAn array $x$ is lexicographically smaller than an array $y$ if in the first position where $x$ and $y$ differ, $x_i < y_i$.\n\nInput Format:\nThe first line contains a single integer $t$ ($1 \\leq t \\leq 10^4$) \u2014 the number of test cases.\n\nThe first line of each test case contains a single integer $n$ ($1 \\leq n \\leq 2\\cdot10^5$) \u2014 the length of the array.\n\nThe second line of each test case contains $n$ integers $a_i$ ($0 \\leq a_i \\leq 10^9$) \u2014 the elements of the array.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\nOutput Format:\nFor each test case, output $n$ integers \u2014 the lexicographically smallest array that can be made with any number of swaps.\n\nTags:\n['data structures', 'dsu', 'sortings']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "4\n4\n1 0 3 2\n5\n2 7 1 5 6\n8\n1 2 1 2 1 2 1 2\n4\n16 4 1 64",
                "output": "0 1 2 3 \n1 5 2 6 7 \n1 1 1 1 2 2 2 2 \n16 4 1 64"
            }
        ]
    },
    {
        "problem": "\nBob has a grid with $3$ rows and $n$ columns, each of which contains either $a_i$ or $-a_i$ for some integer $1 \\leq i \\leq n$. For example, one possible grid for $n=4$ is shown below:\n\n$$\\begin{bmatrix} a_1 & -a_2 & -a_3 & -a_2 \\\\\\ -a_4 & a_4 & -a_1 & -a_3 \\\\\\ a_1 & a_2 & -a_2 & a_4 \\end{bmatrix}$$\n\nAlice and Bob play a game as follows:\n\n  * Bob shows Alice his grid.    * Alice gives Bob an array $a_1, a_2, \\dots, a_n$ of her choosing, whose elements are all $\\mathbf{-1}$ or $\\mathbf{1}$.    * Bob substitutes these values into his grid to make a grid of $-1$s and $1$s.    * Bob sorts the elements of each column in non-decreasing order.    * Alice wins if all the elements in the middle row are $1$; otherwise, Bob wins. \n\nFor example, suppose Alice gives Bob the array $[1, -1, -1, 1]$ for the grid above. Then the following will happen (colors are added for clarity):\n\n$$\\begin{bmatrix} \\color{red}{a_1} & \\color{green}{-a_2} & \\color{blue}{-a_3} & \\color{green}{-a_2} \\\\\\ -a_4 & a_4 & \\color{red}{-a_1} & \\color{blue}{-a_3} \\\\\\ \\color{red}{a_1} & \\color{green}{a_2} & \\color{green}{-a_2} & a_4 \\end{bmatrix} \\xrightarrow{[\\color{red}{1},\\color{green}{-1},\\color{blue}{-1},1]} \\begin{bmatrix} \\color{red}{1} & \\color{green}{1} & \\color{blue}{1} & \\color{green}{1} \\\\\\ -1 & 1 & \\color{red}{-1} & \\color{blue}{1} \\\\\\ \\color{red}{1} & \\color{green}{-1} & \\color{green}{1} & 1 \\end{bmatrix} \\xrightarrow{\\text{sort each column}} \\begin{bmatrix} -1 & -1 & -1 & 1 \\\\\\ \\mathbf{1} & \\mathbf{1} & \\mathbf{1} & \\mathbf{1} \\\\\\ 1 & 1 & 1 & 1 \\\\\\ \\end{bmatrix}\\,. $$ Since the middle row is all $1$, Alice wins.\n\nGiven Bob's grid, determine whether or not Alice can choose the array $a$ to win the game.\n\nInput Format:\nThe first line contains a single integer $t$ ($1 \\leq t \\leq 1000$) \u2014 the number of test cases.\n\nThe first line of each test case contains a single integer $n$ ($2 \\leq n \\leq 500$) \u2014 the number of columns of Bob's grid.\n\nThe next three lines each contain $n$ integers, the $i$-th of which contains $g_{i,1}, g_{i,2}, \\dots, g_{i,n}$ ($-n \\leq g_{i,j} \\leq n$, $g_{i,j} \\neq 0$), representing Bob's grid.\n\nIf cell $x > 0$ is in the input, that cell in Bob's grid should contain $a_x$; if $x < 0$ is in the input, that cell in Bob's grid should contain $-a_{-x}$. See the sample input and notes for a better understanding.\n\nOutput Format:\nFor each test case, output \"YES\" (without quotes) if Alice can win, and \"NO\" (without quotes) otherwise.\n\nYou can output \"YES\" and \"NO\" in any case (for example, strings \"yEs\", \"yes\", and \"Yes\" will be recognized as a positive response).\n\nTags:\n['2-sat', 'dfs and similar', 'graphs']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "4\n4\n1 -2 -3 -2\n-4 4 -1 -3\n1 2 -2 4\n2\n1 2\n-1 -2\n2 -2\n5\n1 2 3 4 5\n-2 3 -4 -5 -1\n3 -5 1 2 2\n6\n1 3 -6 2 5 2\n1 3 -2 -3 -6 -5\n-2 -1 -3 2 3 1",
                "output": "YES\nNO\nYES\nNO"
            }
        ]
    },
    {
        "problem": "\nA contest contains $n$ problems and the difficulty of the $i$-th problem is expected to be at most $b_i$. There are already $n$ problem proposals and the difficulty of the $i$-th problem is $a_i$. Initially, both $a_1, a_2, \\ldots, a_n$ and $b_1, b_2, \\ldots, b_n$ are sorted in non-decreasing order.\n\nSome of the problems may be more difficult than expected, so the writers must propose more problems. When a new problem with difficulty $w$ is proposed, the most difficult problem will be deleted from the contest, and the problems will be sorted in a way that the difficulties are non-decreasing.\n\nIn other words, in each operation, you choose an integer $w$, insert it into the array $a$, sort array $a$ in non-decreasing order, and remove the last element from it.\n\nFind the minimum number of new problems to make $a_i\\le b_i$ for all $i$.\n\nInput Format:\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1\\le t\\le 100$). The description of the test cases follows.\n\nThe first line of each test case contains only one positive integer $n$ ($1 \\leq n \\leq 100$), representing the number of problems.\n\nThe second line of each test case contains an array $a$ of length $n$ ($1\\le a_1\\le a_2\\le\\cdots\\le a_n\\le 10^9$).\n\nThe third line of each test case contains an array $b$ of length $n$ ($1\\le b_1\\le b_2\\le\\cdots\\le b_n\\le 10^9$).\n\nOutput Format:\nFor each test case, print an integer as your answer in a new line.\n\nTags:\n['brute force', 'greedy', 'two pointers']\n\nTime Limit: 1000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "2\n6\n1000 1400 2000 2000 2200 2700\n800 1200 1500 1800 2200 3000\n6\n4 5 6 7 8 9\n1 2 3 4 5 6",
                "output": "2\n3"
            }
        ]
    },
    {
        "problem": "\nThere are $n$ coins on the table forming a circle, and each coin is either facing up or facing down. Alice and Bob take turns to play the following game, and Alice goes first.\n\nIn each operation, the player chooses a facing-up coin, removes the coin, and flips the two coins that are adjacent to it. If (before the operation) there are only two coins left, then one will be removed and the other won't be flipped (as it would be flipped twice). If (before the operation) there is only one coin left, no coins will be flipped. If (before the operation) there are no facing-up coins, the player loses.\n\nDecide who will win the game if they both play optimally. It can be proved that the game will end in a finite number of operations, and one of them will win.\n\nInput Format:\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1\\le t\\le 100$). The description of the test cases follows.\n\nThe first line of each test case contains only one positive integer $n$ ($1 \\leq n \\leq 100$), representing the number of the coins.\n\nA string $s$ of length $n$ follows on the second line of each test case, containing only \"U\" and \"D\", representing that each coin is facing up or facing down.\n\nOutput Format:\nFor each test case, print \"YES\" if Alice will win the game, and \"NO\" otherwise.\n\nYou can output the answer in any case (upper or lower). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as positive responses.\n\nTags:\n['games']\n\nTime Limit: 1000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "3\n5\nUUDUD\n5\nUDDUD\n2\nUU",
                "output": "YES\nNO\nNO"
            }
        ]
    },
    {
        "problem": "\nYou have some cards. An integer between $1$ and $n$ is written on each card: specifically, for each $i$ from $1$ to $n$, you have $a_i$ cards which have the number $i$ written on them.\n\nThere is also a shop which contains unlimited cards of each type. You have $k$ coins, so you can buy $k$ new cards in total, and the cards you buy can contain any integer between $1$ and $n$.\n\nAfter buying the new cards, you rearrange all your cards in a line. The score of a rearrangement is the number of (contiguous) subarrays of length $n$ which are a permutation of $[1, 2, \\ldots, n]$. What's the maximum score you can get?\n\nInput Format:\nEach test contains multiple test cases. The first line contains the number of test cases $t\\ (1\\le t\\le 100)$. The description of the test cases follows.\n\nThe first line of each test case contains two integers $n$, $k$ ($1\\le n \\le 2 \\cdot 10^5$, $0\\le k \\le 10^{12}$) \u2014 the number of distinct types of cards and the number of coins.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\le a_i \\le 10^{12}$) \u2014 the number of cards of type $i$ you have at the beginning.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $5 \\cdot 10^5$.\n\nOutput Format:\nFor each test case, output a single line containing an integer: the maximum score you can get.\n\nTags:\n['binary search', 'constructive algorithms', 'greedy', 'implementation', 'math', 'sortings']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "8\n1 10\n1\n2 4\n8 4\n3 4\n6 1 8\n3 9\n7 6 2\n5 3\n6 6 7 4 6\n9 7\n7 6 1 7 6 2 4 3 3\n10 10\n1 3 1 2 1 9 3 5 7 5\n9 8\n5 8 7 5 1 3 2 9 8",
                "output": "11\n15\n15\n22\n28\n32\n28\n36"
            }
        ]
    },
    {
        "problem": "\nThe two versions are different problems. You may want to read both versions. You can make hacks only if both versions are solved.\n\nYou are given two positive integers $n$, $m$.\n\nCalculate the number of ordered pairs $(a, b)$ satisfying the following conditions:\n\n  * $1\\le a\\le n$, $1\\le b\\le m$;    * $a+b$ is a multiple of $b \\cdot \\gcd(a,b)$.\n\nInput Format:\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1\\le t\\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains two integers $n$, $m$ ($1\\le n,m\\le 2 \\cdot 10^6$).\n\nIt is guaranteed that neither the sum of $n$ nor the sum of $m$ over all test cases exceeds $2 \\cdot 10^6$.\n\nOutput Format:\nFor each test case, print a single integer: the number of valid pairs.\n\nTags:\n['brute force', 'math', 'number theory']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "6\n1 1\n2 3\n3 5\n10 8\n100 1233\n1000000 1145141",
                "output": "1\n3\n4\n14\n153\n1643498"
            }
        ]
    },
    {
        "problem": "\nThe two versions are different problems. You may want to read both versions. You can make hacks only if both versions are solved.\n\nYou are given two positive integers $n$, $m$.\n\nCalculate the number of ordered pairs $(a, b)$ satisfying the following conditions:\n\n  * $1\\le a\\le n$, $1\\le b\\le m$;    * $b \\cdot \\gcd(a,b)$ is a multiple of $a+b$.\n\nInput Format:\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1\\le t\\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains two integers $n$, $m$ ($1\\le n,m\\le 2 \\cdot 10^6$).\n\nIt is guaranteed that neither the sum of $n$ nor the sum of $m$ over all test cases exceeds $2 \\cdot 10^6$.\n\nOutput Format:\nFor each test case, print a single integer: the number of valid pairs.\n\nTags:\n['brute force', 'math', 'number theory']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "6\n1 1\n2 3\n3 5\n10 8\n100 1233\n1000000 1145141",
                "output": "0\n1\n1\n6\n423\n5933961"
            }
        ]
    },
    {
        "problem": "\nLet $\\operatorname{lowbit}(x)$ denote the value of the lowest binary bit of $x$, e.g. $\\operatorname{lowbit}(12)=4$, $\\operatorname{lowbit}(8)=8$.\n\nFor an array $a$ of length $n$, if an array $s$ of length $n$ satisfies $s_k=\\left(\\sum\\limits_{i=k-\\operatorname{lowbit}(k)+1}^{k}a_i\\right)\\bmod 998\\,244\\,353$ for all $k$, then $s$ is called the Fenwick Tree of $a$. Let's denote it as $s=f(a)$.\n\nFor a positive integer $k$ and an array $a$, $f^k(a)$ is defined as follows:\n\n$$ f^k(a)= \\begin{cases} f(a)&\\textrm{if }k=1\\\\\\ f(f^{k-1}(a))&\\textrm{otherwise.}\\\\\\ \\end{cases} $$\n\nYou are given an array $b$ of length $n$ and a positive integer $k$. Find an array $a$ that satisfies $0\\le a_i < 998\\,244\\,353$ and $f^k(a)=b$. It can be proved that an answer always exists. If there are multiple possible answers, you may print any of them.\n\nInput Format:\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1\\le t\\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains two positive integers $n$ ($1 \\leq n \\leq 2\\cdot 10^5$) and $k$ ($1\\le k\\le 10^9$), representing the length of the array and the number of times the function $f$ is performed.\n\nThe second line of each test case contains an array $b_1, b_2, \\ldots, b_n$ ($0\\le b_i < 998\\,244\\,353$).\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2\\cdot 10^5$.\n\nOutput Format:\nFor each test case, print a single line, containing a valid array $a$ of length $n$.\n\nTags:\n['combinatorics', 'data structures', 'math', 'matrices']\n\nTime Limit: 3000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "2\n8 1\n1 2 1 4 1 2 1 8\n6 2\n1 4 3 17 5 16",
                "output": "1 1 1 1 1 1 1 1\n1 2 3 4 5 6"
            }
        ]
    },
    {
        "problem": "\nLittle R is a magician who likes non-decreasing arrays. She has an array of length $n$, initially as $a_1, \\ldots, a_n$, in which each element is an integer between $[1, m]$. She wants it to be non-decreasing, i.e., $a_1 \\leq a_2 \\leq \\ldots \\leq a_n$.\n\nTo do this, she can perform several magic tricks. Little R has a fixed array $b_1\\ldots b_m$ of length $m$. Formally, let's define a trick as a procedure that does the following things in order:\n\n  * Choose a set $S \\subseteq \\\\{1, 2, \\ldots, n\\\\}$.    * For each $u \\in S$, assign $a_u$ with $b_{a_u}$. \n\nLittle R wonders how many tricks are needed at least to make the initial array non-decreasing. If it is not possible with any amount of tricks, print $-1$ instead.\n\nInput Format:\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1\\le t\\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains two integers $n$ and $m$ ($1\\leq n \\leq 10^6$, $1 \\leq m \\leq 10^6$) \u2014 the length of the initial array and the range of the elements in the array.\n\nThe second line of each test case contains $n$ integers $a_1, \\ldots, a_n$ ($1 \\leq a_i \\leq m$) \u2014 the initial array.\n\nThe third line of each test case contains $m$ integers $b_1, \\ldots, b_m$ ($1 \\leq b_i \\leq m$) \u2014 the fixed magic array.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $10^6$ and the sum of $m$ over all test cases does not exceed $10^6$.\n\nOutput Format:\nFor each test case, output a single integer: the minimum number of tricks needed, or $-1$ if it is impossible to make $a_1, \\ldots, a_n$ non- decreasing.\n\nTags:\n['binary search', 'dfs and similar', 'graphs', 'implementation']\n\nTime Limit: 4000 ms\nMemory Limit: 512 MB\n",
        "tests": [
            {
                "input": "3\n5 8\n1 6 3 7 1\n2 3 5 8 7 1 5 6\n3 3\n1 3 2\n2 1 3\n10 10\n2 8 5 4 8 4 1 5 10 10\n6 7 2 6 3 4 1 1 3 5",
                "output": "3\n-1\n3"
            }
        ]
    },
    {
        "problem": "\nThree friends gathered to play a few games of chess together.\n\nIn every game, two of them play against each other. The winner gets $2$ points while the loser gets $0$, and in case of a draw, both players get $1$ point each. Note that the same pair of players could have played any non-negative number of times (possibly zero). It is also possible that no games were played at all.\n\nYou've been told that their scores after all the games were played were $p_1$, $p_2$ and $p_3$. Additionally, it is guaranteed that $p_1 \\leq p_2 \\leq p_3$ holds.\n\nFind the maximum number of draws that could have happened and print it. If there isn't any way to obtain $p_1$, $p_2$ and $p_3$ as a result of a non-negative number of games between the three players, print $-1$ instead.\n\nInput Format:\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 500$). The description of the test cases follows.\n\nThe first line of each test case contains three integers $p_1$, $p_2$ and $p_3$ ($0 \\leq p_1 \\leq p_2 \\leq p_3 \\leq 30$) \u2014 the scores of the three players, sorted non-decreasingly.\n\nOutput Format:\nFor each testcase, print one number \u2014 the maximum possible number of draws that could've happened, or $-1$ if the scores aren't consistent with any valid set of games and results.\n\nTags:\n['brute force', 'dp', 'implementation', 'math']\n\nTime Limit: 1000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "7\n0 0 0\n0 1 1\n1 1 1\n1 1 2\n3 3 3\n3 4 5\n1 1 10",
                "output": "0\n1\n-1\n2\n-1\n6\n2"
            }
        ]
    },
    {
        "problem": "\nToday, Cat and Fox found an array $a$ consisting of $n$ non-negative integers.\n\nDefine the loneliness of $a$ as the smallest positive integer $k$ ($1 \\le k \\le n$) such that for any two positive integers $i$ and $j$ ($1 \\leq i, j \\leq n - k +1$), the following holds: $$a_i | a_{i+1} | \\ldots | a_{i+k-1} = a_j | a_{j+1} | \\ldots | a_{j+k-1},$$ where $x | y$ denotes the [bitwise OR](https://en.wikipedia.org/wiki/Bitwise_operation#OR) of $x$ and $y$. In other words, for every $k$ consecutive elements, their bitwise OR should be the same. Note that the loneliness of $a$ is well-defined, because for $k = n$ the condition is satisfied.\n\nCat and Fox want to know how lonely the array $a$ is. Help them calculate the loneliness of the found array.\n\nInput Format:\nEach test consists of multiple test cases. The first line contains a single integer $t$ ($1 \\leq t \\leq 10^4 $) \u2014 the number of test cases. The description of the test cases follows.\n\nThe first line of each test case contains one integer $n$ ($1 \\leq n \\leq 10^5$) \u2014 the length of the array $a$.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($0 \\leq a_i < 2^{20}$) \u2014 the elements of the array.\n\nIt is guaranteed that the sum of $n$ over all test cases doesn't exceed $10^5$.\n\nOutput Format:\nFor each test case, print one integer  \u2014 the loneliness of the given array.\n\nTags:\n['binary search', 'bitmasks', 'data structures', 'greedy', 'math', 'two pointers']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "7\n1\n0\n3\n2 2 2\n3\n1 0 2\n5\n3 0 1 4 2\n5\n2 0 4 0 2\n7\n0 0 0 0 1 2 4\n8\n0 1 3 2 2 1 0 3",
                "output": "1\n1\n3\n4\n4\n7\n3"
            }
        ]
    },
    {
        "problem": "\nFox loves permutations! She came up with the following problem and asked Cat to solve it:\n\nYou are given an even positive integer $n$ and a permutation$^\\dagger$ $p$ of length $n$.\n\nThe score of another permutation $q$ of length $n$ is the number of local maximums in the array $a$ of length $n$, where $a_i = p_i + q_i$ for all $i$ ($1 \\le i \\le n$). In other words, the score of $q$ is the number of $i$ such that $1 < i < n$ (note the strict inequalities), $a_{i-1} < a_i$, and $a_i > a_{i+1}$ (once again, note the strict inequalities).\n\nFind the permutation $q$ that achieves the maximum score for given $n$ and $p$. If there exist multiple such permutations, you can pick any of them.\n\n$^\\dagger$ A permutation of length $n$ is an array consisting of $n$ distinct integers from $1$ to $n$ in arbitrary order. For example, $[2,3,1,5,4]$ is a permutation, but $[1,2,2]$ is not a permutation ($2$ appears twice in the array), and $[1,3,4]$ is also not a permutation ($n=3$ but there is $4$ in the array).\n\nInput Format:\nThe first line of input contains an integer $t$ ($1 \\leq t \\leq 10^4$) \u2014 the number of test cases in the input you will have to solve.\n\nThe first line of each test case contains one even integer $n$ ($4 \\leq n \\leq 10^5$, $n$ is even) \u2014 the length of the permutation $p$.\n\nThe second line of each test case contains the $n$ integers $p_1, p_2, \\ldots, p_n$ ($1 \\leq p_i \\leq n$). It is guaranteed that $p$ is a permutation of length $n$.\n\nIt is guaranteed that the sum of $n$ across all test cases doesn't exceed $10^5$.\n\nOutput Format:\nFor each test case, output one line containing any permutation of length $n$ (the array $q$), such that $q$ maximizes the score under the given constraints.\n\nTags:\n['constructive algorithms', 'greedy', 'implementation', 'math', 'sortings']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "4\n4\n1 2 3 4\n4\n4 3 1 2\n6\n6 5 1 4 2 3\n8\n1 2 4 5 7 6 8 3",
                "output": "2 4 1 3\n3 1 4 2\n2 5 1 4 3 6\n5 4 8 2 7 1 6 3"
            }
        ]
    },
    {
        "problem": "\nThis is an interactive problem.\n\nFox gave Cat two positive integers $n$ and $k$. She has a hidden array $a_1, \\ldots , a_n$ of length $n$, such that $1 \\leq a_i \\leq n$ for every $i$. Now they are going to play the following game:\n\nFor any two integers $l, r$ such that $1 \\leq l \\leq r \\leq n$, define $f(l, r) = (r - l + 1) \\cdot \\max\\limits_{x=l}^r a_x$. In other words, $f(l, r)$ is equal to the maximum of the subarray $a_l, \\ldots, a_r$ multiplied by its size.\n\nCat can ask Fox at most $2 n$ questions about the array. He will tell her two integers $l$ and $x$ ($1 \\leq l \\leq n, 1 \\leq x \\leq 10^9$), and she will tell him one integer $p$ as the answer \u2014 the smallest positive integer $r$ such that $f(l, r) = x$, or $n+1$ if no such $r$ exists.\n\nNow, Cat needs to find the largest value $m$ such that there exists a sequence $c_1, \\ldots, c_{k-1}$ such that $1 \\leq c_1 < \\ldots < c_{k-1} < n$ and $f(1, c_1) = f(c_1 + 1, c_2) = \\ldots = f(c_{k-1}+1, n) = m$. If no such $m$ exists, he should indicate this and take $-1$ as the answer. Note that for $k = 1$, $m$ is always equal to $f(1, n)$.\n\nIn other words, the goal is to find the largest $m$ such that you can split the array into exactly $k$ subarrays ($k$ is the constant given to you in the beginning of the interaction) so that all the subarrays have the product of their length and their maximum equal to $m$, or determine that no such $m$ exists. Every element should belong in exactly one of the subarrays.\n\nCat doesn't know what he should do, so he asked you to play the game for him.\n\nInput Format:\n\n\nOutput Format:\n\n\nTags:\n['brute force', 'interactive', 'math']\n\nTime Limit: 3000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "3\n1 1\n\n1\n2 2\n\n1\n\n3\n\n1\n6 3\n\n7\n\n2\n\n3\n\n6\n\n1",
                "output": "! 1\n\n\n? 1 1\n\n? 2 1\n\n! -1\n\n\n? 1 9\n\n? 1 6\n\n? 3 6\n\n? 4 6\n\n! 6"
            }
        ]
    },
    {
        "problem": "\nFox has found an array $p_1, p_2, \\ldots, p_n$, that is a permutation of length $n^\\dagger$ of the numbers $1, 2, \\ldots, n$. She wants to sort the elements in increasing order. Cat wants to help her \u2014 he is able to swap any two numbers $x$ and $y$ in the array, but only if $l \\leq x + y \\leq r$ (note that the constraint is imposed on the values of the elements, not their positions). He can make such swaps any number of times.\n\nThey don't know the numbers $l$, $r$ yet, they only know that it's true that $1 \\leq l \\leq r \\leq 2 \\cdot n$.\n\nYou are given the number $n$ and the array $p_1, p_2, \\ldots, p_n$. Determine how many pairs $(l, r)$ satisfying the conditions are there such that you can sort the permutation if you can only swap two number $(x, y)$ such that $l \\leq x + y \\leq r$ (arbitrary number of times, possibly $0$).\n\n$^\\dagger$ A permutation of length $n$ is an array consisting of $n$ distinct integers from $1$ to $n$ in arbitrary order. For example, $[2,3,1,5,4]$ is a permutation, but $[1,2,2]$ is not a permutation ($2$ appears twice in the array), and $[1,3,4]$ is also not a permutation ($n=3$ but there is $4$ in the array).\n\nInput Format:\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nDescription of each test case consists of two lines. The first line contains one integer $n$ ($1 \\leq n \\leq 10^5$).\n\nThe second line contains $n$ integers: the array $p_1, p_2, \\ldots, p_n$ ($1 \\le p_i \\le n$). It is guaranteed that this array is a permutation of length $n$.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $10^5$.\n\nOutput Format:\nFor each test case, print the number of pairs of integers $(l, r)$ such that $1 \\leq l \\leq r \\leq 2 \\cdot n$, and you can sort the array under the constraints.\n\nTags:\n['graphs', 'math', 'sortings']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "7\n2\n2 1\n3\n3 1 2\n4\n3 2 1 4\n5\n5 3 1 2 4\n5\n1 2 3 4 5\n6\n3 2 1 5 4 6\n6\n1 3 2 4 5 6",
                "output": "6\n11\n23\n29\n55\n46\n58"
            }
        ]
    },
    {
        "problem": "\nFor $k$ positive integers $x_1, x_2, \\ldots, x_k$, the value $\\gcd(x_1, x_2, \\ldots, x_k)$ is the greatest common divisor of the integers $x_1, x_2, \\ldots, x_k$ \u2014 the largest integer $z$ such that all the integers $x_1, x_2, \\ldots, x_k$ are divisible by $z$.\n\nYou are given three arrays $a_1, a_2, \\ldots, a_n$, $b_1, b_2, \\ldots, b_n$ and $c_1, c_2, \\ldots, c_n$ of length $n$, containing positive integers.\n\nYou also have a machine that allows you to swap $a_i$ and $b_i$ for any $i$ ($1 \\le i \\le n$). Each swap costs you $c_i$ coins.\n\nFind the maximum possible value of $$\\gcd(a_1, a_2, \\ldots, a_n) + \\gcd(b_1, b_2, \\ldots, b_n)$$ that you can get by paying in total at most $d$ coins for swapping some elements. The amount of coins you have changes a lot, so find the answer to this question for each of the $q$ possible values $d_1, d_2, \\ldots, d_q$.\n\nInput Format:\nThere are two integers on the first line \u2014 the numbers $n$ and $q$ ($1 \\leq n \\leq 5 \\cdot 10^5$, $1 \\leq q \\leq 5 \\cdot 10^5$).\n\nOn the second line, there are $n$ integers \u2014 the numbers $a_1, a_2, \\ldots, a_n$ ($1 \\leq a_i \\leq 10^8$).\n\nOn the third line, there are $n$ integers \u2014 the numbers $b_1, b_2, \\ldots, b_n$ ($1 \\leq b_i \\leq 10^8$).\n\nOn the fourth line, there are $n$ integers \u2014 the numbers $c_1, c_2, \\ldots, c_n$ ($1 \\leq c_i \\leq 10^9$).\n\nOn the fifth line, there are $q$ integers \u2014 the numbers $d_1, d_2, \\ldots, d_q$ ($0 \\leq d_i \\leq 10^{15}$).\n\nOutput Format:\nPrint $q$ integers \u2014 the maximum value you can get for each of the $q$ possible values $d$.\n\nTags:\n['bitmasks', 'brute force', 'dp', 'implementation', 'number theory']\n\nTime Limit: 5000 ms\nMemory Limit: 512 MB\n",
        "tests": [
            {
                "input": "3 4\n1 2 3\n4 5 6\n1 1 1\n0 1 2 3",
                "output": "2 3 3 3"
            },
            {
                "input": "5 5\n3 4 6 8 4\n8 3 4 9 3\n10 20 30 40 50\n5 55 13 1000 113",
                "output": "2 7 3 7 7"
            },
            {
                "input": "1 1\n3\n4\n5\n0",
                "output": "7"
            }
        ]
    },
    {
        "problem": "\nLittle Rosie has a phone with a desktop (or launcher, as it is also called). The desktop can consist of several screens. Each screen is represented as a grid of size $5 \\times 3$, i.e., five rows and three columns.\n\nThere are $x$ applications with an icon size of $1 \\times 1$ cells; such an icon occupies only one cell of the screen. There are also $y$ applications with an icon size of $2 \\times 2$ cells; such an icon occupies a square of $4$ cells on the screen. Each cell of each screen can be occupied by no more than one icon.\n\nRosie wants to place the application icons on the minimum number of screens. Help her find the minimum number of screens needed.\n\nInput Format:\nThe first line of the input contains $t$ ($1 \\leq t \\leq 10^4$) \u2014 the number of test cases.\n\nThe first and only line of each test case contains two integers $x$ and $y$ ($0 \\leq x, y \\leq 99$) \u2014 the number of applications with a $1 \\times 1$ icon and the number of applications with a $2 \\times 2$ icon, respectively.\n\nOutput Format:\nFor each test case, output the minimal number of required screens on a separate line.\n\nTags:\n['greedy', 'math']\n\nTime Limit: 1000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "11\n1 1\n7 2\n12 4\n0 3\n1 0\n8 1\n0 0\n2 0\n15 0\n8 2\n0 9",
                "output": "1\n1\n2\n2\n1\n1\n0\n1\n1\n2\n5"
            }
        ]
    },
    {
        "problem": "\nPolycarp has a string $s$, which consists of lowercase Latin letters. He encodes this string using the following algorithm:\n\n  * first, he constructs a new auxiliary string $r$, which consists of all distinct letters of the string $s$, written in alphabetical order;    * then the encoding happens as follows: each character in the string $s$ is replaced by its symmetric character from the string $r$ (the first character of the string $r$ will be replaced by the last, the second by the second from the end, and so on). \n\nFor example, encoding the string $s$=\"codeforces\" happens as follows:\n\n  * the string $r$ is obtained as \"cdefors\";    * the first character $s_1$='c' is replaced by 's';    * the second character $s_2$='o' is replaced by 'e';    * the third character $s_3$='d' is replaced by 'r';    * ...    * the last character $s_{10}$='s' is replaced by 'c'. \n\n![](CDN_BASE_URL/e120531cc984becdbbab53f80507a062) The string $r$ and replacements for $s$=\"codeforces\".\n\nThus, the result of encoding the string $s$=\"codeforces\" is the string \"serofedsoc\".\n\nWrite a program that performs decoding \u2014 that is, restores the original string $s$ from the encoding result.\n\nInput Format:\nThe first line contains a single integer $t$ ($1 \\le t \\le 10^4$) \u2014 the number of test cases.\n\nThe first line of each test case contains a single integer $n$ ($1 \\le n \\le 2 \\cdot 10^5$) \u2014 the length of the string $b$.\n\nThe second line of each test case contains a string $b$ of length $n$, consisting of lowercase Latin letters \u2014 the result of encoding the original string $s$.\n\nIt is guaranteed that the sum of the values of $n$ over all test cases in the test does not exceed $2 \\cdot 10^5$.\n\nOutput Format:\nFor each test case, output the string $s$ from which the encoding result $b$ was obtained.\n\nTags:\n['implementation', 'sortings', 'strings']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "5\n10\nserofedsoc\n3\nttf\n9\ntlrhgmaoi\n1\nw\n15\nhnndledmnhlttin",
                "output": "codeforces\nfft\nalgorithm\nw\nmeetinthemiddle"
            }
        ]
    },
    {
        "problem": "\nPolycarp was given an array $a$ of $n$ integers. He really likes triples of numbers, so for each $j$ ($1 \\le j \\le n - 2$) he wrote down a triple of elements $[a_j, a_{j + 1}, a_{j + 2}]$.\n\nPolycarp considers a pair of triples $b$ and $c$ beautiful if they differ in exactly one position, that is, one of the following conditions is satisfied:\n\n  * $b_1 \\ne c_1$ and $b_2 = c_2$ and $b_3 = c_3$;    * $b_1 = c_1$ and $b_2 \\ne c_2$ and $b_3 = c_3$;    * $b_1 = c_1$ and $b_2 = c_2$ and $b_3 \\ne c_3$. \n\nFind the number of beautiful pairs of triples among the written triples $[a_j, a_{j + 1}, a_{j + 2}]$.\n\nInput Format:\nThe first line contains a single integer $t$ ($1 \\le t \\le 10^4$) \u2014 the number of test cases.\n\nThe first line of each test case contains a single integer $n$ ($3 \\le n \\le 2 \\cdot 10^5$) \u2014 the length of the array $a$.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\dots, a_n$ ($1 \\le a_i \\le 10^6$) \u2014 the elements of the array.\n\nIt is guaranteed that the sum of the values of $n$ for all test cases in the test does not exceed $2 \\cdot 10^5$.\n\nOutput Format:\nFor each test case, output a single integer \u2014 the number of beautiful pairs of triples among the pairs of the form $[a_j, a_{j + 1}, a_{j + 2}]$.\n\nNote that the answer may not fit into 32-bit data types.\n\nTags:\n['combinatorics', 'data structures']\n\nTime Limit: 4000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "8\n5\n3 2 2 2 3\n5\n1 2 1 2 1\n8\n1 2 3 2 2 3 4 2\n4\n2 1 1 1\n8\n2 1 1 2 1 1 1 1\n7\n2 1 1 1 1 1 1\n6\n2 1 1 1 1 1\n5\n2 1 1 1 1",
                "output": "2\n0\n3\n1\n8\n4\n3\n2"
            }
        ]
    },
    {
        "problem": "\nLet's imagine the surface of Mars as an infinite coordinate plane. Initially, the rover Perseverance-2 and the helicopter Ingenuity-2 are located at the point with coordinates $(0, 0)$. A set of instructions $s$ consisting of $n$ instructions of the following types was specially developed for them:\n\n  * N: move one meter north (from point $(x, y)$ to $(x, y + 1)$);    * S: move one meter south (from point $(x, y)$ to $(x, y - 1)$);    * E: move one meter east (from point $(x, y)$ to $(x + 1, y)$);    * W: move one meter west (from point $(x, y)$ to $(x - 1, y)$). \n\nEach instruction must be executed either by the rover or by the helicopter. Moreover, each device must execute at least one instruction. Your task is to distribute the instructions in such a way that after executing all $n$ instructions, the helicopter and the rover end up at the same point, or determine that this is impossible.\n\nInput Format:\nThe first line of input contains $t$ ($1 \\leq t \\leq 10^4$) \u2014 the number of test cases.\n\nThe first line of each test case contains a single integer $n$ ($1 \\le n \\le 2 \\cdot 10^5$) \u2014 the number of instructions.\n\nThe second line of each test case contains a string $s$ of length $n$ consisting of the characters 'N', 'S', 'E', 'W' \u2014 the sequence of instructions.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10 ^ 5$.\n\nOutput Format:\nFor each test case, if the required distribution of instructions exists, output a string $p$ of length $n$ consisting of the characters 'R', 'H'. If the $i$-th operation should be executed by the rover, then $p_i=\\text{R}$, if the $i$-th operation should be executed by the helicopter, then $p_i=\\text{H}$. If there are multiple solutions, output any of them.\n\nOtherwise, output NO.\n\nTags:\n['constructive algorithms', 'greedy', 'implementation']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "10\n6\nNENSNE\n3\nWWW\n6\nNESSWS\n2\nSN\n2\nWE\n4\nSSNN\n4\nWESN\n2\nSS\n4\nEWNN\n4\nWEWE",
                "output": "RRHRRH\nNO\nHRRHRH\nNO\nNO\nRHRH\nRRHH\nRH\nRRRH\nRRHH"
            }
        ]
    },
    {
        "problem": "\nBeing a physicist, Charlie likes to plan his life in simple and precise terms.\n\nFor the next $m$ months, starting with no money, Charlie will work hard and earn $x$ pounds per month. For the $i$-th month $(1 \\le i \\le m)$, there'll be a single opportunity of paying cost $c_i$ pounds to obtain happiness $h_i$.\n\nBorrowing is not allowed. Money earned in the $i$-th month can only be spent in a later $j$-th month ($j>i$).\n\nSince physicists don't code, help Charlie find the maximum obtainable sum of happiness.\n\nInput Format:\nThe first line of input contains a single integer $t$ ($1 \\le t \\le 1000$) \u2014 the number of test cases.\n\nThe first line of each test case contains two integers, $m$ and $x$ ($1 \\le m \\le 50$, $1 \\le x \\le 10^8$) \u2014 the total number of months and the monthly salary.\n\nThe $i$-th of the following $m$ lines contains two integers, $c_i$ and $h_i$ ($0 \\le c_i \\le 10^8$, $1 \\le h_i \\le 10^3$) \u2014 the cost and happiness on offer for the $i$-th month. Note that some happiness may be free ($c_i=0$ for some $i$'s).\n\nIt is guaranteed that the sum of $\\sum_i h_i$ over all test cases does not exceed $10^5$.\n\nOutput Format:\nFor each test case, print a single integer, the maximum sum of happiness Charlie could obtain.\n\nTags:\n['dp']\n\nTime Limit: 3000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "7\n1 10\n1 5\n2 80\n0 10\n200 100\n3 100\n70 100\n100 200\n150 150\n5 8\n3 1\n5 3\n3 4\n1 5\n5 3\n2 5\n1 5\n2 1\n5 3\n2 5\n2 4\n4 1\n5 1\n3 4\n5 2\n2 1\n1 2\n3 5\n3 2\n3 2",
                "output": "0\n10\n200\n15\n1\n9\n9"
            }
        ]
    },
    {
        "problem": "\nAlice and Bob were playing a game again. They have a grid of size $a \\times b$ ($1 \\le a, b \\le 10^9$), on which there are $n$ chips, with at most one chip in each cell. The cell at the intersection of the $x$-th row and the $y$-th column has coordinates $(x, y)$.\n\nAlice made the first move, and the players took turns. On each move, a player could cut several (but not all) rows or columns from the beginning or end of the remaining grid and earn a point for each chip that was on the cut part of the grid. Each move can be described by the character 'U', 'D', 'L', or 'R' and an integer $k$:\n\n  * If the character is 'U', then the first $k$ remaining rows will be cut;    * If the character is 'D', then the last $k$ remaining rows will be cut;    * If the character is 'L', then the first $k$ remaining columns will be cut;    * If the character is 'R', then the last $k$ remaining columns will be cut. \n\nBased on the initial state of the grid and the players' moves, determine the number of points earned by Alice and Bob, respectively.\n\nInput Format:\nThe first line contains a single integer $t$ ($1 \\le t \\le 10^4$) \u2014 the number of test cases.\n\nThe first line of each test case contains four integers $a$, $b$, $n$, and $m$ ($2 \\le a, b \\le 10^9$, $1 \\le n, m \\le 2 \\cdot 10^5$) \u2014 the dimensions of the grid, the number of chips, and the number of moves.\n\nEach of the next $n$ lines contain two integers $x_i$ and $y_i$ ($1 \\le x_i \\le a$, $1 \\le y_i \\le b$) \u2014 the coordinates of the chips. All pairs of coordinates are distinct.\n\nEach of the next $m$ lines contain a character $c_j$ and an integer $k_j$ \u2014 the description of the $j$-th move. It is guaranteed that $k$ is less than the number of rows/columns in the current grid. In other words, a player cannot cut the entire remaining grid on their move.\n\nIt is guaranteed that the sum of the values of $n$ across all test cases in the test does not exceed $2 \\cdot 10^5$. It is guaranteed that the sum of the values of $m$ across all test cases in the test does not exceed $2 \\cdot 10^5$.\n\nOutput Format:\nFor each test case, output two integers \u2014 the number of points earned by Alice and Bob, respectively.\n\nTags:\n['binary search', 'brute force', 'data structures', 'implementation', 'sortings', 'two pointers']\n\nTime Limit: 3000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "6\n4 4 3 2\n4 1\n3 3\n2 4\nD 2\nR 1\n4 4 3 3\n4 1\n3 2\n2 3\nD 1\nL 1\nU 2\n3 5 3 2\n1 3\n2 2\n3 3\nR 2\nR 2\n6 4 4 2\n1 4\n2 3\n5 3\n1 1\nR 1\nU 1\n9 3 2 1\n6 1\n3 3\nD 8\n10 10 2 5\n7 5\n9 1\nR 1\nL 2\nD 1\nU 4\nD 1",
                "output": "2 1\n2 0\n0 3\n1 1\n2 0\n0 1"
            }
        ]
    },
    {
        "problem": "\nYou can never buy enough happiness, so here we go again! In this version, you can only buy $h_i = 1$ unit of happiness each month, but the number of months is hugely increased. We are in the realm of quantum happiness and time dilation.\n\nBeing a physicist, Charlie likes to plan his life in simple and precise terms.\n\nFor the next $m$ months, starting with no money, Charlie will work hard and earn $x$ pounds per month. For the $i$-th month $(1 \\le i \\le m)$, there'll be a single opportunity of paying cost $c_i$ pounds to obtain one unit of happiness. You cannot buy more than one unit each month.\n\nBorrowing is not allowed. Money earned in the $i$-th month can only be spent in a later $j$-th month ($j>i$).\n\nSince physicists don't code, help Charlie find the maximum reachable units of happiness.\n\nInput Format:\nThe first line of the input contains $t$ ($1 \\leq t \\leq 10^4$) \u2014 the number of test cases.\n\nThe first line of each test case contains two integers, $m$ and $x$ ($1 \\le m \\le 2 \\cdot 10^5$, $1 \\le x \\le 10^3$) \u2014 the total number of months and the monthly salary.\n\nThe second line of each test case contains $m$ integers $c_1, c_2, \\dots, c_m$ ($1 \\leq c_i \\leq 10^3$) \u2014 the cost of one unit of happiness for each month.\n\nIt is guaranteed that sum of $m$ over all test cases does not exceed $2 \\cdot 10^5$.\n\nOutput Format:\nFor each test case, output one integer \u2014 the maximal amount of happiness Charlie can get.\n\nTags:\n['data structures', 'greedy', 'sortings']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "6\n3 3\n2 2 2\n6 5\n2 2 8 2 6 8\n6 4\n4 10 3 8 6 10\n2 1\n1 1\n4 1\n4 1 3 1\n4 2\n1 3 4 3",
                "output": "2\n4\n3\n1\n2\n1"
            }
        ]
    },
    {
        "problem": "\nMocha likes arrays, so before her departure, Bazoka gave her an array $a$ consisting of $n$ positive integers as a gift.\n\nNow Mocha wants to know whether array $a$ could become sorted in non- decreasing order after performing the following operation some (possibly, zero) times:\n\n  * Split the array into two parts \u2014 a prefix and a suffix, then swap these two parts. In other words, let $a=x+y$. Then, we can set $a:= y+x$. Here $+$ denotes the array concatenation operation. \n\nFor example, if $a=[3,1,4,1,5]$, we can choose $x=[3,1]$ and $y=[4,1,5]$, satisfying $a=x+y$. Then, we can set $a:= y + x = [4,1,5,3,1]$. We can also choose $x=[3,1,4,1,5]$ and $y=[\\,]$, satisfying $a=x+y$. Then, we can set $a := y+x = [3,1,4,1,5]$. Note that we are not allowed to choose $x=[3,1,1]$ and $y=[4,5]$, neither are we allowed to choose $x=[1,3]$ and $y=[5,1,4]$, as both these choices do not satisfy $a=x+y$.\n\nInput Format:\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1\\leq t\\leq 1000$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($2\\leq n\\leq 50$) \u2014 the length of the array $a$.\n\nThe second line of each test case contains $n$ integers $a_1,a_2,\\ldots,a_n$ ($1\\leq a_i \\leq 10^6$) \u2014 the elements of array $a$.\n\nOutput Format:\nFor each test case, output \"Yes\" if $a$ could become non-decreasing after performing the operation any number of times, and output \"No\" if not.\n\nYou can output \"Yes\" and \"No\" in any case (for example, strings \"yEs\", \"yes\", \"Yes\" and \"YES\" will be recognized as a positive response).\n\nTags:\n['brute force', 'greedy', 'implementation', 'sortings']\n\nTime Limit: 1000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "3\n6\n1 1 4 5 1 4\n5\n7 9 2 2 3\n3\n1 2 3",
                "output": "No\nYes\nYes"
            }
        ]
    },
    {
        "problem": "\nMocha likes arrays, so before her departure, 378QAQ gave her an array $a$ consisting of $n$ positive integers as a gift.\n\nMocha thinks that $a$ is beautiful if there exist two numbers $i$ and $j$ ($1\\leq i,j\\leq n$, $i\\neq j$) such that for all $k$ ($1 \\leq k \\leq n$), $a_k$ is divisible$^\\dagger$ by either $a_i$ or $a_j$.\n\nDetermine whether $a$ is beautiful.\n\n$^\\dagger$ $x$ is divisible by $y$ if there exists an integer $z$ such that $x = y \\cdot z$.\n\nInput Format:\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1\\leq t\\leq 500$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($3\\leq n\\leq 10^5$) \u2014 the length of the array $a$.\n\nThe second line of each test case contains $n$ integers $a_1,a_2,\\ldots,a_n$ ($1\\leq a_i \\leq 10^9$) \u2014 the elements of the array $a$.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $10^5$.\n\nOutput Format:\nFor each test case, output \"Yes\" if array $a$ is beautiful, and output \"No\" otherwise.\n\nYou can output \"Yes\" and \"No\" in any case (for example, strings \"yEs\", \"yes\", \"Yes\" and \"YES\" will be recognized as a positive response).\n\nTags:\n['brute force', 'greedy', 'math', 'sortings']\n\nTime Limit: 1000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "4\n3\n7 3 8\n5\n7 1 9 3 5\n5\n4 12 2 6 3\n5\n7 49 9 3 1000000000",
                "output": "No\nYes\nYes\nNo"
            }
        ]
    },
    {
        "problem": "\nMocha likes arrays, so before her departure, Chamo gave her an array $a$ consisting of $n$ positive integers as a gift.\n\nMocha doesn't like arrays containing different numbers, so Mocha decides to use magic to change the array. Mocha can perform the following three-step operation some (possibly, zero) times:\n\n  1. Choose indices $l$ and $r$ ($1 \\leq l < r \\leq n$)    2. Let $x$ be the median$^\\dagger$ of the subarray $[a_l, a_{l+1},\\ldots, a_r]$    3. Set all values $a_l, a_{l+1},\\ldots, a_r$ to $x$ \n\nSuppose $a=[1,2,3,4,5]$ initially:\n\n  * If Mocha chooses $(l,r)=(3,4)$ in the first operation, then $x=3$, the array will be changed into $a=[1,2,3,3,5]$.    * If Mocha chooses $(l,r)=(1,3)$ in the first operation, then $x=2$, the array will be changed into $a=[2,2,2,4,5]$. \n\nMocha will perform the operation until the array contains only the same number. Mocha wants to know what is the maximum possible value of this number.\n\n$^\\dagger$ The median in an array $b$ of length $m$ is an element that occupies position number $\\lfloor \\frac{m+1}{2} \\rfloor$ after we sort the elements in non-decreasing order. For example, the median of $[3,1,4,1,5]$ is $3$ and the median of $[5,25,20,24]$ is $20$.\n\nInput Format:\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1\\leq t\\leq 500$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($2\\leq n\\leq 10^5$) \u2014 the length of the array $a$.\n\nThe second line of each test case contains $n$ integers $a_1,a_2,\\ldots,a_n$ ($1\\leq a_i \\leq 10^9$) \u2014 the elements of the array $a$.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $10^5$.\n\nOutput Format:\nFor each test case, output the maximum value of the number.\n\nTags:\n['binary search', 'brute force', 'greedy']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "2\n2\n1 2\n5\n1 2 3 4 5",
                "output": "1\n4"
            }
        ]
    },
    {
        "problem": "\n378QAQ has a tree with $n$ vertices. Initially, all vertices are white.\n\nThere are two chess pieces called $P_A$ and $P_B$ on the tree. $P_A$ and $P_B$ are initially located on vertices $a$ and $b$ respectively. In one step, 378QAQ will do the following in order:\n\n  1. Move $P_A$ to a neighboring vertex. If the target vertex is white, this vertex will be painted red.    2. Move $P_B$ to a neighboring vertex. If the target vertex is colored in red, this vertex will be painted blue. \n\nInitially, the vertex $a$ is painted red. If $a=b$, the vertex $a$ is painted blue instead. Note that both the chess pieces must be moved in each step. Two pieces can be on the same vertex at any given time.\n\n378QAQ wants to know the minimum number of steps to paint all vertices blue.\n\nInput Format:\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1\\leq t\\leq 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains one integer $n$ ($1\\leq n\\leq 2\\cdot 10^5$).\n\nThe second line of each test case contains two integers $a$ and $b$ ($1\\leq a,b\\leq n$).\n\nThen $n - 1$ lines follow, each line contains two integers $x_i$ and $y_i$ ($1 \\le x_i,y_i \\le n$), indicating an edge between vertices $x_i$ and $y_i$. It is guaranteed that these edges form a tree.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2\\cdot 10^5$.\n\nOutput Format:\nFor each test case, output the minimum number of steps to paint all vertices blue.\n\nTags:\n['brute force', 'dfs and similar', 'dp', 'greedy', 'shortest paths', 'trees']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "3\n2\n1 2\n1 2\n5\n1 2\n1 2\n1 3\n1 4\n1 5\n8\n5 4\n7 1\n1 5\n1 8\n8 3\n7 2\n8 6\n3 4",
                "output": "2\n8\n13"
            }
        ]
    },
    {
        "problem": "\nYou are given a tree of $n$ vertices numbered from $1$ to $n$. Initially, all vertices are colored white or black.\n\nYou are asked to perform $q$ queries:\n\n  * \"u\" \u2014 toggle the color of vertex $u$ (if it was white, change it to black and vice versa). \n\nAfter each query, you should answer whether all the black vertices form a chain. That is, there exist two black vertices such that the simple path between them passes through all the black vertices and only the black vertices. Specifically, if there is only one black vertex, they form a chain. If there are no black vertices, they do not form a chain.\n\nInput Format:\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1\\leq t\\leq 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains two integers $n$ and $q$ ($1\\leq n,q\\leq 2\\cdot 10^5$).\n\nThe second line of each test case contains $n$ integers $c_1,c_2,\\ldots,c_n$ ($c_i \\in \\\\{ \\mathtt{0}, \\mathtt{1} \\\\}$) \u2014 the initial color of the vertices. $c_i$ denotes the color of vertex $i$ where $\\mathtt{0}$ denotes the color white, and $\\mathtt{1}$ denotes the color black.\n\nThen $n - 1$ lines follow, each line contains two integers $x_i$ and $y_i$ ($1 \\le x_i,y_i \\le n$), indicating an edge between vertices $x_i$ and $y_i$. It is guaranteed that these edges form a tree.\n\nThe following $q$ lines each contain an integer $u_i$ ($1 \\le u_i \\le n$), indicating the color of vertex $u_i$ needs to be toggled.\n\nIt is guaranteed that the sum of $n$ and $q$ over all test cases respectively does not exceed $2\\cdot 10^5$.\n\nOutput Format:\nFor each query, output \"Yes\" if the black vertices form a chain, and output \"No\" otherwise.\n\nYou can output \"Yes\" and \"No\" in any case (for example, strings \"yEs\", \"yes\", \"Yes\" and \"YES\" will be recognized as a positive response).\n\nTags:\n['binary search', 'data structures', 'dfs and similar', 'implementation', 'trees']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "2\n2 1\n1 0\n1 2\n1\n5 4\n1 0 0 0 0\n1 2\n1 3\n1 5\n3 4\n4\n3\n2\n5",
                "output": "No\nNo\nYes\nYes\nNo"
            },
            {
                "input": "4\n5 3\n1 1 1 1 1\n3 5\n2 5\n3 4\n1 5\n1\n1\n1\n4 4\n0 0 0 0\n1 2\n2 3\n1 4\n1\n2\n3\n2\n1 1\n1\n1\n1 1\n0\n1",
                "output": "Yes\nNo\nYes\nYes\nYes\nYes\nNo\nNo\nYes"
            }
        ]
    },
    {
        "problem": "\nDefine the binary encoding of a finite set of natural numbers $T \\subseteq \\\\{0,1,2,\\ldots\\\\}$ as $f(T) = \\sum\\limits_{i \\in T} 2^i$. For example, $f(\\\\{0,2\\\\}) = 2^0 + 2^2 = 5$ and $f(\\\\{\\\\}) = 0$. Notice that $f$ is a bijection from all such sets to all non-negative integers. As such, $f^{-1}$ is also defined.\n\nYou are given an integer $n$ along with $2^n-1$ sets $V_1,V_2,\\ldots,V_{2^n-1}$.\n\nFind all sets $S$ that satisfy the following constraint:\n\n  * $S \\subseteq \\\\{0,1,\\ldots,n-1\\\\}$. Note that $S$ can be empty.    * For all non-empty subsets $T \\subseteq \\\\{0,1,\\ldots,n-1\\\\}$, $|S \\cap T| \\in V_{f(T)}$. \n\nDue to the large input and output, both input and output will be given in terms of binary encodings of the sets.\n\nInput Format:\nThe first line of input contains a single integer $n$ ($1 \\leq n \\leq 20$).\n\nThe second line of input contains $2^n-1$ integers $v_1,v_2,\\ldots,v_{2^n-1}$ ($0 \\leq v_i < 2^{n+1}$) \u2014 the sets $V_i$ given in their binary encoding where $V_i = f^{-1}(v_i)$.\n\nOutput Format:\nThe first line of output should contain an integer $k$ indicating the number of possible $S$.\n\nIn the following $k$ lines, you should output $f(S)$ for all possible $S$ in increasing order.\n\nTags:\n['bitmasks', 'brute force', 'combinatorics', 'dfs and similar', 'divide and conquer', 'dp', 'math']\n\nTime Limit: 2000 ms\nMemory Limit: 512 MB\n",
        "tests": [
            {
                "input": "3\n15 15 15 15 15 15 12",
                "output": "4\n3\n5\n6\n7"
            },
            {
                "input": "5\n63 63 63 63 6 63 63 63 63 63 63 5 63 63 63 63 63 63 8 63 63 63 63 2 63 63 63 63 63 63 63",
                "output": "1\n19"
            }
        ]
    },
    {
        "problem": "\nOne day, Zimpha casually came up with a problem. As a member of \"Zimpha fan club\", you decided to solve that problem.      You are given two strings $s$ and $t$ of length $n$ and $m$, respectively. Both strings only consist of lowercase English letters, - and *.\n\nYou need to replace all occurrences of * and -, observing the following rules:\n\n  * For each -, you must replace it with any lowercase English letter.    * For each *, you must replace it with a string of any (possibly, zero) length which only consists of lowercase English letters. \n\nNote that you can replace two different instances of - with different characters. You can also replace each two different instances of * with different strings.\n\nSuppose $s$ and $t$ have been transformed into $s'$ and $t'$. Now you're wondering if there's a replacement that makes $s'=t'$.\n\nInput Format:\nThe first line of input contains two integers $n$ and $m$ ($1 \\leq n, m \\leq 2 \\cdot 10^6$) \u2014 the length of the strings $s$ and $t$, respectively.\n\nThe second line contains the string $s$ of length $n$. It is guaranteed that $s$ only consists of lowercase English letters, - and *.\n\nThe third line contains the string $t$ of length $m$. It is guaranteed that $t$ only consists of lowercase English letters, - and *.\n\nOutput Format:\nFor each test case, output \"Yes\" if there is a replacement that makes $s'=t'$, and output \"No\" otherwise.\n\nYou can output \"Yes\" and \"No\" in any case (for example, strings \"yEs\", \"yes\", \"Yes\" and \"YES\" will be recognized as a positive response).\n\nTags:\n['fft', 'greedy', 'math', 'strings']\n\nTime Limit: 12000 ms\nMemory Limit: 512 MB\n",
        "tests": [
            {
                "input": "10 10\njustmonika\nj-stsayori",
                "output": "No"
            },
            {
                "input": "7 8\nttk-wxx\n*tt-l-xx",
                "output": "Yes"
            },
            {
                "input": "13 11\nasoulwangziji\n-soulg*z-y-",
                "output": "No"
            },
            {
                "input": "7 3\nabc*cba\na*c",
                "output": "No"
            },
            {
                "input": "20 18\nbulijiojio-dibuliduo\n*li*ji-*ox*i*-du*-",
                "output": "Yes"
            }
        ]
    },
    {
        "problem": "\n378QAQ has a string $s$ of length $n$. Define the core of a string as the substring$^\\dagger$ with maximum lexicographic$^\\ddagger$ order.\n\nFor example, the core of \"$\\mathtt{bazoka}$\" is \"$\\mathtt{zoka}$\", and the core of \"$\\mathtt{aaa}$\" is \"$\\mathtt{aaa}$\".\n\n378QAQ wants to rearrange the string $s$ so that the core is lexicographically minimum. Find the lexicographically minimum possible core over all rearrangements of $s$.\n\n$^\\dagger$ A substring of string $s$ is a continuous segment of letters from $s$. For example, \"$\\mathtt{defor}$\", \"$\\mathtt{code}$\" and \"$\\mathtt{o}$\" are all substrings of \"$\\mathtt{codeforces}$\" while \"$\\mathtt{codes}$\" and \"$\\mathtt{aaa}$\" are not.\n\n$^\\ddagger$ A string $p$ is lexicographically smaller than a string $q$ if and only if one of the following holds:\n\n  * $p$ is a prefix of $q$, but $p \\ne q$; or    * in the first position where $p$ and $q$ differ, the string $p$ has a smaller element than the corresponding element in $q$ (when compared by their ASCII code). \n\nFor example, \"$\\mathtt{code}$\" and \"$\\mathtt{coda}$\" are both lexicographically smaller than \"$\\mathtt{codeforces}$\" while \"$\\mathtt{codeforceston}$\" and \"$\\mathtt{z}$\" are not.\n\nInput Format:\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1\\leq t\\leq 10^5$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($1\\leq n\\leq 10^6$) \u2014 the length of string $s$.\n\nThe next line of each test case contains the string $s$ of length $n$. The string $s$ consists of lowercase English letters.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $10^6$.\n\nOutput Format:\nFor each test case, output the lexicographically minimum possible core over all rearrangements of $s$.\n\nTags:\n['greedy', 'strings']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "6\n3\nqaq\n4\ncccc\n6\nbazoka\n6\nzazzzz\n7\nababbbb\n7\nccbabcc",
                "output": "qaq\ncccc\nz\nzzz\nbbababb\ncbcacbc"
            }
        ]
    },
    {
        "problem": "\nThis is the way it always was.\n\nThis is the way it always will be.\n\nAll will be forgotten again soon...\n\nJellyfish is playing a one-player card game called \"Slay the Spire\". There are $n$ cards in total numbered from $1$ to $n$. The $i$-th card has power $c_i$.\n\nThere is a binary string $s$ of length $n$. If $s_i = \\texttt{0}$, the $i$-th card is initially in the draw pile. If $s_i = \\texttt{1}$, the $i$-th card is initially in Jellyfish's hand.\n\nJellyfish will repeat the following process until either her hand or the draw pile is empty.\n\n  1. Let $x$ be the power of the card with the largest power in her hand.    2. Place a single card with power $x$ back into the draw pile.    3. Randomly draw $x$ cards from the draw pile. All subsets of $x$ cards from the draw pile have an equal chance of being drawn. If there are fewer than $x$ cards in the draw pile, Jellyfish will draw all cards. \n\nAt the end of this process, find the probability that Jellyfish can empty the draw pile, modulo $1\\,000\\,000\\,007$.\n\nFormally, let $M=1\\,000\\,000\\,007$. It can be shown that the answer can be expressed as an irreducible fraction $\\frac{p}{q}$, where $p$ and $q$ are integers and $q \\not \\equiv 0 \\pmod{M}$. Output the integer equal to $p \\cdot q^{-1} \\bmod M$. In other words, output such an integer $x$ that $0 \\le x < M$ and $x \\cdot q \\equiv p \\pmod{M}$.\n\nInput Format:\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1\\leq t\\leq 100$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($1 \\leq n \\leq 120$) \u2014 the number of cards.\n\nThe second line of each test case contains $n$ integers $c_1,c_2,\\ldots,c_n$ ($0 \\leq c_i \\leq n$) \u2014 the powers of the cards. It is guaranteed that $c_1 \\leq c_2 \\leq \\ldots \\leq c_n$.\n\nThe third line of each test case contains a binary string $s$ of length $n$. If $s_i = \\texttt{0}$, the $i$-th card is initially in the draw pile. If $s_i = \\texttt{1}$, the $i$-th card is initially in Jellyfish's hand.\n\nIt is guaranteed that the sum of $n^2$ over all test cases does not exceed $120^2$.\n\nOutput Format:\nFor each test case, output the probability that Jellyfish can empty the draw pile modulo $1\\,000\\,000\\,007$.\n\nTags:\n['dp']\n\nTime Limit: 5000 ms\nMemory Limit: 1024 MB\n",
        "tests": [
            {
                "input": "4\n5\n0 1 1 1 2\n00100\n3\n2 3 3\n000\n10\n0 0 0 0 0 0 0 1 1 1\n1111011111\n20\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 2 3 3 4\n00000000001000101010",
                "output": "500000004\n0\n0\n675898154"
            }
        ]
    },
    {
        "problem": "\nMonocarp is working on his new site, and the current challenge is to make the users pick strong passwords.\n\nMonocarp decided that strong passwords should satisfy the following conditions:\n\n  * password should consist only of lowercase Latin letters and digits;    * there should be no digit that comes after a letter (so, after each letter, there is either another letter or the string ends);    * all digits should be sorted in the non-decreasing order;    * all letters should be sorted in the non-decreasing order. \n\nNote that it's allowed for the password to have only letters or only digits.\n\nMonocarp managed to implement the first condition, but he struggles with the remaining ones. Can you help him to verify the passwords?\n\nInput Format:\nThe first line contains a single integer $t$ ($1 \\le t \\le 1000$) \u2014 the number of testcases.\n\nThe first line of each testcase contains a single integer $n$ ($1 \\le n \\le 20$) \u2014 the length of the password.\n\nThe second line contains a string, consisting of exactly $n$ characters. Each character is either a lowercase Latin letter or a digit.\n\nOutput Format:\nFor each testcase, print \"YES\" if the given password is strong and \"NO\" otherwise.\n\nTags:\n['implementation', 'sortings', 'strings']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "5\n4\n12ac\n5\n123wa\n9\nallllmost\n5\nac123\n6\n011679",
                "output": "YES\nNO\nYES\nNO\nYES"
            }
        ]
    },
    {
        "problem": "\nYou are given two integer arrays: array $a$ of length $n$ and array $b$ of length $n+1$.\n\nYou can perform the following operations any number of times in any order:\n\n  * choose any element of the array $a$ and increase it by $1$;    * choose any element of the array $a$ and decrease it by $1$;    * choose any element of the array $a$, copy it and append the copy to the end of the array $a$. \n\nYour task is to calculate the minimum number of aforementioned operations (possibly zero) required to transform the array $a$ into the array $b$. It can be shown that under the constraints of the problem, it is always possible.\n\nInput Format:\nThe first line contains a single integer $t$ ($1 \\le t \\le 10^4$) \u2014 the number of test cases.\n\nEach test case consists of three lines:\n\n  * the first line contains a single integer $n$ ($1 \\le n \\le 2 \\cdot 10^5$);    * the second line contains $n$ integers $a_1, a_2, \\dots, a_n$ ($1 \\le a_i \\le 10^9$);    * the third line contains $n + 1$ integers $b_1, b_2, \\dots, b_{n + 1}$ ($1 \\le b_i \\le 10^9$). \n\nAdditional constraint on the input: the sum of $n$ over all test cases doesn't exceed $2 \\cdot 10^5$.\n\nOutput Format:\nFor each test case, print a single integer \u2014 the minimum number of operations (possibly zero) required to transform the array $a$ into the array $b$.\n\nTags:\n['greedy', 'implementation']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "3\n1\n2\n1 3\n2\n3 3\n3 3 3\n4\n4 2 1 2\n2 1 5 2 3",
                "output": "3\n1\n8"
            }
        ]
    },
    {
        "problem": "\nMonocarp is opening his own IT company. He wants to hire $n$ programmers and $m$ testers.\n\nThere are $n+m+1$ candidates, numbered from $1$ to $n+m+1$ in chronological order of their arriving time. The $i$-th candidate has programming skill $a_i$ and testing skill $b_i$ (a person's programming skill is different from their testing skill). The skill of the team is the sum of the programming skills of all candidates hired as programmers, and the sum of the testing skills of all candidates hired as testers.\n\nWhen a candidate arrives to interview, Monocarp tries to assign them to the most suitable position for them (if their programming skill is higher, then he hires them as a programmer, otherwise as a tester). If all slots for that position are filled, Monocarp assigns them to the other position.\n\nYour task is, for each candidate, calculate the skill of the team if everyone except them comes to interview. Note that it means that exactly $n+m$ candidates will arrive, so all $n+m$ positions in the company will be filled.\n\nInput Format:\nThe first line contains a single integer $t$ ($1 \\le t \\le 10^4$) \u2014 the number of test cases.\n\nEach test case consists of three lines:\n\n  * the first line contains two integers $n$ and $m$ ($0 \\le n, m \\le 2 \\cdot 10^5$; $2 \\le n + m + 1 \\le 2 \\cdot 10^5$) \u2014 the number of programmers and the number of testers Monocarp wants to hire, respectively;    * the second line contains $n + m + 1$ integers $a_1, a_2, \\dots, a_{n+m+1}$ ($1 \\le a_i \\le 10^9$), where $a_i$ is the programming skill of the $i$-th candidate;    * the third line contains $n + m + 1$ integers $b_1, b_2, \\dots, b_{n+m+1}$ ($1 \\le b_i \\le 10^9$; $b_i \\ne a_i$), where $b_i$ is the testing skill of the $i$-th candidate. \n\nAdditional constraint on the input: the sum of $(n + m + 1)$ over all test cases doesn't exceed $2 \\cdot 10^5$.\n\nOutput Format:\nFor each test case, print $n + m + 1$ integers, where the $i$-th integer should be equal to the skill of the team if everyone except the $i$-th candidate comes to interview.\n\nTags:\n['binary search', 'dp', 'greedy', 'implementation', 'two pointers']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "4\n1 0\n2 1\n1 2\n0 2\n4 5 5\n5 4 1\n1 2\n2 1 5 4\n5 2 3 1\n3 1\n4 3 3 4 1\n5 5 4 5 2",
                "output": "1 2 \n5 6 9 \n8 11 11 12 \n13 13 13 12 15"
            }
        ]
    },
    {
        "problem": "\nA regular bracket sequence is a bracket sequence that can be transformed into a correct arithmetic expression by inserting characters '1' and '+' between the original characters of the sequence. For example:\n\n  * bracket sequences \"()()\" and \"(())\" are regular (the resulting expressions are: \"(1)+(1)\" and \"((1+1)+1)\");    * bracket sequences \")(\", \"(\" and \")\" are not. \n\nLet's define the inverse of the bracket sequence as follows: replace all brackets '(' with ')', and vice versa (all brackets ')' with '('). For example, strings \"()((\" and \")())\" are inverses of each other.\n\nYou are given a regular bracket sequence $s$. Calculate the number of pairs of integers $(l,r)$ ($1 \\le l \\le r \\le |s|$) such that if you replace the substring of $s$ from the $l$-th character to the $r$-th character (inclusive) with its inverse, $s$ will still be a regular bracket sequence.\n\nInput Format:\nThe first line contains a single integer $t$ ($1 \\le t \\le 10^4$) \u2014 the number of test cases.\n\nThe only line of each test case contains a non-empty regular bracket sequence; it consists only of characters '(' and/or ')'.\n\nAdditional constraint on the input: the total length of the regular bracket sequences over all test cases doesn't exceed $2 \\cdot 10^5$.\n\nOutput Format:\nFor each test case, print a single integer \u2014 the number of pairs $(l,r)$ meeting the conditions from the statement.\n\nTags:\n['binary search', 'combinatorics', 'data structures', 'divide and conquer', 'implementation', 'two pointers']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "4\n(())\n()\n()()()\n(()())(())",
                "output": "1\n0\n3\n13"
            }
        ]
    },
    {
        "problem": "\nInitially, we had one array, which was a permutation of size $n$ (an array of size $n$ where each integer from $1$ to $n$ appears exactly once).\n\nWe performed $q$ operations. During the $i$-th operation, we did the following:\n\n  * choose any array we have with at least $2$ elements;    * split it into two non-empty arrays (prefix and suffix);    * write two integers $l_i$ and $r_i$, where $l_i$ is the maximum element in the left part which we get after the split, and $r_i$ is the maximum element in the right part;    * remove the array we've chosen from the pool of arrays we can use, and add the two resulting parts into the pool. \n\nFor example, suppose the initial array was $[6, 3, 4, 1, 2, 5]$, and we performed the following operations:\n\n  1. choose the array $[6, 3, 4, 1, 2, 5]$ and split it into $[6, 3]$ and $[4, 1, 2, 5]$. Then we write $l_1 = 6$ and $r_1 = 5$, and the arrays we have are $[6, 3]$ and $[4, 1, 2, 5]$;    2. choose the array $[4, 1, 2, 5]$ and split it into $[4, 1, 2]$ and $[5]$. Then we write $l_2 = 4$ and $r_2 = 5$, and the arrays we have are $[6, 3]$, $[4, 1, 2]$ and $[5]$;    3. choose the array $[4, 1, 2]$ and split it into $[4]$ and $[1, 2]$. Then we write $l_3 = 4$ and $r_3 = 2$, and the arrays we have are $[6, 3]$, $[4]$, $[1, 2]$ and $[5]$. \n\nYou are given two integers $n$ and $q$, and two sequences $[l_1, l_2, \\dots, l_q]$ and $[r_1, r_2, \\dots, r_q]$. A permutation of size $n$ is called valid if we can perform $q$ operations and produce the given sequences $[l_1, l_2, \\dots, l_q]$ and $[r_1, r_2, \\dots, r_q]$.\n\nCalculate the number of valid permutations.\n\nInput Format:\nThe first line contains two integers $n$ and $q$ ($1 \\le q < n \\le 3 \\cdot 10^5$).\n\nThe second line contains $q$ integers $l_1, l_2, \\dots, l_q$ ($1 \\le l_i \\le n$).\n\nThe third line contains $q$ integers $r_1, r_2, \\dots, r_q$ ($1 \\le r_i \\le n$).\n\nAdditional constraint on the input: there exists at least one permutation which can produce the given sequences $[l_1, l_2, \\dots, l_q]$ and $[r_1, r_2, \\dots, r_q]$.\n\nOutput Format:\nPrint one integer \u2014 the number of valid permutations, taken modulo $998244353$.\n\nTags:\n['combinatorics', 'data structures', 'dfs and similar', 'greedy', 'math', 'trees']\n\nTime Limit: 2000 ms\nMemory Limit: 512 MB\n",
        "tests": [
            {
                "input": "6 3\n6 4 4\n5 5 2",
                "output": "30"
            },
            {
                "input": "10 1\n10\n9",
                "output": "1814400"
            },
            {
                "input": "4 1\n2\n4",
                "output": "8"
            }
        ]
    },
    {
        "problem": "\nYou are given a rooted tree, consisting of $n$ vertices, numbered from $1$ to $n$. Vertex $1$ is the root. Additionally, the root only has one child.\n\nYou are asked to add exactly $k$ edges to the tree (possibly, multiple edges and/or edges already existing in the tree).\n\nRecall that a bridge is such an edge that, after you remove it, the number of connected components in the graph increases. So, initially, all edges of the tree are bridges.\n\nAfter $k$ edges are added, some original edges of the tree are still bridges and some are not anymore. You want to satisfy two conditions:\n\n  * for every bridge, all tree edges in the subtree of the lower vertex of that bridge should also be bridges;    * the number of bridges is as small as possible. \n\nSolve the task for all values of $k$ from $1$ to $n - 1$ and output the smallest number of bridges.\n\nInput Format:\nThe first line contains a single integer $t$ ($1 \\le t \\le 10^4$) \u2014 the number of testcases.\n\nThe first line of each testcase contains a single integer $n$ ($2 \\le n \\le 3 \\cdot 10^5$) \u2014 the number of vertices of the tree.\n\nEach of the next $n - 1$ lines contain two integers $v$ and $u$ ($1 \\le v, u \\le n$) \u2014 the description of the edges of the tree. It's guaranteed that the given edges form a valid tree.\n\nAdditional constraint on the input: the root (vertex $1$) has exactly one child.\n\nThe sum of $n$ over all testcases doesn't exceed $3 \\cdot 10^5$.\n\nOutput Format:\nFor each testcase, print $n - 1$ integers. For each $k$ from $1$ to $n - 1$ print the smallest number of bridges that can be left after you add $k$ edges to the tree.\n\nTags:\n['data structures', 'dfs and similar', 'dp', 'greedy', 'sortings', 'trees']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "4\n2\n1 2\n12\n4 10\n5 12\n12 11\n3 6\n9 6\n1 6\n12 7\n11 6\n2 11\n10 9\n10 8\n8\n1 2\n2 3\n2 4\n3 5\n3 6\n4 7\n4 8\n5\n1 2\n2 3\n3 4\n4 5",
                "output": "0 \n7 3 1 0 0 0 0 0 0 0 0 \n4 1 0 0 0 0 0 \n0 0 0 0"
            }
        ]
    },
    {
        "problem": "\nThe little boy Nikita was given some cubes as a present. He decided to build a tower out of them.\n\nInitially, the tower doesn't have any cubes. In one move, Nikita either puts exactly $1$ cube on top of the tower or removes exactly $1$ cube from the top of the tower. Is it possible that after $n$ moves, the resulting tower has exactly $m$ cubes?\n\nInput Format:\nEach test contains multiple test cases. The first line of input contains a single integer $t$ ($1 \\le t \\le 100$) \u2014 the number of test cases. The description of the test cases follows.\n\nThe only line of each test case contains two integers $n$ and $m$ ($1 \\le n, m \\le 100$).\n\nOutput Format:\nFor each test case, output \"Yes\" (without quotes) if Nikita can obtain a tower with $m$ cubes, and \"No\" (without quotes) otherwise.\n\nYou can output each letter in any case (lowercase or uppercase). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be accepted as a positive answer.\n\nTags:\n['math']\n\nTime Limit: 1000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "3\n3 3\n2 4\n5 3",
                "output": "Yes\nNo\nYes"
            }
        ]
    },
    {
        "problem": "\nYou are given a positive integer $x$. Find any array of integers $a_0, a_1, \\ldots, a_{n-1}$ for which the following holds:\n\n  * $1 \\le n \\le 32$,    * $a_i$ is $1$, $0$, or $-1$ for all $0 \\le i \\le n - 1$,    * $x = \\displaystyle{\\sum_{i=0}^{n - 1}{a_i \\cdot 2^i}}$,    * There does not exist an index $0 \\le i \\le n - 2$ such that both $a_{i} \\neq 0$ and $a_{i + 1} \\neq 0$. \n\nIt can be proven that under the constraints of the problem, a valid array always exists.\n\nInput Format:\nEach test contains multiple test cases. The first line of input contains a single integer $t$ ($1 \\le t \\le 10^4$) \u2014 the number of test cases. The description of the test cases follows.\n\nThe only line of each test case contains a single positive integer $x$ ($1 \\le x < 2^{30}$).\n\nOutput Format:\nFor each test case, output two lines.\n\nOn the first line, output an integer $n$ ($1 \\le n \\le 32$) \u2014 the length of the array $a_0, a_1, \\ldots, a_{n-1}$.\n\nOn the second line, output the array $a_0, a_1, \\ldots, a_{n-1}$.\n\nIf there are multiple valid arrays, you can output any of them.\n\nTags:\n['bitmasks', 'constructive algorithms', 'greedy', 'math']\n\nTime Limit: 1000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "7\n1\n14\n24\n15\n27\n11\n19",
                "output": "1\n1\n5\n0 -1 0 0 1\n6\n0 0 0 -1 0 1\n5\n-1 0 0 0 1\n6\n-1 0 -1 0 0 1\n5\n-1 0 -1 0 1\n5\n-1 0 1 0 1"
            }
        ]
    },
    {
        "problem": "\nNikita is a student passionate about number theory and algorithms. He faces an interesting problem related to an array of numbers.\n\nSuppose Nikita has an array of integers $a$ of length $n$. He will call a subsequence$^\\dagger$ of the array special if its [least common multiple (LCM)](https://en.wikipedia.org/wiki/Least_common_multiple) is not contained in $a$. The LCM of an empty subsequence is equal to $0$.\n\nNikita wonders: what is the length of the longest special subsequence of $a$? Help him answer this question!\n\n$^\\dagger$ A sequence $b$ is a subsequence of $a$ if $b$ can be obtained from $a$ by the deletion of several (possibly, zero or all) elements, without changing the order of the remaining elements. For example, $[5,2,3]$ is a subsequence of $[1,5,7,8,2,4,3]$.\n\nInput Format:\nEach test contains multiple test cases. The first line of input contains a single integer $t$ ($1 \\le t \\le 2000$) \u2014 the number of test cases. The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($1 \\le n \\le 2000$) \u2014 the length of the array $a$.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\le a_i \\le 10^9$) \u2014 the elements of the array $a$.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2000$.\n\nOutput Format:\nFor each test case, output a single integer \u2014 the length of the longest special subsequence of $a$.\n\nTags:\n['brute force', 'data structures', 'dp', 'greedy', 'math', 'number theory', 'sortings']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "6\n5\n1 2 4 8 16\n6\n3 2 10 20 60 1\n7\n2 3 4 6 12 100003 1200036\n9\n2 42 7 3 6 7 7 1 6\n8\n4 99 57 179 10203 2 11 40812\n1\n1",
                "output": "0\n4\n4\n5\n8\n0"
            }
        ]
    },
    {
        "problem": "\nYou are given a binary (consisting only of 0s and 1s) $n \\times m$ matrix. You are also given a XORificator, using which you can invert all the values in a chosen row (i.e. replace 0 with 1 and 1 with 0).\n\nA column in the matrix is considered special if it contains exactly one 1. Your task is to find the maximum number of columns that can be made special at the same time, and the set of rows the XORificator should be used on to achieve that.\n\nInput Format:\nEach test contains multiple test cases. The first line of input contains a single integer $t$ ($1 \\le t \\le 10^4$) \u2014 the number of test cases. The description of the test cases follows.\n\nThe first line of each test case contains two integers $n$ and $m$ ($1 \\leq n, m \\leq 3 \\cdot 10^5$, $n \\cdot m \\leq 3 \\cdot 10^5$).\n\nEach of the following $n$ lines of the test case contains a binary string of length $m$.\n\nIt is guaranteed that the sum of $n \\cdot m$ over all test cases does not exceed $3 \\cdot 10^5$.\n\nOutput Format:\nFor each test case, output two lines.\n\nIn the first line, output the maximum number of special columns that is possible to get simultaneously.\n\nIn the second line, output a binary string of length $n$, where the $i$-th character is 0, if you don't use the XORificator on the $i$-th row, and 1, if you use the XORificator on the $i$-th row.\n\nIf there are multiple valid XORificator configurations that achieve the optimal answer, you can output any of them.\n\nTags:\n['bitmasks', 'brute force', 'greedy', 'hashing']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "5\n3 4\n1010\n0110\n0100\n1 1\n1\n1 1\n0\n2 5\n00101\n10110\n3 3\n101\n111\n000",
                "output": "3\n010\n1\n0\n1\n1\n3\n00\n2\n010"
            }
        ]
    },
    {
        "problem": "\nThis is an interactive problem.\n\nYou are given an integer $n$.\n\nThe jury has hidden from you a directed graph with $n$ vertices (numbered from $1$ to $n$) and some number of edges. You additionally know that:\n\n  * The graph only contains edges of the form $i \\leftarrow j$, where $1 \\le i < j \\le n$.    * For any three vertices $1 \\le i < j < k \\le n$, at least one of the following holds$^\\dagger$:      * Vertex $i$ is reachable from vertex $j$, or      * Vertex $i$ is reachable from vertex $k$, or      * Vertex $j$ is reachable from vertex $k$. \n\nYou want to color each vertex in either black or white such that for any two vertices $i$ and $j$ ($1 \\le i < j \\le n$) of the same color, vertex $i$ is reachable from vertex $j$.\n\nTo do that, you can ask queries of the following type:\n\n  * ? i j \u2014 is vertex $i$ reachable from vertex $j$ ($1 \\le i < j \\le n$)? \n\nFind any valid vertex coloring of the hidden graph in at most $2 \\cdot n$ queries. It can be proven that such a coloring always exists.\n\nNote that the grader is not adaptive: the graph is fixed before any queries are made.\n\n$^\\dagger$ Vertex $a$ is reachable from vertex $b$ if there exists a [path](https://en.wikipedia.org/wiki/Path_\\(graph_theory\\)) from vertex $b$ to vertex $a$ in the graph.\n\nInput Format:\nEach test contains multiple test cases. The first line of input contains a single integer $t$ ($1 \\le t \\le 1000$) \u2014 the number of test cases. The description of the test cases follows.\n\nThe only line of each test case contains a single integer $n$ ($3 \\le n \\le 100$) \u2014 the number of vertices in the hidden graph.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $1000$.\n\nOutput Format:\n\n\nTags:\n['constructive algorithms', 'graphs', 'interactive']\n\nTime Limit: 3000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "2\n4\n\nYES\n\nYES\n\nYES\n\nNO\n\nNO\n\nNO\n\n5",
                "output": "? 1 2\n\n? 2 3\n\n? 1 3\n\n? 1 4\n\n? 2 4\n\n? 3 4\n\n! 0 0 0 1\n\n! 1 1 0 1 0"
            }
        ]
    },
    {
        "problem": "\nAlice has $n$ books. The $1$-st book contains $a_1$ pages, the $2$-nd book contains $a_2$ pages, $\\ldots$, the $n$-th book contains $a_n$ pages. Alice does the following:\n\n  * She divides all the books into two non-empty piles. Thus, each book ends up in exactly one of the two piles.   * Alice reads one book with the highest number in each pile.\n\nAlice loves reading very much. Help her find the maximum total number of pages she can read by dividing the books into two piles.\n\nInput Format:\nEach test consists of multiple test cases. The first line contains a single integer $t$ ($1 \\le t \\le 500$) \u2014 the number of test cases. The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($2 \\le n \\le 100$) \u2014 the number of books Alice has.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\le a_i \\le 10^9$) \u2014 the number of pages in each book.\n\nOutput Format:\nFor each test case, output a single integer \u2014 the maximum number of pages Alice can read.\n\nTags:\n['constructive algorithms', 'greedy', 'sortings']\n\nTime Limit: 1000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "5\n2\n1 1\n4\n2 3 3 1\n5\n2 2 3 2 2\n2\n10 3\n3\n1 2 3",
                "output": "2\n4\n5\n13\n5"
            }
        ]
    },
    {
        "problem": "\nBob decided to open a bakery. On the opening day, he baked $n$ buns that he can sell. The usual price of a bun is $a$ coins, but to attract customers, Bob organized the following promotion:\n\n  * Bob chooses some integer $k$ ($0 \\le k \\le \\min(n, b)$).   * Bob sells the first $k$ buns at a modified price. In this case, the price of the $i$-th ($1 \\le i \\le k$) sold bun is $(b - i + 1)$ coins.   * The remaining $(n - k)$ buns are sold at $a$ coins each.\n\nNote that $k$ can be equal to $0$. In this case, Bob will sell all the buns at $a$ coins each.\n\nHelp Bob determine the maximum profit he can obtain by selling all $n$ buns.\n\nInput Format:\nEach test consists of multiple test cases. The first line contains a single integer $t$ ($1 \\le t \\le 10^4$) \u2014 the number of test cases. The description of the test cases follows.\n\nThe only line of each test case contains three integers $n$, $a$, and $b$ ($1 \\le n, a, b \\le 10^9$) \u2014 the number of buns, the usual price of a bun, and the price of the first bun to be sold at a modified price.\n\nOutput Format:\nFor each test case, output a single integer \u2014 the maximum profit that Bob can obtain.\n\nTags:\n['binary search', 'greedy', 'math', 'ternary search']\n\nTime Limit: 1000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "7\n4 4 5\n5 5 9\n10 10 5\n5 5 11\n1000000000 1000000000 1000000000\n1000000000 1000000000 1\n1000 1 1000",
                "output": "17\n35\n100\n45\n1000000000000000000\n1000000000000000000\n500500"
            }
        ]
    },
    {
        "problem": "\nLet's call the Manhattan value of a permutation$^{\\dagger}$ $p$ the value of the expression $|p_1 - 1| + |p_2 - 2| + \\ldots + |p_n - n|$.\n\nFor example, for the permutation $[1, 2, 3]$, the Manhattan value is $|1 - 1| + |2 - 2| + |3 - 3| = 0$, and for the permutation $[3, 1, 2]$, the Manhattan value is $|3 - 1| + |1 - 2| + |2 - 3| = 2 + 1 + 1 = 4$.\n\nYou are given integers $n$ and $k$. Find a permutation $p$ of length $n$ such that its Manhattan value is equal to $k$, or determine that no such permutation exists.\n\n$^{\\dagger}$A permutation of length $n$ is an array consisting of $n$ distinct integers from $1$ to $n$ in arbitrary order. For example, $[2,3,1,5,4]$ is a permutation, but $[1,2,2]$ is not a permutation ($2$ appears twice in the array), and $[1,3,4]$ is also not a permutation ($n=3$ but there is $4$ in the array).\n\nInput Format:\nEach test consists of multiple test cases. The first line contains a single integer $t$ ($1 \\leq t \\leq 10^{4}$) \u2014 the number of test cases. The description of the test cases follows.\n\nThe only line of each test case contains two integers $n$ and $k$ ($1 \\le n \\le 2 \\cdot 10^{5}, 0 \\le k \\le 10^{12}$) \u2014 the length of the permutation and the required Manhattan value.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^{5}$.\n\nOutput Format:\nFor each test case, if there is no suitable permutation, output \"No\". Otherwise, in the first line, output \"Yes\", and in the second line, output $n$ distinct integers $p_1, p_2, \\ldots, p_n$ ($1 \\le p_i \\le n$) \u2014 a suitable permutation.\n\nIf there are multiple solutions, output any of them.\n\nYou can output the answer in any case (for example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as a positive answer).\n\nTags:\n['constructive algorithms', 'data structures', 'greedy', 'implementation', 'math']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "8\n3 4\n4 5\n7 0\n1 1000000000000\n8 14\n112 777\n5 12\n5 2",
                "output": "Yes\n3 1 2\nNo\nYes\n1 2 3 4 5 6 7\nNo\nYes\n8 2 3 4 5 6 1 7\nNo\nYes\n5 4 3 1 2\nYes\n2 1 3 4 5"
            }
        ]
    },
    {
        "problem": "\nElections are taking place in Berland. There are $n$ candidates participating in the elections, numbered from $1$ to $n$. The $i$-th candidate has $a_i$ fans who will vote for him. Additionally, there are $c$ people who are undecided about their favorite candidate, let's call them undecided. Undecided people will vote for the candidate with the lowest number.\n\nThe candidate who receives the maximum number of votes wins the elections, and if multiple candidates receive the same maximum number of votes, the candidate with the lowest number among them wins.\n\nYou found these elections too boring and predictable, so you decided to exclude some candidates from them. If you do not allow candidate number $i$ to participate in the elections, all $a_i$ of his fans will become undecided, and will vote for the candidate with the lowest number.\n\nYou are curious to find, for each $i$ from $1$ to $n$, the minimum number of candidates that need to be excluded from the elections for candidate number $i$ to win the elections.\n\nInput Format:\nEach test consists of multiple test cases. The first line contains a single integer $t$ ($1 \\leq t \\leq 2 \\cdot 10^4$) \u2014 the number of test cases. The description of the test cases follows.\n\nThe first line of each test case contains two integers $n$ and $c$ ($1 \\le n \\le 2 \\cdot 10^5$, $0 \\le c \\le 10^9$) \u2014 the number of candidates in the elections and the number of undecided people.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($0 \\le a_i \\le 10^9$) \u2014 the number of fans for each candidate.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\nOutput Format:\nFor each test case, output $n$ integers, the $i$-th of which should be equal to the minimum number of candidates that need to be excluded from the elections for candidate number $i$ to win.\n\nTags:\n['data structures', 'greedy', 'implementation', 'math']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "5\n3 1\n2 0 3\n2 3\n0 10\n5 3\n5 4 3 2 1\n4 5\n3 10 7 1\n6 0\n2 2 2 3 3 3",
                "output": "0 1 2\n1 0\n0 1 2 3 4\n1 0 2 3\n1 1 2 0 4 5"
            }
        ]
    },
    {
        "problem": "\nSasha has two binary strings $s$ and $t$ of the same length $n$, consisting of the characters 0 and 1.\n\nThere is also a computing machine that can perform two types of operations on binary strings $a$ and $b$ of the same length $k$:\n\n  1. If $a_{i} = a_{i + 2} =$ 0, then you can assign $b_{i + 1} :=$ 1 ($1 \\le i \\le k - 2$).    2. If $b_{i} = b_{i + 2} =$ 1, then you can assign $a_{i + 1} :=$ 1 ($1 \\le i \\le k - 2$). \n\nSasha became interested in the following: if we consider the string $a=s_ls_{l+1}\\ldots s_r$ and the string $b=t_lt_{l+1}\\ldots t_r$, what is the maximum number of 1 characters in the string $a$ that can be obtained using the computing machine. Since Sasha is very curious but lazy, it is up to you to answer this question for several pairs $(l_i, r_i)$ that interest him.\n\nInput Format:\nEach test consists of multiple test cases. The first line contains a single integer $t$ ($1 \\le t \\le 10^{4}$) \u2014 the number of test cases. The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($1 \\le n \\le 2 \\cdot 10^5$) \u2014 the length of the strings $s$ and $t$.\n\nThe second line of each test case contains a binary string $s$ of length $n$, consisting of the characters 0 and 1.\n\nThe third line of each test case contains a binary string $t$ of length $n$, consisting of the characters 0 and 1.\n\nThe fourth line of each test case contains a single integer $q$ ($1 \\le q \\le 2 \\cdot 10^5$) \u2014 the number of queries.\n\nThe $i$-th of the following lines contains two integers $l_{i}$ and $r_{i}$ ($1 \\le l_{i} \\le r_{i} \\le n$) \u2014 the boundaries of the $i$-th pair of substrings that interest Sasha.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$ and the sum of $q$ over all test cases does not exceed $2 \\cdot 10^5$.\n\nOutput Format:\nFor each test case, output $q$ integers \u2014 the answers to all queries.\n\nTags:\n['brute force', 'data structures', 'dp', 'greedy', 'implementation']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "3\n4\n1111\n0000\n2\n1 2\n2 4\n4\n1010\n1101\n2\n1 3\n1 4\n6\n010101\n011010\n5\n2 3\n1 6\n2 5\n4 4\n3 6",
                "output": "2\n3\n2\n3\n1\n4\n3\n1\n2"
            }
        ]
    },
    {
        "problem": "\nGiven an array $a$ of length $n$. Let's construct a square matrix $b$ of size $n \\times n$, in which the $i$-th row contains the array $a$ cyclically shifted to the right by $(i - 1)$. For example, for the array $a = [3, 4, 5]$, the obtained matrix is\n\n$$b = \\begin{bmatrix} 3 & 4 & 5 \\\\\\ 5 & 3 & 4 \\\\\\ 4 & 5 & 3 \\end{bmatrix}$$\n\nLet's construct the following graph:\n\n  * The graph contains $n^2$ vertices, each of which corresponds to one of the elements of the matrix. Let's denote the vertex corresponding to the element $b_{i, j}$ as $(i, j)$.   * We will draw an edge between vertices $(i_1, j_1)$ and $(i_2, j_2)$ if $|i_1 - i_2| + |j_1 - j_2| \\le k$ and $\\gcd(b_{i_1, j_1}, b_{i_2, j_2}) > 1$, where $\\gcd(x, y)$ denotes the [greatest common divisor](https://en.wikipedia.org/wiki/Greatest_common_divisor) of integers $x$ and $y$. \n\nYour task is to calculate the number of connected components$^{\\dagger}$ in the obtained graph.\n\n$^{\\dagger}$A connected component of a graph is a set of vertices in which any vertex is reachable from any other via edges, and adding any other vertex to the set violates this rule.\n\nInput Format:\nEach test consists of multiple test cases. The first line contains a single integer $t$ ($1 \\leq t \\leq 10^5$) \u2014 the number of test cases. The description of the test cases follows.\n\nThe first line of each test case contains two integers $n$ and $k$ ($2 \\le n \\le 10^6$, $2 \\le k \\le 2 \\cdot 10^6$) \u2014 the length of the array and the parameter $k$.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\le a_i \\le 10^6$) \u2014 the elements of the array $a$.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $10^6$.\n\nOutput Format:\nFor each test case, output a single integer \u2014 the number of connected components in the obtained graph.\n\nTags:\n['data structures', 'dfs and similar', 'dsu', 'graphs', 'number theory', 'two pointers']\n\nTime Limit: 4000 ms\nMemory Limit: 512 MB\n",
        "tests": [
            {
                "input": "6\n3 3\n3 4 5\n3 3\n3 4 9\n3 2\n3 4 9\n2 2\n2 8\n5 3\n8 27 5 4 3\n4 10\n2 2 2 2",
                "output": "3\n2\n3\n1\n4\n1"
            }
        ]
    },
    {
        "problem": "\nAlice and Bob came up with a rather strange game. They have an array of integers $a_1, a_2,\\ldots, a_n$. Alice chooses a certain integer $k$ and tells it to Bob, then the following happens:\n\n  * Bob chooses two integers $i$ and $j$ ($1 \\le i < j \\le n$), and then finds the maximum among the integers $a_i, a_{i + 1},\\ldots, a_j$;    * If the obtained maximum is strictly greater than $k$, Alice wins, otherwise Bob wins. \n\nHelp Alice find the maximum $k$ at which she is guaranteed to win.\n\nInput Format:\nEach test consists of multiple test cases. The first line contains a single integer $t$ ($1 \\le t \\le 10^4$) \u2014 the number of test cases. The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($2 \\le n \\le 5 \\cdot 10^4$) \u2014 the number of elements in the array.\n\nThe second line of each test case contains $n$ integers $a_1, a_2,\\ldots, a_n$ ($1 \\le a_i \\le 10^9$) \u2014 the elements of the array.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $5 \\cdot 10^4$.\n\nOutput Format:\nFor each test case, output one integer \u2014 the maximum integer $k$ at which Alice is guaranteed to win.\n\nTags:\n['brute force', 'greedy', 'implementation']\n\nTime Limit: 1000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "6\n4\n2 4 1 7\n5\n1 2 3 4 5\n2\n1 1\n3\n37 8 16\n5\n10 10 10 10 9\n10\n3 12 9 5 2 3 2 9 8 2",
                "output": "3\n1\n0\n15\n9\n2"
            }
        ]
    },
    {
        "problem": "\nYou are given two distinct non-negative integers $x$ and $y$. Consider two infinite sequences $a_1, a_2, a_3, \\ldots$ and $b_1, b_2, b_3, \\ldots$, where\n\n  * $a_n = n \\oplus x$;    * $b_n = n \\oplus y$. \n\nHere, $x \\oplus y$ denotes the [bitwise XOR](https://en.wikipedia.org/wiki/Bitwise_operation#XOR) operation of integers $x$ and $y$.\n\nFor example, with $x = 6$, the first $8$ elements of sequence $a$ will look as follows: $[7, 4, 5, 2, 3, 0, 1, 14, \\ldots]$. Note that the indices of elements start with $1$.\n\nYour task is to find the length of the longest common subsegment$^\\dagger$ of sequences $a$ and $b$. In other words, find the maximum integer $m$ such that $a_i = b_j, a_{i + 1} = b_{j + 1}, \\ldots, a_{i + m - 1} = b_{j + m - 1}$ for some $i, j \\ge 1$.\n\n$^\\dagger$A subsegment of sequence $p$ is a sequence $p_l,p_{l+1},\\ldots,p_r$, where $1 \\le l \\le r$.\n\nInput Format:\nEach test consists of multiple test cases. The first line contains a single integer $t$ ($1 \\le t \\le 10^4$) \u2014 the number of test cases. The description of the test cases follows.\n\nThe only line of each test case contains two integers $x$ and $y$ ($0 \\le x, y \\le 10^9, x \\neq y$) \u2014 the parameters of the sequences.\n\nOutput Format:\nFor each test case, output a single integer \u2014 the length of the longest common subsegment.\n\nTags:\n['bitmasks', 'greedy']\n\nTime Limit: 1000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "4\n0 1\n12 4\n57 37\n316560849 14570961",
                "output": "1\n8\n4\n33554432"
            }
        ]
    },
    {
        "problem": "\nYou have been offered to play a game. In this game, there are $n$ possible outcomes, and for each of them, you must bet a certain integer amount of coins. In the event that the $i$-th outcome turns out to be winning, you will receive back the amount of coins equal to your bet on that outcome, multiplied by $k_i$. Note that exactly one of the $n$ outcomes will be winning.\n\nYour task is to determine how to distribute the coins in such a way that you will come out ahead in the event of any winning outcome. More formally, the total amount of coins you bet on all outcomes must be strictly less than the number of coins received back for each possible winning outcome.\n\nInput Format:\nEach test consists of multiple test cases. The first line contains a single integer $t$ ($1 \\le t \\le 10^4$) \u2014 the number of test cases. The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($1 \\le n \\le 50$) \u2014 the number of outcomes.\n\nThe second line of each test case contains $n$ integers $k_1,k_2,\\ldots,k_n$ ($2 \\le k_i \\le 20$) \u2014 the multiplier for the amount of coins if the $i$-th outcome turns out to be winning.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\nOutput Format:\nFor each test case, output $-1$ if there is no way to distribute the coins as required. Otherwise, output $n$ integers $x_1, x_2,\\ldots, x_n$ ($1 \\le x_i \\le 10^{9}$) \u2014 your bets on the outcomes.\n\nIt can be shown that if a solution exists, there is always a solution that satisfies these constraints.\n\nIf there are multiple suitable solutions, output any of them.\n\nTags:\n['binary search', 'combinatorics', 'constructive algorithms', 'number theory']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "6\n3\n3 2 7\n2\n3 3\n5\n5 5 5 5 5\n6\n7 9 3 17 9 13\n3\n6 3 2\n5\n9 4 6 8 3",
                "output": "27 41 12 \n1 1 \n-1\n1989 1547 4641 819 1547 1071 \n-1\n8 18 12 9 24"
            }
        ]
    },
    {
        "problem": "\nYou are given a binary string $s$ of length $n$, consisting of zeros and ones. You can perform the following operation exactly once:\n\n  1. Choose an integer $p$ ($1 \\le p \\le n$).    2. Reverse the substring $s_1 s_2 \\ldots s_p$. After this step, the string $s_1 s_2 \\ldots s_n$ will become $s_p s_{p-1} \\ldots s_1 s_{p+1} s_{p+2} \\ldots s_n$.    3. Then, perform a cyclic shift of the string $s$ to the left $p$ times. After this step, the initial string $s_1s_2 \\ldots s_n$ will become $s_{p+1}s_{p+2} \\ldots s_n s_p s_{p-1} \\ldots s_1$. \n\nFor example, if you apply the operation to the string 110001100110 with $p=3$, after the second step, the string will become 011001100110, and after the third step, it will become 001100110011.\n\nA string $s$ is called $k$-proper if two conditions are met:\n\n  * $s_1=s_2=\\ldots=s_k$;    * $s_{i+k} \\neq s_i$ for any $i$ ($1 \\le i \\le n - k$). \n\nFor example, with $k=3$, the strings 000, 111000111, and 111000 are $k$-proper, while the strings 000000, 001100, and 1110000 are not.\n\nYou are given an integer $k$, which is a divisor of $n$. Find an integer $p$ ($1 \\le p \\le n$) such that after performing the operation, the string $s$ becomes $k$-proper, or determine that it is impossible. Note that if the string is initially $k$-proper, you still need to apply exactly one operation to it.\n\nInput Format:\nEach test consists of multiple test cases. The first line contains one integer $t$ ($1 \\le t \\le 10^4$) \u2014 the number of test cases. The description of the test cases follows.\n\nThe first line of each test case contains two integers $n$ and $k$ ($1 \\le k \\le n$, $2 \\le n \\le 10^5$) \u2014 the length of the string $s$ and the value of $k$. It is guaranteed that $k$ is a divisor of $n$.\n\nThe second line of each test case contains a binary string $s$ of length $n$, consisting of the characters 0 and 1.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\nOutput Format:\nFor each test case, output a single integer \u2014 the value of $p$ to make the string $k$-proper, or $-1$ if it is impossible.\n\nIf there are multiple solutions, output any of them.\n\nTags:\n['bitmasks', 'brute force', 'constructive algorithms', 'dp', 'greedy', 'hashing', 'strings']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "7\n8 4\n11100001\n4 2\n1110\n12 3\n111000100011\n5 5\n00000\n6 1\n101001\n8 4\n01110001\n12 2\n110001100110",
                "output": "3\n-1\n7\n5\n4\n-1\n3"
            }
        ]
    },
    {
        "problem": "\nThe Manhattan distance between two points $(x_1, y_1)$ and $(x_2, y_2)$ is defined as: $$|x_1 - x_2| + |y_1 - y_2|.$$\n\nWe call a Manhattan triangle three points on the plane, the Manhattan distances between each pair of which are equal.\n\nYou are given a set of pairwise distinct points and an even integer $d$. Your task is to find any Manhattan triangle, composed of three distinct points from the given set, where the Manhattan distance between any pair of vertices is equal to $d$.\n\nInput Format:\nEach test consists of multiple test cases. The first line contains one integer $t$ ($1 \\le t \\le 10^4$) \u2014 the number of test cases. The description of the test cases follows.\n\nThe first line of each test case contains two integers $n$ and $d$ ($3 \\le n \\le 2 \\cdot 10^5$, $2 \\le d \\le 4 \\cdot 10^5$, $d$ is even) \u2014 the number of points and the required Manhattan distance between the vertices of the triangle.\n\nThe $(i + 1)$-th line of each test case contains two integers $x_i$ and $y_i$ ($-10^5 \\le x_i, y_i \\le 10^5$) \u2014 the coordinates of the $i$-th point. It is guaranteed that all points are pairwise distinct.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\nOutput Format:\nFor each test case, output three distinct integers $i$, $j$, and $k$ ($1 \\le i,j,k \\le n$) \u2014 the indices of the points forming the Manhattan triangle. If there is no solution, output \"$0\\ 0\\ 0$\" (without quotes).\n\nIf there are multiple solutions, output any of them.\n\nTags:\n['binary search', 'constructive algorithms', 'data structures', 'geometry', 'implementation', 'two pointers']\n\nTime Limit: 3000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "6\n6 4\n3 1\n0 0\n0 -2\n5 -3\n3 -5\n2 -2\n5 4\n0 0\n0 -2\n5 -3\n3 -5\n2 -2\n6 6\n3 1\n0 0\n0 -2\n5 -3\n3 -5\n2 -2\n4 4\n3 0\n0 3\n-3 0\n0 -3\n10 8\n2 1\n-5 -1\n-4 -1\n-5 -3\n0 1\n-2 5\n-4 4\n-4 2\n0 0\n-4 1\n4 400000\n100000 100000\n-100000 100000\n100000 -100000\n-100000 -100000",
                "output": "2 6 1\n4 3 5\n3 5 1\n0 0 0\n6 1 3\n0 0 0"
            }
        ]
    },
    {
        "problem": "\nThis is an interactive problem.\n\nKostyanych has chosen a complete undirected graph$^{\\dagger}$ with $n$ vertices, and then removed exactly $(n - 2)$ edges from it. You can ask queries of the following type:\n\n  * \"? $d$\" \u2014 Kostyanych tells you the number of vertex $v$ with a degree at least $d$. Among all possible such vertices, he selects the vertex with the minimum degree, and if there are several such vertices, he selects the one with the minimum number. He also tells you the number of another vertex in the graph, with which $v$ is not connected by an edge (if none is found, then $0$ is reported). Among all possible such vertices, he selects the one with the minimum number. Then he removes the vertex $v$ and all edges coming out of it. If the required vertex $v$ is not found, then \"$0\\ 0$\" is reported. \n\nFind a Hamiltonian path$^{\\ddagger}$ in the original graph in at most $n$ queries. It can be proven that under these constraints, a Hamiltonian path always exists.\n\n$^{\\dagger}$A complete undirected graph is a graph in which there is exactly one undirected edge between any pair of distinct vertices. Thus, a complete undirected graph with $n$ vertices contains $\\frac{n(n-1)}{2}$ edges.\n\n$^{\\ddagger}$A Hamiltonian path in a graph is a path that passes through each vertex exactly once.\n\nInput Format:\nEach test consists of multiple test cases. The first line contains a single integer $t$ ($1 \\le t \\le 1000$) \u2014 the number of test cases. The description of the test cases follows.\n\nThe only line of each test case contains a single integer $n$ ($2 \\le n \\le 10^5$) \u2014 the number of vertices in the graph.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $10^5$.\n\nOutput Format:\n\n\nTags:\n['brute force', 'constructive algorithms', 'graphs', 'interactive']\n\nTime Limit: 3000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "3\n4\n\n0 0\n\n1 4\n\n2 3\n\n4\n\n1 0\n\n4 2\n\n2\n\n1 0",
                "output": "? 3\n\n? 2\n\n? 1\n\n! 4 3 1 2\n\n? 3\n\n? 0\n\n! 4 1 2 3\n\n? 0\n\n! 2 1"
            }
        ]
    },
    {
        "problem": "\nVlad is planning to hold $m$ rounds next month. Each round should contain one problem of difficulty levels 'A', 'B', 'C', 'D', 'E', 'F', and 'G'.\n\nVlad already has a bank of $n$ problems, where the $i$-th problem has a difficulty level of $a_i$. There may not be enough of these problems, so he may have to come up with a few more problems.\n\nVlad wants to come up with as few problems as possible, so he asks you to find the minimum number of problems he needs to come up with in order to hold $m$ rounds.\n\nFor example, if $m=1$, $n = 10$, $a=$ 'BGECDCBDED', then he needs to come up with two problems: one of difficulty level 'A' and one of difficulty level 'F'.\n\nInput Format:\nThe first line contains a single integer $t$ ($1 \\le t \\le 1000$) \u2014 the number of test cases.\n\nThe first line of each test case contains two integers $n$ and $m$ ($1 \\le n \\le 50$, $1 \\le m \\le 5$) \u2014 the number of problems in the bank and the number of upcoming rounds, respectively.\n\nThe second line of each test case contains a string $a$ of $n$ characters from 'A' to 'G' \u2014 the difficulties of the problems in the bank.\n\nOutput Format:\nFor each test case, output a single integer \u2014 the minimum number of problems that need to come up with to hold $m$ rounds.\n\nTags:\n['math']\n\nTime Limit: 1000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "3\n10 1\nBGECDCBDED\n10 2\nBGECDCBDED\n9 1\nBBCDEFFGG",
                "output": "2\n5\n1"
            }
        ]
    },
    {
        "problem": "\nDmitry has $n$ cubes, numbered from left to right from $1$ to $n$. The cube with index $f$ is his favorite.\n\nDmitry threw all the cubes on the table, and the $i$-th cube showed the value $a_i$ ($1 \\le a_i \\le 100$). After that, he arranged the cubes in non-increasing order of their values, from largest to smallest. If two cubes show the same value, they can go in any order.\n\nAfter sorting, Dmitry removed the first $k$ cubes. Then he became interested in whether he removed his favorite cube (note that its position could have changed after sorting).\n\nFor example, if $n=5$, $f=2$, $a = [4, \\color{green}3, 3, 2, 3]$ (the favorite cube is highlighted in green), and $k = 2$, the following could have happened:\n\n  * After sorting $a=[4, \\color{green}3, 3, 3, 2]$, since the favorite cube ended up in the second position, it will be removed.    * After sorting $a=[4, 3, \\color{green}3, 3, 2]$, since the favorite cube ended up in the third position, it will not be removed.\n\nInput Format:\nThe first line contains an integer $t$ ($1 \\le t \\le 1000$) \u2014 the number of test cases. Then follow the descriptions of the test cases.\n\nThe first line of each test case description contains three integers $n$, $f$, and $k$ ($1 \\le f, k \\le n \\le 100$) \u2014 the number of cubes, the index of Dmitry's favorite cube, and the number of removed cubes, respectively.\n\nThe second line of each test case description contains $n$ integers $a_i$ ($1 \\le a_i \\le 100$) \u2014 the values shown on the cubes.\n\nOutput Format:\nFor each test case, output one line \u2014 \"YES\" if the cube will be removed in all cases, \"NO\" if it will not be removed in any case, \"MAYBE\" if it may be either removed or left.\n\nYou can output the answer in any case. For example, the strings \"YES\", \"nO\", \"mAyBe\" will be accepted as answers.\n\nTags:\n['sortings', 'sortings']\n\nTime Limit: 1000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "12\n5 2 2\n4 3 3 2 3\n5 5 3\n4 2 1 3 5\n5 5 2\n5 2 4 1 3\n5 5 5\n1 2 5 4 3\n5 5 4\n3 1 2 4 5\n5 5 5\n4 3 2 1 5\n6 5 3\n1 2 3 1 2 3\n10 1 1\n1 1 1 1 1 1 1 1 1 1\n1 1 1\n42\n5 2 3\n2 2 1 1 2\n2 1 1\n2 1\n5 3 1\n3 3 2 3 2",
                "output": "MAYBE\nYES\nNO\nYES\nYES\nYES\nMAYBE\nMAYBE\nYES\nYES\nYES\nNO"
            }
        ]
    },
    {
        "problem": "\nSofia had an array of $n$ integers $a_1, a_2, \\ldots, a_n$. One day she got bored with it, so she decided to sequentially apply $m$ modification operations to it.\n\nEach modification operation is described by a pair of numbers $\\langle c_j, d_j \\rangle$ and means that the element of the array with index $c_j$ should be assigned the value $d_j$, i.e., perform the assignment $a_{c_j} = d_j$. After applying all modification operations sequentially, Sofia discarded the resulting array.\n\nRecently, you found an array of $n$ integers $b_1, b_2, \\ldots, b_n$. You are interested in whether this array is Sofia's array. You know the values of the original array, as well as the values $d_1, d_2, \\ldots, d_m$. The values $c_1, c_2, \\ldots, c_m$ turned out to be lost.\n\nIs there a sequence $c_1, c_2, \\ldots, c_m$ such that the sequential application of modification operations $\\langle c_1, d_1, \\rangle, \\langle c_2, d_2, \\rangle, \\ldots, \\langle c_m, d_m \\rangle$ to the array $a_1, a_2, \\ldots, a_n$ transforms it into the array $b_1, b_2, \\ldots, b_n$?\n\nInput Format:\nThe first line contains an integer $t$ ($1 \\le t \\le 10^4$) \u2014 the number of test cases.\n\nThen follow the descriptions of the test cases.\n\nThe first line of each test case contains an integer $n$ ($1 \\le n \\le 2 \\cdot 10^5$) \u2014 the size of the array.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\le a_i \\le 10^9$) \u2014 the elements of the original array.\n\nThe third line of each test case contains $n$ integers $b_1, b_2, \\ldots, b_n$ ($1 \\le b_i \\le 10^9$) \u2014 the elements of the found array.\n\nThe fourth line contains an integer $m$ ($1 \\le m \\le 2 \\cdot 10^5$) \u2014 the number of modification operations.\n\nThe fifth line contains $m$ integers $d_1, d_2, \\ldots, d_m$ ($1 \\le d_j \\le 10^9$) \u2014 the preserved value for each modification operation.\n\nIt is guaranteed that the sum of the values of $n$ for all test cases does not exceed $2 \\cdot 10^5$, similarly the sum of the values of $m$ for all test cases does not exceed $2 \\cdot 10^5$.\n\nOutput Format:\nOutput $t$ lines, each of which is the answer to the corresponding test case. As an answer, output \"YES\" if there exists a suitable sequence $c_1, c_2, \\ldots, c_m$, and \"NO\" otherwise.\n\nYou can output the answer in any case (for example, the strings \"yEs\", \"yes\", \"Yes\" and \"YES\" will be recognized as a positive answer).\n\nTags:\n['constructive algorithms', 'greedy']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "7\n3\n1 2 1\n1 3 2\n4\n1 3 1 2\n4\n1 2 3 5\n2 1 3 5\n2\n2 3\n5\n7 6 1 10 10\n3 6 1 11 11\n3\n4 3 11\n4\n3 1 7 8\n2 2 7 10\n5\n10 3 2 2 1\n5\n5 7 1 7 9\n4 10 1 2 9\n8\n1 1 9 8 7 2 10 4\n4\n1000000000 203 203 203\n203 1000000000 203 1000000000\n2\n203 1000000000\n1\n1\n1\n5\n1 3 4 5 1",
                "output": "YES\nNO\nNO\nNO\nYES\nNO\nYES"
            }
        ]
    },
    {
        "problem": "\nGCD (Greatest Common Divisor) of two integers $x$ and $y$ is the maximum integer $z$ by which both $x$ and $y$ are divisible. For example, $GCD(36, 48) = 12$, $GCD(5, 10) = 5$, and $GCD(7,11) = 1$.\n\nKristina has an array $a$ consisting of exactly $n$ positive integers. She wants to count the GCD of each neighbouring pair of numbers to get a new array $b$, called GCD-sequence.\n\nSo, the elements of the GCD-sequence $b$ will be calculated using the formula $b_i = GCD(a_i, a_{i + 1})$ for $1 \\le i \\le n - 1$.\n\nDetermine whether it is possible to remove exactly one number from the array $a$ so that the GCD sequence $b$ is non-decreasing (i.e., $b_i \\le b_{i+1}$ is always true).\n\nFor example, let Khristina had an array $a$ = [$20, 6, 12, 3, 48, 36$]. If she removes $a_4 = 3$ from it and counts the GCD-sequence of $b$, she gets:\n\n  * $b_1 = GCD(20, 6) = 2$    * $b_2 = GCD(6, 12) = 6$    * $b_3 = GCD(12, 48) = 12$    * $b_4 = GCD(48, 36) = 12$ \n\nThe resulting GCD sequence $b$ = [$2,6,12,12$] is non-decreasing because $b_1 \\le b_2 \\le b_3 \\le b_4$.\n\nInput Format:\nThe first line of input data contains a single number $t$ ($1 \\le t \\le 10^4$) \u2014 he number of test cases in the test.\n\nThis is followed by the descriptions of the test cases.\n\nThe first line of each test case contains a single integer $n$ ($3 \\le n \\le 2 \\cdot 10^5$) \u2014 the number of elements in the array $a$.\n\nThe second line of each test case contains exactly $n$ integers $a_i$ ($1 \\le a_i \\le 10^9$) \u2014 the elements of array $a$.\n\nIt is guaranteed that the sum of $n$ over all test case does not exceed $2 \\cdot 10^5$.\n\nOutput Format:\nFor each test case, output a single line:\n\n  * \"YES\" if you can remove exactly one number from the array $a$ so that the GCD-sequence of $b$ is non-decreasing;    * \"NO\" otherwise. \n\nYou can output the answer in any case (for example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will all be recognized as a positive answer).\n\nTags:\n['greedy', 'implementation', 'math', 'number theory']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "12\n6\n20 6 12 3 48 36\n4\n12 6 3 4\n3\n10 12 3\n5\n32 16 8 4 2\n5\n100 50 2 10 20\n4\n2 4 8 1\n10\n7 4 6 2 4 5 1 4 2 8\n7\n5 9 6 8 5 9 2\n6\n11 14 8 12 9 3\n9\n5 7 3 10 6 3 12 6 3\n3\n4 2 4\n8\n1 6 11 12 6 12 3 6",
                "output": "YES\nNO\nYES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\nYES\nYES"
            }
        ]
    },
    {
        "problem": "\nYou have been given a matrix $a$ of size $n$ by $m$, containing a permutation of integers from $1$ to $n \\cdot m$.\n\nA permutation of $n$ integers is an array containing all numbers from $1$ to $n$ exactly once. For example, the arrays $[1]$, $[2, 1, 3]$, $[5, 4, 3, 2, 1]$ are permutations, while the arrays $[1, 1]$, $[100]$, $[1, 2, 4, 5]$ are not.\n\nA matrix contains a permutation if, when all its elements are written out, the resulting array is a permutation. Matrices $[[1, 2], [3, 4]]$, $[[1]]$, $[[1, 5, 3], [2, 6, 4]]$ contain permutations, while matrices $[[2]]$, $[[1, 1], [2, 2]]$, $[[1, 2], [100, 200]]$ do not.\n\nYou can perform one of the following two actions in one operation:\n\n  * choose columns $c$ and $d$ ($1 \\le c, d \\le m$, $c \\ne d$) and swap these columns;    * choose rows $c$ and $d$ ($1 \\le c, d \\le n$, $c \\ne d$) and swap these rows. \n\nYou can perform any number of operations.\n\nYou are given the original matrix $a$ and the matrix $b$. Your task is to determine whether it is possible to transform matrix $a$ into matrix $b$ using the given operations.\n\nInput Format:\nThe first line contains an integer $t$ ($1 \\le t \\le 10^4$) \u2014 the number of test cases. The descriptions of the test cases follow.\n\nThe first line of each test case description contains $2$ integers $n$ and $m$ ($1 \\le n, m \\le n \\cdot m \\le 2 \\cdot 10^5$) \u2014 the sizes of the matrix.\n\nThe next $n$ lines contain $m$ integers $a_{ij}$ each ($1 \\le a_{ij} \\le n \\cdot m$). It is guaranteed that matrix $a$ is a permutation.\n\nThe next $n$ lines contain $m$ integers $b_{ij}$ each ($1 \\le b_{ij} \\le n \\cdot m$). It is guaranteed that matrix $b$ is a permutation.\n\nIt is guaranteed that the sum of the values $n \\cdot m$ for all test cases does not exceed $2 \\cdot 10^5$.\n\nOutput Format:\nFor each test case, output \"YES\" if the second matrix can be obtained from the first, and \"NO\" otherwise.\n\nYou can output each letter in any case (lowercase or uppercase). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be accepted as a positive answer.\n\nTags:\n['constructive algorithms', 'data structures', 'greedy', 'hashing', 'implementation', 'math', 'matrices', 'sortings']\n\nTime Limit: 3000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "7\n1 1\n1\n1\n2 2\n1 2\n3 4\n4 3\n2 1\n2 2\n1 2\n3 4\n4 3\n1 2\n3 4\n1 5 9 6\n12 10 4 8\n7 11 3 2\n1 5 9 6\n12 10 4 8\n7 11 3 2\n3 3\n1 5 9\n6 4 2\n3 8 7\n9 5 1\n2 4 6\n7 8 3\n2 3\n1 2 6\n5 4 3\n6 1 2\n3 4 5\n1 5\n5 1 2 3 4\n4 2 5 1 3",
                "output": "YES\nYES\nNO\nYES\nYES\nNO\nYES"
            }
        ]
    },
    {
        "problem": "\nThis is an easy version of the problem; it differs from the hard version only by the question. The easy version only needs you to print whether some values are non-zero or not. The hard version needs you to print the exact values.\n\nAlice and Bob are dividing the field. The field is a rectangle of size $n \\times m$ ($2 \\le n, m \\le 10^9$), the rows are numbered from $1$ to $n$ from top to bottom, and the columns are numbered from $1$ to $m$ from left to right. The cell at the intersection of row $r$ and column $c$ is denoted as ($r, c$).\n\nBob has $k$ ($2 \\le k \\le 2 \\cdot 10^5$) fountains, all of them are located in different cells of the field. Alice is responsible for dividing the field, but she must meet several conditions:\n\n  * To divide the field, Alice will start her path in any free (without a fountain) cell on the left or top side of the field and will move, each time moving to the adjacent cell down or right. Her path will end on the right or bottom side of the field.    * Alice's path will divide the field into two parts \u2014 one part will belong to Alice (this part includes the cells of her path), the other part \u2014 to Bob.    * Alice will own the part that includes the cell ($n, 1$).    * Bob will own the part that includes the cell ($1, m$). \n\nAlice wants to divide the field in such a way as to get as many cells as possible.\n\nBob wants to keep ownership of all the fountains, but he can give one of them to Alice. First, output the integer $\\alpha$ \u2014 the maximum possible size of Alice's plot, if Bob does not give her any fountain (i.e., all fountains will remain on Bob's plot). Then output $k$ non-negative integers $a_1, a_2, \\dots, a_k$, where:\n\n  * $a_i=0$, if after Bob gives Alice the $i$-th fountain, the maximum possible size of Alice's plot does not increase (i.e., remains equal to $\\alpha$);    * $a_i=1$, if after Bob gives Alice the $i$-th fountain, the maximum possible size of Alice's plot increases (i.e., becomes greater than $\\alpha$).\n\nInput Format:\nThe first line contains a single integer $t$ ($1 \\le t \\le 10^4$) \u2014 the number of test cases.\n\nThe first line of each test case contains three integers $n$, $m$, and $k$ ($2 \\le n, m \\le 10^9$, $2 \\le k \\le 2 \\cdot 10^5$) \u2014 the field sizes and the number of fountains, respectively.\n\nThen follow $k$ lines, each containing two numbers $r_i$ and $c_i$ ($1 \\le r_i \\le n$, $1 \\le c_i \\le m$) \u2014 the coordinates of the cell with the $i$-th fountain. It is guaranteed that all cells are distinct and none of them is ($n, 1$).\n\nIt is guaranteed that the sum of $k$ over all test cases does not exceed $2 \\cdot 10^5$.\n\nOutput Format:\nFor each test case, first output $\\alpha$ \u2014 the maximum size of the plot that can belong to Alice if Bob does not give her any of the fountains. Then output $k$ non-negative integers $a_1, a_2, \\dots, a_k$, where:\n\n  * $a_i=0$, if after Bob gives Alice the $i$-th fountain, the maximum possible size of Alice's plot does not increase compared to the case when all $k$ fountains belong to Bob;    * $a_i=1$, if after Bob gives Alice the $i$-th fountain, the maximum possible size of Alice's plot increases compared to the case when all $k$ fountains belong to Bob. \n\nIf you output any other positive number instead of $1$ that fits into a 64-bit signed integer type, it will also be recognized as $1$. Thus, a solution to the hard version of this problem will also pass the tests for the easy version.\n\nTags:\n['data structures', 'math', 'sortings']\n\nTime Limit: 3000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "5\n2 2 3\n1 1\n1 2\n2 2\n5 5 4\n1 2\n2 2\n3 4\n4 3\n2 5 9\n1 2\n1 5\n1 1\n2 2\n2 4\n2 5\n1 4\n2 3\n1 3\n6 4 4\n6 2\n1 3\n1 4\n1 2\n3 4 5\n2 1\n3 2\n1 4\n1 3\n2 4",
                "output": "1\n1 0 1 \n11\n0 1 0 1 \n1\n0 0 1 1 0 0 0 0 0 \n6\n1 0 0 0 \n1\n1 1 0 0 0"
            }
        ]
    },
    {
        "problem": "\nThis is a hard version of the problem; it differs from the easy version only by the question. The easy version only needs you to print whether some values are non-zero or not. The hard version needs you to print the exact values.\n\nAlice and Bob are dividing the field. The field is a rectangle of size $n \\times m$ ($2 \\le n, m \\le 10^9$); the rows are numbered from $1$ to $n$ from top to bottom, and the columns are numbered from $1$ to $m$ from left to right. The cell at the intersection of row $r$ and column $c$ is denoted as ($r, c$).\n\nBob has $k$ ($2 \\le k \\le 2 \\cdot 10^5$) fountains, all of them are located in different cells of the field. Alice is responsible for dividing the field, but she must meet several conditions:\n\n  * To divide the field, Alice will start her path in any free (without a fountain) cell on the left or top side of the field and will move, each time moving to the adjacent cell down or right. Her path will end on the right or bottom side of the field.    * Alice's path will divide the field into two parts \u2014 one part will belong to Alice (this part includes the cells of her path), the other part \u2014 to Bob.    * Alice will own the part that includes the cell ($n, 1$).    * Bob will own the part that includes the cell ($1, m$). \n\nAlice wants to divide the field in such a way as to get as many cells as possible.\n\nBob wants to keep ownership of all the fountains, but he can give one of them to Alice. First, output the integer $\\alpha$ \u2014 the maximum possible size of Alice's plot, if Bob does not give her any fountain (i.e., all fountains will remain on Bob's plot).\n\nThen output $k$ non-negative integers $a_1, a_2, \\dots, a_k$, where $a_i$ is a value such that after Bob gives Alice the $i$-th fountain, the maximum size of her plot will be $\\alpha + a_i$.\n\nInput Format:\nThe first line contains a single integer $t$ ($1 \\le t \\le 10^4$) \u2014 the number of test cases.\n\nThe first line of each test case contains three integers $n$, $m$, and $k$ ($2 \\le n, m \\le 10^9$, $2 \\le k \\le 2 \\cdot 10^5$) \u2014 the field sizes and the number of fountains, respectively.\n\nThen follow $k$ lines, each containing two numbers $r_i$ and $c_i$ ($1 \\le r_i \\le n$, $1 \\le c_i \\le m$) \u2014 the coordinates of the cell with the $i$-th fountain. It is guaranteed that all cells are distinct and none of them is ($n, 1$).\n\nIt is guaranteed that the sum of $k$ over all test cases does not exceed $2 \\cdot 10^5$.\n\nOutput Format:\nFor each test case, first output $\\alpha$ \u2014 the maximum size of the plot that can belong to Alice if Bob does not give her any of the fountains. Then output $k$ non-negative integers $a_1, a_2, \\dots, a_k$, where $a_i$ is a value such that after Bob gives Alice the $i$-th fountain, the maximum size of her plot will be $\\alpha + a_i$.\n\nTags:\n['math', 'sortings']\n\nTime Limit: 3000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "5\n2 2 3\n1 1\n1 2\n2 2\n5 5 4\n1 2\n2 2\n3 4\n4 3\n2 5 9\n1 2\n1 5\n1 1\n2 2\n2 4\n2 5\n1 4\n2 3\n1 3\n6 4 4\n6 2\n1 3\n1 4\n1 2\n3 4 5\n2 1\n3 2\n1 4\n1 3\n2 4",
                "output": "1\n1 0 1 \n11\n0 1 0 4 \n1\n0 0 1 1 0 0 0 0 0 \n6\n15 0 0 0 \n1\n2 3 0 0 0"
            }
        ]
    },
    {
        "problem": "\nYasya was walking in the forest and accidentally found a tree with $n$ vertices. A tree is a connected undirected graph with no cycles.\n\nNext to the tree, the girl found an ancient manuscript with $m$ queries written on it. The queries can be of two types.\n\nThe first type of query is described by the integer $y$. The weight of each edge in the tree is replaced by the [bitwise exclusive OR](http://tiny.cc/xor_wiki_eng) of the weight of that edge and the integer $y$.\n\nThe second type is described by the vertex $v$ and the integer $x$. Yasya chooses a vertex $u$ ($1 \\le u \\le n$, $u \\neq v$) and mentally draws a bidirectional edge of weight $x$ from $v$ to $u$ in the tree.\n\nThen Yasya finds a simple cycle in the resulting graph and calculates the [bitwise exclusive OR](http://tiny.cc/xor_wiki_eng) of all the edges in it. She wants to choose a vertex $u$ such that the calculated value is maximum. This calculated value will be the answer to the query. It can be shown that such a cycle exists and is unique under the given constraints (independent of the choice of $u$). If an edge between $v$ and $u$ already existed, a simple cycle is the path $v \\to u \\to v$.\n\nNote that the second type of query is performed mentally, meaning the tree does not change in any way after it.\n\nHelp Yasya answer all the queries.\n\nInput Format:\nThe first line contains an integer $t$ ($1 \\le t \\le 10^4$) \u2014 the number of test cases.\n\nThe descriptions of the test cases follow.\n\nThe first line of each test case contains two integers $n$, $m$ ($2 \\le n \\le 2 \\cdot 10^5$, $1 \\le m \\le 2 \\cdot 10^5$) \u2014 the number of vertices in the tree and the number of queries.\n\nThe next $n - 1$ lines of each test case contain three integers $v$, $u$, $w$ ($1 \\le v, u \\le n$, $1 \\le w \\le 10^9$) \u2014 the ends of some edge in the tree and its weight.\n\nIt is guaranteed that the given set of edges forms a tree.\n\nThe next $m$ lines of each test case describe the queries:\n\n  * ^ $y$ ($1 \\le y \\le 10^9$) \u2014 parameter of the first type query;    * ? $v$ $x$ ($1 \\le v \\le n$, $1 \\le x \\le 10^9$) \u2014 parameters of the second type query. \n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$. The same is guaranteed for $m$.\n\nOutput Format:\nFor each test case, output the answers to the queries of the second type.\n\nTags:\n['bitmasks', 'data structures', 'dfs and similar', 'graphs', 'greedy', 'strings', 'trees']\n\nTime Limit: 2500 ms\nMemory Limit: 512 MB\n",
        "tests": [
            {
                "input": "2\n3 7\n1 2 1\n3 1 8\n^ 5\n? 2 9\n^ 1\n? 1 10\n^ 6\n? 3 1\n? 2 9\n5 6\n1 2 777\n3 2 2812\n4 1 16\n5 3 1000000000\n^ 4\n? 3 123\n? 5 1000000000\n^ 1000000000\n? 1 908070\n? 2 1",
                "output": "13 15 11 10 \n1000000127 2812 999756331 999999756"
            },
            {
                "input": "3\n8 4\n8 6 3\n6 3 4\n2 5 4\n7 6 2\n7 1 10\n4 1 4\n5 1 2\n^ 4\n^ 7\n? 7 8\n? 4 10\n5 6\n3 1 4\n2 3 9\n4 3 6\n5 2 10\n? 5 7\n^ 1\n^ 8\n? 4 10\n? 1 9\n? 3 6\n4 2\n2 1 4\n4 3 5\n2 3 4\n^ 13\n? 1 10",
                "output": "14 13 \n13 8 11 11 \n10"
            }
        ]
    },
    {
        "problem": "\nTurtle and Piggy are playing a number game.\n\nFirst, Turtle will choose an integer $x$, such that $l \\le x \\le r$, where $l, r$ are given. It's also guaranteed that $2l \\le r$.\n\nThen, Piggy will keep doing the following operation until $x$ becomes $1$:\n\n  * Choose an integer $p$ such that $p \\ge 2$ and $p \\mid x$ (i.e. $x$ is a multiple of $p$).    * Set $x$ to $\\frac{x}{p}$, and the score will increase by $1$. \n\nThe score is initially $0$. Both Turtle and Piggy want to maximize the score. Please help them to calculate the maximum score.\n\nInput Format:\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains two integers $l, r$ ($1 \\le l \\le r \\le 10^9, 2l \\le r$) \u2014 The range where Turtle can choose the integer from.\n\nOutput Format:\nFor each test case, output a single integer \u2014 the maximum score.\n\nTags:\n['brute force', 'greedy', 'math']\n\nTime Limit: 1000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "5\n2 4\n3 6\n2 15\n6 22\n114514 1919810",
                "output": "2\n2\n3\n4\n20"
            }
        ]
    },
    {
        "problem": "\nThere is a sequence $a_0, a_1, a_2, \\ldots$ of infinite length. Initially $a_i = i$ for every non-negative integer $i$.\n\nAfter every second, each element of the sequence will simultaneously change. $a_i$ will change to $a_{i - 1} \\mid a_i \\mid a_{i + 1}$ for every positive integer $i$. $a_0$ will change to $a_0 \\mid a_1$. Here, $|$ denotes [bitwise OR](https://en.wikipedia.org/wiki/Bitwise_operation#OR).\n\nTurtle is asked to find the value of $a_n$ after $m$ seconds. In particular, if $m = 0$, then he needs to find the initial value of $a_n$. He is tired of calculating so many values, so please help him!\n\nInput Format:\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains two integers $n, m$ ($0 \\le n, m \\le 10^9$).\n\nOutput Format:\nFor each test case, output a single integer \u2014 the value of $a_n$ after $m$ seconds.\n\nTags:\n['bitmasks', 'math']\n\nTime Limit: 1000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "9\n0 0\n0 1\n0 2\n1 0\n5 2\n10 1\n20 3\n1145 14\n19198 10",
                "output": "0\n1\n3\n1\n7\n11\n23\n1279\n19455"
            }
        ]
    },
    {
        "problem": "\nTurtle was playing with a sequence $a_1, a_2, \\ldots, a_n$ consisting of positive integers. Unfortunately, some of the integers went missing while playing.\n\nNow the sequence becomes incomplete. There may exist an arbitrary number of indices $i$ such that $a_i$ becomes $-1$. Let the new sequence be $a'$.\n\nTurtle is sad. But Turtle remembers that for every integer $i$ from $1$ to $n - 1$, either $a_i = \\left\\lfloor\\frac{a_{i + 1}}{2}\\right\\rfloor$ or $a_{i + 1} = \\left\\lfloor\\frac{a_i}{2}\\right\\rfloor$ holds for the original sequence $a$.\n\nTurtle wants you to help him complete the sequence. But sometimes Turtle makes mistakes, so you need to tell him if you can't complete the sequence.\n\nFormally, you need to find another sequence $b_1, b_2, \\ldots, b_n$ consisting of positive integers such that:\n\n  * For every integer $i$ from $1$ to $n$, if $a'_i \\ne -1$, then $b_i = a'_i$.    * For every integer $i$ from $1$ to $n - 1$, either $b_i = \\left\\lfloor\\frac{b_{i + 1}}{2}\\right\\rfloor$ or $b_{i + 1} = \\left\\lfloor\\frac{b_i}{2}\\right\\rfloor$ holds.    * For every integer $i$ from $1$ to $n$, $1 \\le b_i \\le 10^9$. \n\nIf there is no sequence $b_1, b_2, \\ldots, b_n$ that satisfies all of the conditions above, you need to report $-1$.\n\nInput Format:\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^5$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($2 \\le n \\le 2 \\cdot 10^5$) \u2014 the length of the sequence.\n\nThe second line of each test case contains $n$ integers $a'_1, a'_2, \\ldots, a'_n$ ($a'_i = -1$ or $1 \\le a'_i \\le 10^8$) \u2014 the elements of the sequence $a'$.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\nOutput Format:\nFor each test case, if there is no sequence $b_1, b_2, \\ldots, b_n$ that satisfies all of the conditions, output a single integer $-1$.\n\nOtherwise, output $n$ integers $b_1, b_2, \\ldots, b_n$ \u2014 the elements of the sequence $b_1, b_2, \\ldots, b_n$ you find. The sequence should satisfy that $1 \\le b_i \\le 10^9$ for every integer $i$ from $1$ to $n$. If there are multiple answers, print any of them.\n\nTags:\n['bitmasks', 'brute force', 'constructive algorithms', 'greedy', 'implementation', 'math']\n\nTime Limit: 3000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "9\n8\n-1 -1 -1 2 -1 -1 1 -1\n4\n-1 -1 -1 -1\n6\n3 -1 -1 -1 9 -1\n4\n-1 5 -1 6\n4\n2 -1 -1 3\n4\n1 2 3 4\n2\n4 2\n5\n-1 3 -1 3 6\n13\n-1 -1 3 -1 -1 -1 -1 7 -1 -1 3 -1 -1",
                "output": "4 9 4 2 4 2 1 2\n7 3 6 13\n3 1 2 4 9 18\n-1\n-1\n-1\n4 2\n6 3 1 3 6\n3 1 3 1 3 7 3 7 3 1 3 1 3"
            }
        ]
    },
    {
        "problem": "\nTurtle just learned how to multiply two integers in his math class, and he was very excited.\n\nThen Piggy gave him an integer $n$, and asked him to construct a sequence $a_1, a_2, \\ldots, a_n$ consisting of integers which satisfied the following conditions:\n\n  * For all $1 \\le i \\le n$, $1 \\le a_i \\le 3 \\cdot 10^5$.    * For all $1 \\le i < j \\le n - 1$, $a_i \\cdot a_{i + 1} \\ne a_j \\cdot a_{j + 1}$. \n\nOf all such sequences, Piggy asked Turtle to find the one with the minimum number of distinct elements.\n\nTurtle definitely could not solve the problem, so please help him!\n\nInput Format:\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($2 \\le n \\le 10^6$) \u2014 the length of the sequence $a$.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $10^6$.\n\nOutput Format:\nFor each test case, output $n$ integers $a_1, a_2, \\ldots, a_n$ \u2014 the elements of the sequence $a$.\n\nIf there are multiple answers, print any of them.\n\nTags:\n['constructive algorithms', 'dfs and similar', 'graphs', 'number theory']\n\nTime Limit: 3000 ms\nMemory Limit: 512 MB\n",
        "tests": [
            {
                "input": "3\n2\n3\n4",
                "output": "114514 114514\n1 2 2\n3 3 4 4"
            }
        ]
    },
    {
        "problem": "\nTurtle just received $n$ segments and a sequence $a_1, a_2, \\ldots, a_n$. The $i$-th segment is $[l_i, r_i]$.\n\nTurtle will create an undirected graph $G$. If segment $i$ and segment $j$ intersect, then Turtle will add an undirected edge between $i$ and $j$ with a weight of $|a_i - a_j|$, for every $i \\ne j$.\n\nTurtle wants you to calculate the sum of the weights of the edges of the minimum spanning tree of the graph $G$, or report that the graph $G$ has no spanning tree.\n\nWe say two segments $[l_1, r_1]$ and $[l_2, r_2]$ intersect if and only if $\\max(l_1, l_2) \\le \\min(r_1, r_2)$.\n\nInput Format:\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^5$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($2 \\le n \\le 5 \\cdot 10^5$) \u2014 the number of segments.\n\nThe $i$-th of the following $n$ lines contains three integers $l_i, r_i, a_i$ ($1 \\le l_i \\le r_i \\le 10^9, 1 \\le a_i \\le 10^9$) \u2014 the $i$-th segment and the $i$-th element of the sequence.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $5 \\cdot 10^5$.\n\nOutput Format:\nFor each test case, output a single integer \u2014 the sum of the weights of the edges of the minimum spanning tree of the graph $G$. If the graph $G$ has no spanning tree, output $-1$.\n\nTags:\n['data structures', 'dsu', 'graphs', 'greedy']\n\nTime Limit: 5000 ms\nMemory Limit: 512 MB\n",
        "tests": [
            {
                "input": "4\n5\n1 7 3\n2 4 6\n3 5 5\n6 7 9\n3 4 4\n5\n2 7 3\n1 3 6\n4 5 5\n6 7 9\n1 1 4\n4\n1 4 3\n1 2 1\n3 4 5\n1 4 4\n3\n1 3 1\n2 3 3\n4 5 8",
                "output": "9\n13\n4\n-1"
            }
        ]
    },
    {
        "problem": "\nNote the unusual definition of $\\text{MEX}$ in this problem.\n\nPiggy gave Turtle a binary tree$^{\\dagger}$ with $n$ vertices and a sequence $a_1, a_2, \\ldots, a_n$ on his birthday. The binary tree is rooted at vertex $1$.\n\nIf a set of paths $P = \\\\{(x_i, y_i)\\\\}$ in the tree covers each edge exactly once, then Turtle will think that the set of paths is good. Note that a good set of paths can cover a vertex twice or more.\n\nTurtle defines the value of a set of paths as $\\sum\\limits_{(x, y) \\in P} f(x, y)$, where $f(x, y)$ denotes the $\\text{MEX}^{\\ddagger}$ of all $a_u$ such that vertex $u$ is on the simple path from $x$ to $y$ in the tree (including the starting vertex $x$ and the ending vertex $y$).\n\nTurtle wonders the minimum value over all good sets of paths. Please help him calculate the answer!\n\n$^{\\dagger}$A binary tree is a tree where every non-leaf vertex has at most $2$ sons.\n\n$^{\\ddagger}\\text{MEX}$ of a collection of integers $c_1, c_2, \\ldots, c_k$ is defined as the smallest positive integer $x$ which does not occur in the collection $c$. For example, $\\text{MEX}$ of $[3, 3, 1, 4]$ is $2$, $\\text{MEX}$ of $[2, 3]$ is $1$.\n\nInput Format:\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($2 \\le n \\le 2.5 \\cdot 10^4$) \u2014 the number of vertices in the tree.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\le a_i \\le 10^9$) \u2014 the elements of the sequence $a$.\n\nThe third line of each test case contains $n - 1$ integers $p_2, p_3, \\ldots, p_n$ ($1 \\le p_i < i$) \u2014 the parent of each vertex in the tree.\n\nAdditional constraint on the input: the given tree is a binary tree, that is, every non-leaf vertex has at most $2$ sons.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $10^5$.\n\nOutput Format:\nFor each test case, output a single integer \u2014 the minimum value over all good sets of paths.\n\nTags:\n['data structures', 'dp', 'trees']\n\nTime Limit: 4000 ms\nMemory Limit: 1024 MB\n",
        "tests": [
            {
                "input": "5\n5\n3 2 2 1 1\n1 1 2 2\n5\n3 2 1 1 1\n1 1 2 2\n6\n1 2 1 2 1 3\n1 2 3 3 4\n7\n2 1 2 3 1 2 1\n1 1 2 2 3 3\n10\n1 2 2 1 4 2 3 1 2 1\n1 1 2 2 3 3 4 5 5",
                "output": "4\n6\n6\n6\n7"
            }
        ]
    },
    {
        "problem": "\nDima loves watching soccer. In such a game, the score on the scoreboard is represented as $x$ : $y$, where $x$ is the number of goals of the first team, and $y$ is the number of goals of the second team. At any given time, only one team can score a goal, so the score $x$ : $y$ can change to either $(x + 1)$ : $y$, or $x$ : $(y + 1)$.\n\nWhile watching a soccer game, Dima was distracted by very important matters, and after some time, he returned to watching the game. Dima remembers the score right before he was distracted, and the score right after he returned. Given these two scores, he wonders the following question. Is it possible that, while Dima was not watching the game, the teams never had an equal score?\n\nIt is guaranteed that at neither of the two time points Dima remembers the teams had equal scores. However, it is possible that the score did not change during his absence.\n\nHelp Dima and answer the question!\n\nInput Format:\nEach test consists of several test cases. The first line contains an integer $t$ ($1 \\le t \\le 10^{4}$) \u2014 the number of test cases. Then follows the description of the test cases.\n\nThe first line of each test case contains two integers $x_{1}, y_{1}$ ($0 \\le x_{1}, y_{1} \\le 10^{9}$, $x_{1} \\neq y_{1}$) \u2014 the score before Dima was distracted.\n\nThe second line of each test case contains two integers $x_{2}, y_{2}$ ($x_{1} \\le x_{2} \\le 10^{9}$, $y_{1} \\le y_{2} \\le 10^{9}$, $x_{2} \\neq y_{2}$) \u2014 the score when Dima returned.\n\nOutput Format:\nFor each test case, output \"YES\" without quotes if it is possible, that the teams never had a tie while Dima was away, otherwise output \"NO\" without quotes.\n\nYou can output each letter in any case (for example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as a positive answer).\n\nTags:\n['greedy', 'implementation', 'math', 'sortings']\n\nTime Limit: 1000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "6\n1 0\n5 0\n1 2\n3 2\n1 2\n4 5\n1 2\n4 3\n1 2\n1 2\n998244353 0\n1000000000 999999999",
                "output": "YES\nNO\nYES\nNO\nYES\nYES"
            }
        ]
    },
    {
        "problem": "\nRecently, the first-year student Maxim learned about the Collatz conjecture, but he didn't pay much attention during the lecture, so he believes that the following process is mentioned in the conjecture:\n\nThere is a variable $x$ and a constant $y$. The following operation is performed $k$ times:\n\n  * increase $x$ by $1$, then    * while the number $x$ is divisible by $y$, divide it by $y$. \n\nNote that both of these actions are performed sequentially within one operation.\n\nFor example, if the number $x = 16$, $y = 3$, and $k = 2$, then after one operation $x$ becomes $17$, and after another operation $x$ becomes $2$, because after adding one, $x = 18$ is divisible by $3$ twice.\n\nGiven the initial values of $x$, $y$, and $k$, Maxim wants to know what is the final value of $x$.\n\nInput Format:\nEach test consists of multiple test cases. The first line contains an integer $t$ ($1 \\le t \\le 10^{4}$) \u2014 the number of test cases. Then follows the description of the test cases.\n\nThe only line of each test case contains three integers $x$, $y$, and $k$ ($1 \\le x, k \\le 10^{9}$, $2 \\le y \\le 10^{9}$) \u2014 the initial variable, constant and the number of operations.\n\nOutput Format:\nFor each test case, output a single integer \u2014 the number obtained after applying $k$ operations.\n\nTags:\n['brute force', 'implementation', 'math', 'number theory']\n\nTime Limit: 1000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "13\n1 3 1\n2 3 1\n24 5 5\n16 3 2\n2 2 1\n1337 18 1\n1 2 144133\n12345678 3 10\n998244353 2 998244353\n998244353 123456789 998244352\n998244354 998241111 998244352\n998244355 2 9982443\n1000000000 1000000000 1000000000",
                "output": "2\n1\n1\n2\n3\n1338\n1\n16936\n1\n21180097\n6486\n1\n2"
            }
        ]
    },
    {
        "problem": "\nOn another boring day, Egor got bored and decided to do something. But since he has no friends, he came up with a game to play.\n\nEgor has a deck of $n$ cards, the $i$-th card from the top has a number $a_i$ written on it. Egor wants to play a certain number of rounds until the cards run out. In each round, he takes a non-zero number of cards from the top of the deck and finishes the round. If the sum of the numbers on the cards collected during the round is between $l$ and $r$, inclusive, the round is won; otherwise, it is lost.\n\nEgor knows by heart the order of the cards. Help Egor determine the maximum number of rounds he can win in such a game. Note that Egor is not required to win rounds consecutively.\n\nInput Format:\nEach test consists of several test cases. The first line contains an integer $t$ ($1 \\le t \\le 10^{4}$) \u2014 the number of test cases. This is followed by a description of the test cases.\n\nThe first line of each test case contains three integers $n$, $l$, and $r$ ($1 \\le n \\le 10^{5}$, $1 \\le l \\le r \\le 10^9$).\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\le a_i \\le 10^9$) \u2014 the numbers on the cards from top to bottom.\n\nIt is guaranteed that the sum of $n$ for all test cases does not exceed $2 \\cdot 10^{5}$.\n\nOutput Format:\nFor each test case, output a single number \u2014 the maximum number of rounds Egor can win.\n\nTags:\n['binary search', 'data structures', 'dp', 'greedy', 'two pointers']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "8\n5 3 10\n2 1 11 3 7\n10 1 5\n17 8 12 11 7 11 21 13 10 8\n3 4 5\n3 4 2\n8 12 25\n10 7 5 13 8 9 12 7\n2 3 3\n5 2\n9 7 9\n2 10 5 1 3 7 6 2 3\n1 8 10\n9\n5 5 6\n1 4 2 6 4",
                "output": "3\n0\n1\n4\n0\n3\n1\n2"
            }
        ]
    },
    {
        "problem": "\nNikita loves mountains and has finally decided to visit the Berlyand mountain range! The range was so beautiful that Nikita decided to capture it on a map. The map is a table of $n$ rows and $m$ columns, with each cell containing a non-negative integer representing the height of the mountain.\n\nHe also noticed that mountains come in two types:\n\n  * With snowy caps.    * Without snowy caps. \n\nNikita is a very pragmatic person. He wants the sum of the heights of the mountains with snowy caps to be equal to the sum of the heights of the mountains without them. He has arranged with the mayor of Berlyand, Polikarp Polikarpovich, to allow him to transform the landscape.\n\nNikita can perform transformations on submatrices of size $k \\times k$ as follows: he can add an integer constant $c$ to the heights of the mountains within this area, but the type of the mountain remains unchanged. Nikita can choose the constant $c$ independently for each transformation. Note that $c$ can be negative.\n\nBefore making the transformations, Nikita asks you to find out if it is possible to achieve equality of the sums, or if it is impossible. It doesn't matter at what cost, even if the mountains turn into canyons and have negative heights.\n\nIf only one type of mountain is represented on the map, then the sum of the heights of the other type of mountain is considered to be zero.\n\nInput Format:\nEach test consists of several test cases. The first line contains an integer $t$ ($1 \\le t \\le 10^{4}$) \u2014 the number of test cases. This is followed by a description of test cases.\n\nThe first line of each test case contains three integers $n, m, k$ ($1 \\le n, m \\le 500, 1 \\le k \\le min(n, m)$).\n\nThe next $n$ lines of each test case contain $m$ integers $a_{i j}$ ($0 \\le a_{i j} \\le 10^{9}$) \u2014 the initial heights of the mountains.\n\nThe next $n$ binary strings of length $m$ for each test case determine the type of mountain, '$0$' \u2014 with snowy caps, '$1$' \u2014 without them.\n\nIt is guaranteed that the sum of $n \\cdot m$ for all test cases does not exceed $250\\,000$.\n\nOutput Format:\nFor each test case, output \"YES\" without quotes if it is possible to equalize the sums of the mountain heights, otherwise output \"NO\" without quotes. You can output each letter in any case (for example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as a positive answer).\n\nTags:\n['brute force', 'data structures', 'implementation', 'math', 'number theory']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "8\n3 3 2\n7 11 3\n4 2 3\n0 1 15\n100\n010\n000\n4 4 3\n123 413 24 233\n123 42 0 216\n22 1 1 53\n427 763 22 6\n0101\n1111\n1010\n0101\n3 3 2\n2 1 1\n1 1 2\n1 5 4\n010\n101\n010\n3 3 2\n2 1 1\n1 1 2\n1 5 3\n010\n101\n010\n3 4 3\n46 49 50 1\n19 30 23 12\n30 25 1 46\n1000\n0100\n0010\n5 4 4\n39 30 0 17\n22 42 30 13\n10 44 46 35\n12 19 9 39\n21 0 45 40\n1000\n1111\n0011\n0111\n1100\n2 2 2\n3 4\n6 7\n00\n00\n2 2 2\n0 0\n2 0\n01\n00",
                "output": "YES\nNO\nYES\nNO\nYES\nNO\nYES\nYES"
            }
        ]
    },
    {
        "problem": "\nLet $bit(x)$ denote the number of ones in the binary representation of a non-negative integer $x$.\n\nA subarray of an array is called $k$-good if it consists only of numbers with no more than $k$ ones in their binary representation, i.e., a subarray $(l, r)$ of array $a$ is good if for any $i$ such that $l \\le i \\le r$ condition $bit(a_{i}) \\le k$ is satisfied.\n\nYou are given an array $a$ of length $n$, consisting of consecutive non-negative integers starting from $0$, i.e., $a_{i} = i$ for $0 \\le i \\le n - 1$ (in $0$-based indexing). You need to count the number of $k$-good subarrays in this array.\n\nAs the answer can be very large, output it modulo $10^{9} + 7$.\n\nInput Format:\nEach test consists of multiple test cases. The first line contains an integer $t$ ($1 \\le t \\le 10^{4}$) \u2014 the number of test cases. The following lines describe the test cases.\n\nThe single line of each test case contains two integers $n$, $k$ ($1 \\le n \\le 10^{18}, 1 \\le k \\le 60$).\n\nOutput Format:\nFor each test case, output a single integer \u2014 the number of $k$-good subarrays modulo $10^{9} + 7$.\n\nTags:\n['bitmasks', 'brute force', 'combinatorics', 'divide and conquer', 'dp', 'math', 'meet-in-the-middle']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "10\n6 1\n16 2\n1 1\n3 1\n31 3\n14 1\n1337 5\n100000 20\n795569939321040850 56\n576460752303423268 59",
                "output": "7\n35\n1\n6\n155\n8\n7323\n49965\n741136395\n66679884"
            }
        ]
    },
    {
        "problem": "\nYou have an array $a$ of $n$ elements. There are also $q$ modifications of the array. Before the first modification and after each modification, you would like to know the following:\n\nWhat is the minimum length subarray that needs to be sorted in non-decreasing order in order for the array $a$ to be completely sorted in non-decreasing order?\n\nMore formally, you want to select a subarray of the array $(l, r)$ with the minimum value of $r - l + 1$. After that, you will sort the elements $a_{l}, a_{l + 1}, \\ldots, a_{r}$ and want the condition $a_{i} \\le a_{i + 1}$ to hold for all $1 \\le i < n$. If the array is already sorted in non-decreasing order, then $l$ and $r$ should be considered as equal to $-1$.\n\nNote that finding such $(l, r)$ does not change the array in any way. The modifications themselves take the form: assign $a_{pos} = x$ for given $pos$ and $x$.\n\nInput Format:\nEach test consists of several test cases. The first line contains an integer $t$ ($1 \\le t \\le 10$) \u2014 the number of test cases. Then follows the description of test cases.\n\nThe first line of each test case contains a single integer $n$ ($1 \\le n \\le 5 \\cdot 10^{5}$).\n\nThe second line of each test case contains $n$ integers $a_{i}$ ($0 \\le |a_{i}| \\le 10^{9}$) \u2014 the initial elements of the array $a$.\n\nThe third line of each test case contains a number $q$ ($0 \\le q \\le 5 \\cdot 10^{5}$) \u2014 the number of modifications to the array.\n\nThe following $q$ lines of each test case contain two integers $pos_{i}$ ($1 \\le pos_{i} \\le n$) and $val_{i}$ ($0 \\le |val_{i}| \\le 10^{9}$) \u2014 this means that for the $i$-th modification, $a_{pos_{i}}$ is assigned the value $val_{i}$.\n\nIt is guaranteed that the sum of $n$ and the sum of $q$ for all test cases does not exceed $5 \\cdot 10^{5}$.\n\nOutput Format:\nFor each test case, output $q + 1$ lines. Each line should contain $2$ integers $l, r$ \u2014 the boundaries of the minimum subarray, such that sorting it will make the array $a$ completely sorted. If $a$ is already sorted, then output $l = -1$, $r = -1$.\n\nTags:\n['binary search', 'data structures', 'sortings']\n\nTime Limit: 2500 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "2\n5\n2 2 3 4 5\n3\n2 1\n4 1\n1 1\n5\n1 2 3 4 5\n9\n1 4\n2 3\n5 2\n3 1\n1 1\n5 1\n4 1\n3 1\n2 1",
                "output": "-1 -1\n1 2\n1 4\n3 4\n-1 -1\n1 3\n1 3\n1 5\n1 5\n2 5\n2 5\n2 5\n2 5\n-1 -1"
            }
        ]
    },
    {
        "problem": "\nAn array of integers $a_1,a_2,\\cdots,a_n$ is beautiful subject to an integer $k$ if it satisfies the following:\n\n  * The sum of $a_{j}$ over all $j$ such that $j$ is a multiple of $k$ and $1 \\le j \\le n $, itself, is a multiple of $k$.    * More formally, if $\\sum_{k | j} a_{j}$ is divisible by $k$ for all $1 \\le j \\le n$ then the array $a$ is beautiful subject to $k$. Here, the notation ${k|j}$ means $k$ divides $j$, that is, $j$ is a multiple of $k$. \n\nGiven $n$, find an array of positive nonzero integers, with each element less than or equal to $10^5$ that is beautiful subject to all $1 \\le k \\le n$.\n\nIt can be shown that an answer always exists.\n\nInput Format:\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 100$). The description of the test cases follows.\n\nThe first and only line of each test case contains a single integer $n$ ($1 \\le n \\le 100$) \u2014 the size of the array.\n\nOutput Format:\nFor each test case, print the required array as described in the problem statement.\n\nTags:\n['constructive algorithms', 'math']\n\nTime Limit: 1000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "3\n3\n6\n7",
                "output": "4 22 18\n10 6 15 32 125 54\n23 18 27 36 5 66 7"
            }
        ]
    },
    {
        "problem": "\nYou are given two grids of numbers $a$ and $b$, with $n$ rows and $m$ columns. All the values in the grid are $0$, $1$ or $2$.\n\nYou can perform the following operation on $a$ any number of times:\n\n  * Pick any subrectangle in the grid with length and width $\\ge 2$. You are allowed to choose the entire grid as a subrectangle.    * The subrectangle has four corners. Take any pair of diagonally opposite corners of the chosen subrectangle and add $1$ to their values modulo $3$.    * For the pair of corners not picked, add $2$ to their values modulo $3$. \n\nNote that the operation only changes the values of the corners of the picked subrectangle.\n\nIs it possible to convert the grid $a$ into grid $b$ by applying the above operation any number of times (possibly zero)?\n\nInput Format:\nThe first line contains an integer $t$, the number of testcases ($1 \\le t \\le 250$).\n\nFor each testcase:\n\nThe first line contains two integers $n$ and $m$, the number of rows and columns in the grid ($2 \\le n,m \\le 500$).\n\nEach of the next n lines contain m characters \u2014 the $j$-th character of the $i$-th line represents $a_{i,j}$.\n\nEach of the next n lines contain m characters \u2014 the $j$-th character of the $i$-th line represents $b_{i,j}$ ($0 \\le a_{i,j}, b_{i,j} \\le 2$).\n\nIt is guaranteed that the sum of $n$ over all test cases and the sum of $m$ over all test cases do not exceed $500$.\n\nOutput Format:\nFor each test case print \"YES\" (without quotes) if it is possible to convert grid $a$ into grid $b$ and \"NO\" (without quotes) otherwise.\n\nYou can output the answer in any case (upper or lower). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as positive responses.\n\nTags:\n['constructive algorithms', 'greedy', 'implementation', 'math']\n\nTime Limit: 1000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "7\n3 3\n000\n000\n000\n111\n111\n111\n4 4\n0000\n0000\n0000\n0000\n2100\n1200\n0012\n0021\n4 4\n1020\n1200\n1210\n0000\n0000\n1200\n2200\n0000\n3 3\n012\n012\n012\n010\n111\n011\n8 8\n00000000\n00000000\n00000000\n00000000\n00000000\n00000000\n00000000\n10000000\n00000000\n01200000\n02010000\n00102000\n00020100\n00001020\n00000210\n10000000\n2 7\n0000000\n0000000\n2220111\n0111222\n2 7\n0000000\n0100010\n2220111\n1210202",
                "output": "YES\nYES\nYES\nNO\nYES\nNO\nYES"
            }
        ]
    },
    {
        "problem": "\nAlice, Bob and Charlie want to share a rectangular cake cut into $n$ pieces. Each person considers every piece to be worth a different value. The $i$-th piece is considered to be of value $a_i$ by Alice, $b_i$ by Bob and $c_i$ by Charlie.\n\nThe sum over all $a_i$, all $b_i$ and all $c_i$ individually is the same, equal to $tot$.\n\nGiven the values of each piece of the cake for each person, you need to give each person a contiguous slice of cake. In other words, the indices at the left and right ends of these subarrays (the slices given to each person) can be represented as $(l_a, r_a)$, $(l_b, r_b)$ and $(l_c, r_c)$ respectively for Alice, Bob and Charlie. The division needs to satisfy the following constraints:\n\n  * No piece is assigned to more than one person, i.e., no two subarrays among $[l_a,\\ldots,r_a]$, $[l_b, \\ldots, r_b]$ and $[l_c, \\ldots, r_c]$ intersect.   * $ \\sum_{i = l_a}^{r_a} a_i, \\sum_{i = l_b}^{r_b} b_i, \\sum_{i = l_c}^{r_c} c_i \\geq \\lceil \\frac{tot}{3} \\rceil$. \n\nHere, the notation $\\lceil \\frac{a}{b} \\rceil$ represents ceiling division. It is defined as the smallest integer greater than or equal to the exact division of $a$ by $b$. In other words, it rounds up the division result to the nearest integer. For instance $\\lceil \\frac{10}{3} \\rceil = 4$ and $\\lceil \\frac{15}{3} \\rceil = 5$.\n\nInput Format:\nThe first line contains an integer $t$, the number of testcases, ($1 \\le t \\le 10^4$)\n\nFor each testcase:\n\nThe first line contains the integer $n$ ($3 \\le n \\le 2 \\cdot 10^5$).\n\nThe following three lines contain $n$ integers each:\n\nOne line with $n$ integers $a_1, a_2, \\ldots, a_n$ represents the values for Alice ($1 \\le a_i \\le 10^6$).\n\nThe next line with $n$ integers $b_1, b_2, \\ldots, b_n$ represents the values for Bob ($1 \\le b_i \\le 10^6$).\n\nThe next line with $n$ integers $c_1, c_2, \\ldots, c_n$ represents the values for Charlie ($1 \\le c_i \\le 10^6$).\n\nIt is guaranteed that $ \\sum_{i = 1}^{n} a_i = \\sum_{i = 1}^{n} b_i = \\sum_{i = 1}^{n} c_i$.\n\nThe sum of $n$ over all testcases does not exceed $2 \\cdot 10^5$.\n\nOutput Format:\nFor each testcase, output $-1$ if the required condition is impossible.\n\nOtherwise, output six numbers \u2013 $l_a, r_a, l_b, r_b, l_c, r_c$, the respective starting and ending indices ($1$-indexed) of the subarrays for Alice, Bob and Charlie, respectively.\n\nTags:\n['binary search', 'brute force', 'greedy', 'implementation']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "10\n5\n5 1 1 1 1\n1 1 5 1 1\n1 1 1 1 5\n6\n1 2 3 4 5 6\n5 6 1 2 3 4\n3 4 5 6 1 2\n4\n4 4 4 4\n4 4 4 4\n4 4 4 4\n5\n5 10 5 2 10\n9 6 9 7 1\n10 7 10 2 3\n3\n4 5 2\n6 1 4\n1 8 2\n3\n10 4 10\n8 7 9\n10 4 10\n7\n57113 65383 19795 53580 74452 3879 23255\n12917 16782 89147 93107 27365 15044 43095\n33518 63581 33565 34112 46774 44151 41756\n6\n6 3 1 8 7 1\n10 2 6 2 2 4\n10 9 2 1 2 2\n5\n5 5 4 5 5\n1 6 3 8 6\n2 4 1 9 8\n10\n1 1 1 1 1001 1 1 1001 1 1\n1 1 1 1 1 1 2001 1 1 1\n1 1 1 1 1 1001 1 1 1 1001",
                "output": "1 1 2 3 4 5 \n5 6 1 2 3 4 \n-1\n-1\n1 1 3 3 2 2 \n-1\n1 2 3 4 5 7 \n3 6 1 1 2 2 \n1 2 3 4 5 5 \n1 5 6 7 8 10"
            }
        ]
    },
    {
        "problem": "\nGiven two arrays of distinct positive integers $a$ and $b$ of length $n$, we would like to make both the arrays the same. Two arrays $x$ and $y$ of length $k$ are said to be the same when for all $1 \\le i \\le k$, $x_i = y_i$.\n\nNow in one move, you can choose some index $l$ and $r$ in $a$ ($l \\le r$) and swap $a_l$ and $a_r$, then choose some $p$ and $q$ ($p \\le q$) in $b$ such that $r-l=q-p$ and swap $b_p$ and $b_q$.\n\nIs it possible to make both arrays the same?\n\nInput Format:\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 2 \\cdot 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($1 \\le n \\le 10^5$) \u2014 the length of the arrays $a$ and $b$.\n\nThe second line of each test case contains $n$ distinct integers $a_1,a_2,a_3,\\ldots,a_n$ ($1 \\le a_i \\le 2 \\cdot 10^5$) \u2014 the integers in the array $a$.\n\nThe third line of each test case contains $n$ distinct integers $b_1,b_2,b_3,\\ldots,b_n$ ($1 \\le b_i \\le 2 \\cdot 10^5$) \u2014 the integers in the array $b$.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $10^5$.\n\nOutput Format:\nFor each testcase, print \"YES\" if the arrays $a$ and $b$ can be made the same. Otherwise, print \"NO\". can output the answer in any case (upper or lower). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as positive responses.\n\nTags:\n['constructive algorithms', 'data structures', 'divide and conquer', 'greedy', 'math', 'sortings']\n\nTime Limit: 1000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "6\n4\n1 2 3 4\n1 2 3 4\n5\n1 3 4 2 5\n7 1 2 5 4\n4\n1 2 3 4\n4 3 2 1\n3\n1 2 3\n1 3 2\n5\n1 5 7 1000 4\n4 1 7 5 1000\n3\n1 4 2\n1 3 2",
                "output": "YES\nNO\nYES\nNO\nNO\nNO"
            }
        ]
    },
    {
        "problem": "\nAlice and Bob are playing a game. There are $n$ balls, out of which $k$ are special. Each ball has a value associated with it.\n\nThe players play turn by turn. In each turn, the player randomly picks a ball and adds the value of the ball to their score, which is $0$ at the beginning of the game. The selected ball is removed from the game. If the ball was special, the same player takes the next turn if at least one ball is remaining. If the ball picked was not special, the next player plays their turn.\n\nThey play this game until no balls are remaining in the game. Alice plays first.\n\nFind the expected score that both the players have at the end of the game modulo $10^9+7$.\n\nFormally, let $M = 10^9+7$. It can be shown that the answer can be expressed as an irreducible fraction $\\frac{p}{q}$, where $p$ and $q$ are integers and $q \\not \\equiv 0 \\pmod{M}$. Output the integer equal to $p \\cdot q^{-1} \\bmod M$. In other words, output such an integer $x$ that $0 \\le x < M$ and $x \\cdot q \\equiv p \\pmod{M}$.\n\nInput Format:\nThere are multiple test cases. The first line of the input contains an integer $t$, the number of test cases ($1 \\le t \\le 2 \\cdot 10^5$).\n\nEach test case description is on a new line. The first line of the test case contains two integers $n$ and $k$ in the respective order separated by a space ($1 \\le k \\le n \\le 4 \\cdot 10^5$).\n\nThe second line of the test case contains $n$ integers: $v_1, v_2, \\ldots, v_n$, the value for each ball separated by spaces. The first $k$ balls are special ($1 \\le v_i \\le 10^7$).\n\nThe sum of $n$ over all test cases does not exceed $5 \\cdot 10^5$.\n\nOutput Format:\nOutput two integers per test case in a new line, the expected score of Alice and the expected score of Bob modulo $10^9+7$.\n\nTags:\n['combinatorics', 'math', 'probabilities']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "1\n5 2\n10 20 5 15 25",
                "output": "45 30"
            },
            {
                "input": "5\n1 1\n732507\n2 2\n5817860 5398510\n5 1\n2122894 4951549 2750585 7821535 3214167\n8 4\n1405323 5069867 6883092 6972029 328406 2478975 7628890 9973340\n4 2\n9662050 3566134 3996473 9872255",
                "output": "732507 0\n11216370 0\n810642660 210218077\n722402997 318336932\n349086489 678010430"
            },
            {
                "input": "5\n3 3\n1095611 8219204 7773462\n2 1\n8176490 2774103\n3 1\n9178636 5138057 3367761\n12 9\n7597698 6843019 2298534 1522386 4969588 1340345 3967362 9152890 6689668 9986080 4745473 7407325\n10 5\n6986368 2397882 5804127 6980694 3740836 3215836 5195724 3179261 4136769 4544231",
                "output": "17088277 0\n6862348 4088245\n677038671 340645790\n36949997 29570371\n725118051 321063684"
            }
        ]
    },
    {
        "problem": "\nYou have an array of non-negative integers $a_1, a_2, \\ldots, a_n$.\n\nThe value of a sub-array of length $\\ge 2$, $a[l, r] = [a_l, a_{l+1}, \\ldots, a_r]$ is the minimum value of $a_i \\oplus a_j$ such that $l \\le i < j \\le r$, where $\\oplus$ is the xor (exclusive-or) operator.\n\nYou have to find the $k$-th smallest value over all sub-arrays of length $\\ge 2$.\n\nInput Format:\nThe first line of the input contains multiple test cases $t$ ($1 \\le t \\le 2 \\cdot 10^4$).\n\nThe first line of each test case contains integer numbers $n$ and $k$ ($2 \\le n \\le 10^5$, $1 \\le k \\le \\frac{n\\cdot(n-1)}{2}$).\n\nThe second line of the input contains $n$ non-negative integer numbers $a_1, a_2, \\ldots, a_n$ ($0 \\le a_i \\le 10^9$) \u2014 the array itself.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $10^5$.\n\nOutput Format:\nPrint the $k$-th smallest value obtained over all subarrays of length at least $2$.\n\nTags:\n['binary search', 'bitmasks', 'data structures', 'greedy', 'two pointers']\n\nTime Limit: 4000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "4\n5 2\n1 2 3 4 5\n2 1\n4 3\n4 6\n1 2 4 8\n5 9\n1 2 3 4 5",
                "output": "1\n7\n12\n3"
            }
        ]
    },
    {
        "problem": "\nYou are given a tree with $n$ nodes numbered from $1$ to $n$, along with an array of size $n$. The value of $i$-th node is $a_{i}$. There are $q$ queries. In each query, you are given 2 nodes numbered as $x$ and $y$.\n\nConsider the path from the node numbered as $x$ to the node numbered as $y$. Let the path be represented by $x = p_0, p_1, p_2, \\ldots, p_r = y$, where $p_i$ are the intermediate nodes. Compute the sum of $a_{p_i}\\oplus i$ for each $i$ such that $0 \\le i \\le r$ where $\\oplus$ is the [XOR](https://en.wikipedia.org/wiki/Exclusive_or) operator.\n\nMore formally, compute $$\\sum_{i =0}^{r} a_{p_i}\\oplus i$$.\n\nInput Format:\nThe first line contains a single integer $t$ ($1 \\le t \\le 10^4$) \u2014 the number of test cases. Each test case contains several sets of input data.\n\nThe first line of each set of input data contains a single integer $n$ ($1 \\le n \\le 5 \\cdot 10^5$) \u2014 the number of nodes.\n\nThe next $n-1$ lines of each set of input data contain $2$ integers, $u$ and $v$ representing an edge between the node numbered $u$ and the node numbered $v$. It is guaranteed that $u \\ne v$ and that the edges form a tree.\n\nThe next line of each set of input data contains $n$ integers, $a_1, a_2, \\ldots, a_n$ ($1 \\le a_i \\le 5 \\cdot 10^5$) \u2014 values of the nodes.\n\nThe next line contains a single integer $q$ ($1 \\le q \\le 10^5$) \u2014 the number of queries.\n\nThe next $q$ lines describe the queries. The $i$-th query contains $2$ integers $x$ and $y$ ($1 \\le x,y \\le n$) denoting the starting and the ending node of the path.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $5 \\cdot 10^5$ and sum of $q$ over all test cases does not exceed $10^5$.\n\nOutput Format:\nFor each query, output a single number \u2014 the sum from the problem statement.\n\nTags:\n['bitmasks', 'brute force', 'dp', 'trees']\n\nTime Limit: 3000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "1\n4\n1 2\n2 3\n3 4\n2 3 6 5\n3\n1 4\n3 4\n1 1",
                "output": "14\n10\n2"
            }
        ]
    },
    {
        "problem": "\nDefine the range of a non-empty array to be the maximum value minus the minimum value. For example, the range of $[1,4,2]$ is $4-1=3$.\n\nYou are given an array $a_1, a_2, \\ldots, a_n$ of length $n \\geq 3$. It is guaranteed $a$ is sorted.\n\nYou have to color each element of $a$ red or blue so that:\n\n  * the range of the red elements does not equal the range of the blue elements, and    * there is at least one element of each color. \n\nIf there does not exist any such coloring, you should report it. If there are multiple valid colorings, you can print any of them.\n\nInput Format:\nThe first line contains a single integer $t$ ($1 \\leq t \\leq 100$) \u2014 the number of test cases.\n\nThe first line of each test case contains an integer $n$ ($3 \\leq n \\leq 50$) \u2014 the length of the array.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\leq a_i \\leq 10^9$). It is guaranteed $a_1 \\leq a_2 \\leq \\ldots \\leq a_{n - 1} \\leq a_{n}$.\n\nOutput Format:\nFor each test case, if it is impossible to color $a$ to satisfy all the constraints, output $\\texttt{NO}$.\n\nOtherwise, first output $\\texttt{YES}$.\n\nThen, output a string $s$ of length $n$. For $1 \\leq i \\leq n$, if you color $a_i$ red, $s_i$ should be $\\texttt{R}$. For $1 \\leq i \\leq n$, if you color $a_i$ blue, $s_i$ should be $\\texttt{B}$.\n\nTags:\n['constructive algorithms']\n\nTime Limit: 1000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "7\n4\n1 1 2 2\n5\n1 2 3 4 5\n3\n3 3 3\n4\n1 2 2 2\n3\n1 2 2\n3\n1 1 2\n3\n1 9 84",
                "output": "YES\nRBRR\nYES\nBBRBB\nNO\nYES\nRBBR\nYES\nRRB\nYES\nBRR\nYES\nBRB"
            }
        ]
    },
    {
        "problem": "\nA digit is large if it is between $5$ and $9$, inclusive. A positive integer is large if all of its digits are large.\n\nYou are given an integer $x$. Can it be the sum of two large positive integers with the same number of digits?\n\nInput Format:\nThe first line contains a single integer $t$ ($1 \\leq t \\leq 10^4$) \u2014 the number of test cases.\n\nThe only line of each test case contains a single integer $x$ ($10 \\leq x \\leq 10^{18}$).\n\nOutput Format:\nFor each test case, output $\\texttt{YES}$ if $x$ satisfies the condition, and $\\texttt{NO}$ otherwise.\n\nYou can output $\\texttt{YES}$ and $\\texttt{NO}$ in any case (for example, strings $\\texttt{yES}$, $\\texttt{yes}$, and $\\texttt{Yes}$ will be recognized as a positive response).\n\nTags:\n['implementation', 'math']\n\nTime Limit: 1000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "11\n1337\n200\n1393938\n1434\n98765432123456789\n11111111111111111\n420\n1984\n10\n69\n119",
                "output": "YES\nNO\nYES\nYES\nNO\nYES\nNO\nYES\nYES\nNO\nNO"
            }
        ]
    },
    {
        "problem": "\nThe two versions of the problem are different. You may want to read both versions. You can make hacks only if both versions are solved.\n\nYou are given an array $a$ of length $n$. Start with $c = 0$. Then, for each $i$ from $1$ to $n$ (in increasing order) do exactly one of the following:\n\n  * Option $1$: set $c$ to $c + a_i$.    * Option $2$: set $c$ to $|c + a_i|$, where $|x|$ is the absolute value of $x$. \n\nLet the maximum final value of $c$ after the procedure described above be equal to $k$. Find $k$.\n\nInput Format:\nThe first line contains a single integer $t$ ($1 \\leq t \\leq 10^4$) \u2014 the number of test cases.\n\nThe first line of each test case contains a single integer $n$ ($2 \\leq n \\leq 2 \\cdot 10^5$).\n\nThe second line of each case contains $n$ integers $a_1$, $a_2$, $a_3$, $\\ldots$, $a_n$ ($-10^9 \\leq a_i \\leq 10^9$).\n\nThe sum of $n$ over all test cases does not exceed $3 \\cdot 10^5$.\n\nOutput Format:\nFor each test case, output a single integer \u2014 the value of $k$.\n\nTags:\n['dp', 'greedy', 'math']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "5\n4\n10 -9 -3 4\n8\n1 4 3 4 1 4 3 4\n3\n-1 -2 -3\n4\n-1000000000 1000000000 1000000000 1000000000\n4\n1 9 8 4",
                "output": "6\n24\n6\n4000000000\n22"
            }
        ]
    },
    {
        "problem": "\nThe two versions of the problem are different. You may want to read both versions. You can make hacks only if both versions are solved.\n\nYou are given an array $a$ of length $n$. Start with $c = 0$. Then, for each $i$ from $1$ to $n$ (in increasing order) do exactly one of the following:\n\n  * Option $1$: set $c$ to $c + a_i$.    * Option $2$: set $c$ to $|c + a_i|$, where $|x|$ is the absolute value of $x$. \n\nLet the maximum final value of $c$ after the procedure described above be equal to $k$. Find the number of unique procedures that result in $c = k$. Two procedures are different if at any index $i$, one procedure chose option $1$ and another chose option $2$, even if the value of $c$ is equal for both procedures after that turn.\n\nSince the answer may be large, output it modulo $998\\,244\\,353$.\n\nInput Format:\nThe first line contains a single integer $t$ ($1 \\leq t \\leq 10^4$) \u2014 the number of test cases.\n\nThe first line of each test case contains a single integer $n$ ($2 \\leq n \\leq 2 \\cdot 10^5$).\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($-10^9 \\leq a_i \\leq 10^9$).\n\nThe sum of $n$ over all test cases does not exceed $3 \\cdot 10^5$.\n\nOutput Format:\nFor each test case, output a single integer \u2014 the number of unique procedures that result in $c = k$, modulo $998\\,244\\,353$.\n\nTags:\n['combinatorics', 'dp', 'greedy', 'math']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "5\n4\n2 -5 3 -3\n8\n1 4 3 4 1 4 3 4\n3\n-1 -2 -3\n4\n-1000000000 1000000000 1000000000 1000000000\n4\n1 9 8 4",
                "output": "12\n256\n1\n8\n16"
            }
        ]
    },
    {
        "problem": "\nYou are given a string $s$ consisting of lowercase Latin characters. Count the number of nonempty strings $t \\neq$ \"$\\texttt{a}$\" such that it is possible to partition$^{\\dagger}$ $s$ into some substrings satisfying the following conditions:\n\n  * each substring either equals $t$ or \"$\\texttt{a}$\", and    * at least one substring equals $t$. \n\n$^{\\dagger}$ A partition of a string $s$ is an ordered sequence of some $k$ strings $t_1, t_2, \\ldots, t_k$ (called substrings) such that $t_1 + t_2 + \\ldots + t_k = s$, where $+$ represents the concatenation operation.\n\nInput Format:\nThe first line contains a single integer $t$ ($1 \\leq t \\leq 10^4$) \u2014 the number of test cases.\n\nThe only line of each test case contains a string $s$ consisting of lowercase Latin characters ($2 \\leq |s| \\leq 2 \\cdot 10^5$).\n\nThe sum of $|s|$ over all test cases does not exceed $3 \\cdot 10^5$.\n\nOutput Format:\nFor each test case, output a single integer \u2014 the number of nonempty strings $t \\neq$ \"$\\texttt{a}$\" that satisfy all constraints.\n\nTags:\n['brute force', 'hashing', 'implementation', 'math', 'string suffix structures', 'strings']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "8\naaaaa\nbaba\ncabacb\naaabaaa\nbitset\nab\nabbaaaabbb\nyearnineteeneightyfour",
                "output": "4\n4\n1\n16\n1\n2\n3\n1"
            }
        ]
    },
    {
        "problem": "\nTwo hungry red pandas, Oscar and Lura, have a tree $T$ with $n$ nodes. They are willing to perform the following shuffle procedure on the whole tree $T$ exactly once. With this shuffle procedure, they will create a new tree out of the nodes of the old tree.\n\n  1. Choose any node $V$ from the original tree $T$. Create a new tree $T_2$, with $V$ as the root.    2. Remove $V$ from $T$, such that the original tree is split into one or more subtrees (or zero subtrees, if $V$ is the only node in $T$).    3. Shuffle each subtree with the same procedure (again choosing any node as the root), then connect all shuffled subtrees' roots back to $V$ to finish constructing $T_2$. \n\nAfter this, Oscar and Lura are left with a new tree $T_2$. They can only eat leaves and are very hungry, so please find the maximum number of leaves over all trees that can be created in exactly one shuffle.\n\nNote that leaves are all nodes with degree $1$. Thus, the root may be considered as a leaf if it has only one child.\n\nInput Format:\nThe first line contains a single integer $t$ ($1 \\leq t \\leq 10^4$) \u2014 the number of test cases.\n\nThe first line of every test case contains a single integer $n$ ($2 \\leq n \\leq 2 \\cdot 10^5$) \u2014 the number of nodes within the original tree $T$.\n\nThe next $n - 1$ lines each contain two integers $u$ and $v$ ($1 \\leq u, v \\leq n$) \u2014 an edge within the original tree $T$. The given edges form a tree.\n\nThe sum of $n$ over all test cases does not exceed $3 \\cdot 10^5$.\n\nOutput Format:\nFor each test case, output a single integer \u2014 the maximum number of leaves achievable with exactly one shuffle procedure on the whole tree.\n\nTags:\n['dp', 'greedy', 'trees']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "4\n5\n1 2\n1 3\n2 4\n2 5\n5\n1 2\n2 3\n3 4\n4 5\n6\n1 2\n1 3\n1 4\n1 5\n1 6\n10\n9 3\n8 1\n10 6\n8 5\n7 8\n4 6\n1 3\n10 1\n2 7",
                "output": "4\n3\n5\n6"
            }
        ]
    },
    {
        "problem": "\nThere is a hidden array $a_1, a_2, \\ldots, a_n$ of length $n$ whose elements are integers between $-m$ and $m$, inclusive.\n\nYou are given an array $b_1, b_2, \\ldots, b_n$ of length $n$ and a string $s$ of length $n$ consisting of the characters $\\texttt{P}$, $\\texttt{S}$, and $\\texttt{?}$.\n\nFor each $i$ from $1$ to $n$ inclusive, we must have:\n\n  * If $s_i = \\texttt{P}$, $b_i$ is the sum of $a_1$ through $a_i$.    * If $s_i = \\texttt{S}$, $b_i$ is the sum of $a_i$ through $a_n$. \n\nOutput the number of ways to replace all $\\texttt{?}$ in $s$ with either $\\texttt{P}$ or $\\texttt{S}$ such that there exists an array $a_1, a_2, \\ldots, a_n$ with elements not exceeding $m$ by absolute value satisfying the constraints given by the array $b_1, b_2, \\ldots, b_n$ and the string $s$.\n\nSince the answer may be large, output it modulo $998\\,244\\,353$.\n\nInput Format:\nThe first line contains a single integer $t$ ($1 \\leq t \\leq 10^3$) \u2014 the number of test cases.\n\nThe first line of each test case contains two integers $n$ and $m$ ($2 \\leq n \\leq 2 \\cdot 10^3$, $2 \\leq m \\leq 10^{9}$) \u2014 the length of the hidden array $a_1, a_2, \\ldots, a_n$ and the maximum absolute value of an element $a_i$.\n\nThe second line of each test case contains a string $s$ of length $n$ consisting of characters $\\texttt{P}$, $\\texttt{S}$, and $\\texttt{?}$.\n\nThe third line of each test case contains $n$ integers $b_1, b_2, \\ldots, b_n$ ($|b_i| \\leq m \\cdot n$).\n\nThe sum of $n$ over all test cases does not exceed $5 \\cdot 10^3$.\n\nOutput Format:\nFor each test case, output a single integer \u2014 the number of ways to replace all $\\texttt{?}$ in $s$ with either $\\texttt{P}$ or $\\texttt{S}$ that result in the existence of a valid array $a_1, a_2, \\ldots, a_n$, modulo $998\\,244\\,353$.\n\nTags:\n['brute force', 'dp', 'math']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "6\n4 10\nPSPP\n1 9 8 10\n4 1000000000\n????\n1 1 1 4000000000\n8 1000000000\n?P?SSP?P\n-857095623 -1424391899 -851974476 673437144 471253851 -543483033 364945701 -178537332\n4 7\nPPSS\n4 2 1 3\n9 20\n?????????\n1 2 3 4 5 6 7 8 9\n3 1000000000\nP??\n-145463248 -974068460 -1287458396",
                "output": "1\n0\n2\n1\n14\n1"
            }
        ]
    },
    {
        "problem": "\nThe secret behind Oscar's first magic trick has been revealed! Because he still wants to impress Lura, he comes up with a new idea: he still wants to sort a permutation $p_1, p_2, \\ldots, p_n$ of $[1, 2, \\ldots, n]$.\n\nThis time, he chooses an integer $k$. He wants to sort the permutation in non-decreasing order using the following operation several times:\n\n  1. Pick a continuous subarray of length $k$ and remove it from $p$.    2. Insert the continuous subarray back into $p$ at any position (perhaps, in the very front or the very back). \n\nTo be as impressive as possible, Oscar would like to choose the maximal value of $k$ such that he can sort his permutation. Please help him find the maximal $k$ as well as a sequence of operations that will sort the permutation. You don't need to minimize the number of operations, but you are allowed to use at most $5n^2$ operations.\n\nWe have a proof that, for the maximal $k$ such that you can sort the permutation in any number of operations, you can also sort it in at most $5n^2$ operations.\n\nInput Format:\nThe first line contains a single integer $t$ ($1 \\leq t \\leq 10^3$) \u2014 the number of test cases.\n\nThe first line of each test case contains a single integer $n$ ($5 \\leq n \\leq 10^3$) \u2014 the length of the permutation.\n\nThe second line of each test case contains a permutation $p_1, p_2, \\ldots, p_n$ of $[1, 2, \\ldots, n]$.\n\nThe sum of $n$ over all test cases does not exceed $2 \\cdot 10^3$.\n\nOutput Format:\nFor each test case, first output the chosen value of $k$ on a new line ($1 \\leq k \\leq n$).\n\nThen, output a single integer $m$ \u2014 the number of operations used ($0 \\leq m \\leq 5n^2$).\n\nThen, on each of the next $m$ lines, output the operations denoted by two integers $i$ and $j$ ($1 \\leq i, j \\leq n - k + 1$), representing an operation where you remove the subarray starting from index $i$ and replace it back into $p$ at index $j$.\n\nTags:\n['constructive algorithms', 'implementation', 'sortings']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "3\n5\n5 1 2 3 4\n5\n2 3 5 4 1\n6\n1 2 3 4 5 6",
                "output": "4\n1\n2 1\n3\n2\n1 3\n2 1\n6\n0"
            }
        ]
    },
    {
        "problem": "\nThere are $n$ towers at $n$ distinct points $(x_1, y_1), (x_2, y_2), \\ldots, (x_n, y_n)$, such that no three are collinear and no four are concyclic. Initially, you own towers $(x_1, y_1)$ and $(x_2, y_2)$, and you want to capture all of them. To do this, you can do the following operation any number of times:\n\n  * Pick two towers $P$ and $Q$ you own and one tower $R$ you don't own, such that the circle through $P$, $Q$, and $R$ contains all $n$ towers inside of it.    * Afterwards, capture all towers in or on triangle $\\triangle PQR$, including $R$ itself. \n\nAn attack plan is a series of choices of $R$ ($R_1, R_2, \\ldots, R_k$) using the above operations after which you capture all towers. Note that two attack plans are considered different only if they differ in their choice of $R$ in some operation; in particular, two attack plans using the same choices of $R$ but different choices of $P$ and $Q$ are considered the same.\n\nCount the number of attack plans of minimal length. Note that it might not be possible to capture all towers, in which case the answer is $0$.\n\nSince the answer may be large, output it modulo $998\\,244\\,353$.\n\nInput Format:\nThe first line contains a single integer $t$ ($1 \\leq t \\leq 250$) \u2014 the number of test cases.\n\nThe first line of each test case contains a single integer $n$ ($4 \\leq n \\leq 100$) \u2014 the number of towers.\n\nThe $i$-th of the next $n$ lines contains two integers $x_i$ and $y_i$ ($-10^4 \\leq x_i, y_i \\leq 10^4$) \u2014 the location of the $i$-th tower. Initially, you own towers $(x_1, y_1)$ and $(x_2, y_2)$.\n\nAll towers are at distinct locations, no three towers are collinear, and no four towers are concyclic.\n\nThe sum of $n$ over all test cases does not exceed $1000$.\n\nOutput Format:\nFor each test case, output a single integer \u2014 the number of attack plans of minimal length after which you capture all towers, modulo $998\\,244\\,353$.\n\nTags:\n['combinatorics', 'dp', 'geometry']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "3\n5\n1 1\n2 5\n3 3\n4 2\n5 4\n6\n1 1\n3 3\n1 2\n2 1\n3 10000\n19 84\n7\n2 7\n-4 -3\n-3 6\n3 1\n-5 2\n1 -4\n-1 7",
                "output": "1\n0\n10"
            }
        ]
    },
    {
        "problem": "\nMatthew is given two strings $a$ and $b$, both of length $3$. He thinks it's particularly funny to create two new words by swapping the first character of $a$ with the first character of $b$. He wants you to output $a$ and $b$ after the swap.\n\nNote that the new words may not necessarily be different.\n\nInput Format:\nThe first line contains $t$ ($1 \\leq t \\leq 100$)  \u2014 the number of test cases.\n\nThe first and only line of each test case contains two space-separated strings, $a$ and $b$, both of length $3$. The strings only contain lowercase Latin letters.\n\nOutput Format:\nFor each test case, after the swap, output $a$ and $b$, separated by a space.\n\nTags:\n['implementation', 'strings']\n\nTime Limit: 1000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "6\nbit set\ncat dog\nhot dog\nuwu owo\ncat cat\nzzz zzz",
                "output": "sit bet\ndat cog\ndot hog\nowu uwo\ncat cat\nzzz zzz"
            }
        ]
    },
    {
        "problem": "\nGiven an integer $n$, find an integer $x$ such that:\n\n  * $2 \\leq x \\leq n$.    * The sum of multiples of $x$ that are less than or equal to $n$ is maximized. Formally, $x + 2x + 3x + \\dots + kx$ where $kx \\leq n$ is maximized over all possible values of $x$.\n\nInput Format:\nThe first line contains $t$ ($1 \\leq t \\leq 100$) \u2014 the number of test cases.\n\nEach test case contains a single integer $n$ ($2 \\leq n \\leq 100$).\n\nOutput Format:\nFor each test case, output an integer, the optimal value of $x$. It can be shown there is only one unique answer.\n\nTags:\n['brute force', 'math', 'number theory']\n\nTime Limit: 1000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "2\n3\n15",
                "output": "3\n2"
            }
        ]
    },
    {
        "problem": "\nAlex thinks some array is good if there exists some element that can be represented as the sum of all other elements (the sum of all other elements is $0$ if there are no other elements). For example, the array $[1,6,3,2]$ is good since $1+3+2=6$. Furthermore, the array $[0]$ is also good. However, the arrays $[1,2,3,4]$ and $[1]$ are not good.\n\nAlex has an array $a_1,a_2,\\ldots,a_n$. Help him count the number of good non-empty prefixes of the array $a$. In other words, count the number of integers $i$ ($1 \\le i \\le n$) such that the length $i$ prefix (i.e. $a_1,a_2,\\ldots,a_i$) is good.\n\nInput Format:\nThe first line of the input contains a single integer $t$ ($1 \\leq t \\leq 10^4$) \u2014 the number of test cases.\n\nThe first line of each test case contains a single integer $n$ ($1 \\le n \\le 2 \\cdot 10^5$) \u2014 the number of elements in the array.\n\nThe second line of each test case contains $n$ integers $a_1,a_2,\\ldots,a_n$ ($0 \\le a_i \\le 10^9$) \u2014 the elements of the array.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\nOutput Format:\nFor each test case, output a single integer \u2014 the number of good non-empty prefixes of the array $a$.\n\nTags:\n['greedy']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "7\n1\n0\n1\n1\n4\n1 1 2 0\n5\n0 1 2 1 4\n7\n1 1 0 3 5 2 12\n7\n1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 294967296\n10\n0 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 589934592",
                "output": "1\n0\n3\n3\n4\n1\n2"
            }
        ]
    },
    {
        "problem": "\nGiven a $n$ by $m$ grid consisting of '.' and '#' characters, there exists a whole manhattan circle on the grid. The top left corner of the grid has coordinates $(1,1)$, and the bottom right corner has coordinates $(n, m)$.\n\nPoint ($a, b$) belongs to the manhattan circle centered at ($h, k$) if $|h - a| + |k - b| < r$, where $r$ is a positive constant.\n\nOn the grid, the set of points that are part of the manhattan circle is marked as '#'. Find the coordinates of the center of the circle.\n\nInput Format:\nThe first line contains $t$ ($1 \\leq t \\leq 1000$)  \u2014 the number of test cases.\n\nThe first line of each test case contains $n$ and $m$ ($1 \\leq n \\cdot m \\leq 2 \\cdot 10^5$) \u2014 the height and width of the grid, respectively.\n\nThe next $n$ lines contains $m$ characters '.' or '#'. If the character is '#', then the point is part of the manhattan circle.\n\nIt is guaranteed the sum of $n \\cdot m$ over all test cases does not exceed $2 \\cdot 10^5$, and there is a whole manhattan circle on the grid.\n\nOutput Format:\nFor each test case, output the two integers, the coordinates of the center of the circle.\n\nTags:\n['implementation', 'math']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "6\n5 5\n.....\n.....\n..#..\n.....\n.....\n5 5\n..#..\n.###.\n#####\n.###.\n..#..\n5 6\n......\n......\n.#....\n###...\n.#....\n1 1\n#\n5 6\n...#..\n..###.\n.#####\n..###.\n...#..\n2 10\n..........\n...#......",
                "output": "3 3\n3 3\n4 2\n1 1\n3 4\n2 4"
            }
        ]
    },
    {
        "problem": "\nNtarsis has a box $B$ with side lengths $x$, $y$, and $z$. It lies in the 3D coordinate plane, extending from $(0,0,0)$ to $(x,y,z)$.\n\nNtarsis has a secret box $S$. He wants to choose its dimensions such that all side lengths are positive integers, and the volume of $S$ is $k$. He can place $S$ somewhere within $B$ such that:\n\n  * $S$ is parallel to all axes.    * every corner of $S$ lies on an integer coordinate. \n\n$S$ is magical, so when placed at an integer location inside $B$, it will not fall to the ground.\n\nAmong all possible ways to choose the dimensions of $S$, determine the maximum number of distinct locations he can choose to place his secret box $S$ inside $B$. Ntarsis does not rotate $S$ once its side lengths are selected.\n\nInput Format:\nThe first line consists of an integer $t$, the number of test cases ($1 \\leq t \\leq 2000$). The description of the test cases follows.\n\nThe first and only line of each test case contains four integers $x, y, z$ and $k$ ($1 \\leq x, y, z \\leq 2000$, $1 \\leq k \\leq x \\cdot y \\cdot z$).\n\nIt is guaranteed the sum of all $x$, sum of all $y$, and sum of all $z$ do not exceed $2000$ over all test cases.\n\nNote that $k$ may not fit in a standard 32-bit integer data type.\n\nOutput Format:\nFor each test case, output the answer as an integer on a new line. If there is no way to select the dimensions of $S$ so it fits in $B$, output $0$.\n\nTags:\n['brute force', 'combinatorics', 'math']\n\nTime Limit: 1000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "7\n3 3 3 8\n3 3 3 18\n5 1 1 1\n2 2 2 7\n3 4 2 12\n4 3 1 6\n1800 1800 1800 4913000000",
                "output": "8\n2\n5\n0\n4\n4\n1030301"
            }
        ]
    },
    {
        "problem": "\nYou are facing the final boss in your favorite video game. The boss enemy has $h$ health. Your character has $n$ attacks. The $i$'th attack deals $a_i$ damage to the boss but has a cooldown of $c_i$ turns, meaning the next time you can use this attack is turn $x + c_i$ if your current turn is $x$. Each turn, you can use all attacks that are not currently on cooldown, all at once. If all attacks are on cooldown, you do nothing for the turn and skip to the next turn.\n\nInitially, all attacks are not on cooldown. How many turns will you take to beat the boss? The boss is beaten when its health is $0$ or less.\n\nInput Format:\nThe first line contains $t$ ($1 \\leq t \\leq 10^4$)  \u2013 the number of test cases.\n\nThe first line of each test case contains two integers $h$ and $n$ ($1 \\leq h, n \\leq 2 \\cdot 10^5$) \u2013 the health of the boss and the number of attacks you have.\n\nThe following line of each test case contains $n$ integers $a_1, a_2, ..., a_n$ ($1 \\leq a_i \\leq 2 \\cdot 10^5$) \u2013 the damage of your attacks.\n\nThe following line of each test case contains $n$ integers $c_1, c_2, ..., c_n$ ($1 \\leq c_i \\leq 2 \\cdot 10^5$) \u2013 the cooldown of your attacks.\n\nIt is guaranteed that the sum of $h$ and $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\nOutput Format:\nFor each test case, output an integer, the minimum number of turns required to beat the boss.\n\nTags:\n['binary search', 'data structures']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "8\n3 2\n2 1\n2 1\n5 2\n2 1\n2 1\n50 3\n5 6 7\n5 6 7\n50 3\n2 2 2\n3 3 3\n90000 2\n200000 200000\n1 1\n100000 1\n1\n200000\n6 7\n3 2 3 2 3 1 2\n6 5 9 5 10 7 7\n21 6\n1 1 1 1 1 1\n5 5 8 10 7 6",
                "output": "1\n3\n15\n25\n1\n19999800001\n1\n21"
            }
        ]
    },
    {
        "problem": "\nLet $D(n)$ represent the sum of digits of $n$. For how many integers $n$ where $10^{l} \\leq n < 10^{r}$ satisfy $D(k \\cdot n) = k \\cdot D(n)$? Output the answer modulo $10^9+7$.\n\nInput Format:\nThe first line contains an integer $t$ ($1 \\leq t \\leq 10^4$) \u2013 the number of test cases.\n\nEach test case contains three integers $l$, $r$, and $k$ ($0 \\leq l < r \\leq 10^9$, $1 \\leq k \\leq 10^9$).\n\nOutput Format:\nFor each test case, output an integer, the answer, modulo $10^9 + 7$.\n\nTags:\n['combinatorics', 'math', 'number theory']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "6\n0 1 4\n0 2 7\n1 2 1\n1 2 3\n582 74663 3\n0 3 1",
                "output": "2\n3\n90\n12\n974995667\n999"
            }
        ]
    },
    {
        "problem": "\nEasy and hard versions are actually different problems, so read statements of both problems completely and carefully. The only difference between the two versions is the operation.\n\nAlex has a grid with $n$ rows and $m$ columns consisting of '.' and '#' characters. A set of '#' cells forms a connected component if from any cell in this set, it is possible to reach any other cell in this set by only moving to another cell in the set that shares a common side. The size of a connected component is the number of cells in the set.\n\nIn one operation, Alex selects any row $r$ ($1 \\le r \\le n$) or any column $c$ ($1 \\le c \\le m$), then sets every cell in row $r$ or column $c$ to be '#'. Help Alex find the maximum possible size of the largest connected component of '#' cells that he can achieve after performing the operation at most once.\n\nInput Format:\nThe first line of the input contains a single integer $t$ ($1 \\leq t \\leq 10^4$) \u2014 the number of test cases.\n\nThe first line of each test case contains two integers $n$ and $m$ ($1 \\le n \\cdot m \\le 10^6$) \u2014 the number of rows and columns of the grid.\n\nThe next $n$ lines each contain $m$ characters. Each character is either '.' or '#'.\n\nIt is guaranteed that the sum of $n \\cdot m$ over all test cases does not exceed $10^6$.\n\nOutput Format:\nFor each test case, output a single integer \u2014 the maximum possible size of a connected component of '#' cells that Alex can achieve.\n\nTags:\n['brute force', 'data structures', 'dfs and similar', 'dsu', 'graphs', 'implementation']\n\nTime Limit: 2000 ms\nMemory Limit: 512 MB\n",
        "tests": [
            {
                "input": "6\n1 1\n.\n4 2\n..\n#.\n#.\n.#\n3 5\n.#.#.\n..#..\n.#.#.\n5 5\n#...#\n....#\n#...#\n.....\n...##\n6 6\n.#..#.\n#..#..\n.#...#\n#.#.#.\n.#.##.\n###..#\n6 8\n..#....#\n.####.#.\n###.#..#\n.##.#.##\n.#.##.##\n#..##.#.",
                "output": "1\n6\n9\n11\n15\n30"
            }
        ]
    },
    {
        "problem": "\nEasy and hard versions are actually different problems, so read statements of both problems completely and carefully. The only difference between the two versions is the operation.\n\nAlex has a grid with $n$ rows and $m$ columns consisting of '.' and '#' characters. A set of '#' cells forms a connected component if from any cell in this set, it is possible to reach any other cell in this set by only moving to another cell in the set that shares a common side. The size of a connected component is the number of cells in the set.\n\nIn one operation, Alex selects any row $r$ ($1 \\le r \\le n$) and any column $c$ ($1 \\le c \\le m$), then sets every cell in row $r$ and column $c$ to be '#'. Help Alex find the maximum possible size of the largest connected component of '#' cells that he can achieve after performing the operation at most once.\n\nInput Format:\nThe first line of the input contains a single integer $t$ ($1 \\leq t \\leq 10^4$) \u2014 the number of test cases.\n\nThe first line of each test case contains two integers $n$ and $m$ ($1 \\le n \\cdot m \\le 10^6$) \u2014 the number of rows and columns of the grid.\n\nThe next $n$ lines each contain $m$ characters. Each character is either '.' or '#'.\n\nIt is guaranteed that the sum of $n \\cdot m$ over all test cases does not exceed $10^6$.\n\nOutput Format:\nFor each test case, output a single integer \u2014 the maximum possible size of a connected component of '#' cells that Alex can achieve.\n\nTags:\n['data structures', 'dfs and similar', 'dp', 'dsu', 'implementation']\n\nTime Limit: 2000 ms\nMemory Limit: 512 MB\n",
        "tests": [
            {
                "input": "6\n1 1\n.\n4 2\n..\n#.\n#.\n.#\n3 5\n.#.#.\n..#..\n.#.#.\n5 5\n#...#\n....#\n#...#\n.....\n...##\n6 6\n.#..#.\n#..#..\n.#...#\n#.#.#.\n.#.##.\n###..#\n6 8\n..#....#\n.####.#.\n###.#..#\n.##.#.##\n.#.##.##\n#..##.#.",
                "output": "1\n7\n11\n16\n22\n36"
            }
        ]
    },
    {
        "problem": "\nYou are given three points with integer coordinates $x_1$, $x_2$, and $x_3$ on the $X$ axis ($1 \\leq x_i \\leq 10$). You can choose any point with an integer coordinate $a$ on the $X$ axis. Note that the point $a$ may coincide with $x_1$, $x_2$, or $x_3$. Let $f(a)$ be the total distance from the given points to the point $a$. Find the smallest value of $f(a)$.\n\nThe distance between points $a$ and $b$ is equal to $|a - b|$. For example, the distance between points $a = 5$ and $b = 2$ is $3$.\n\nInput Format:\nEach test consists of multiple test cases. The first line contains a single integer $t$ ($1 \\leq t \\leq 10^3$) \u2014 the number of test cases. Then follows their descriptions.\n\nThe single line of each test case contains three integers $x_1$, $x_2$, and $x_3$ ($1 \\leq x_i \\leq 10$) \u2014 the coordinates of the points.\n\nOutput Format:\nFor each test case, output the smallest value of $f(a)$.\n\nTags:\n['brute force', 'geometry', 'math', 'sortings']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "8\n1 1 1\n1 5 9\n8 2 8\n10 9 3\n2 1 1\n2 4 1\n7 3 5\n1 9 4",
                "output": "0\n8\n6\n7\n1\n3\n4\n8"
            }
        ]
    },
    {
        "problem": "\nYou are given a matrix of size $n \\times m$, where the rows are numbered from $1$ to $n$ from top to bottom, and the columns are numbered from $1$ to $m$ from left to right. The element at the intersection of the $i$-th row and the $j$-th column is denoted by $a_{ij}$.\n\nConsider the algorithm for stabilizing matrix $a$:\n\n  1. Find the cell $(i, j)$ such that its value is strictly greater than the values of all its neighboring cells. If there is no such cell, terminate the algorithm. If there are multiple such cells, choose the cell with the smallest value of $i$, and if there are still multiple cells, choose the one with the smallest value of $j$.   2. Set $a_{ij} = a_{ij} - 1$.    3. Go to step $1$. \n\nIn this problem, cells $(a, b)$ and $(c, d)$ are considered neighbors if they share a common side, i.e., $|a - c| + |b - d| = 1$.\n\nYour task is to output the matrix $a$ after the stabilization algorithm has been executed. It can be shown that this algorithm cannot run for an infinite number of iterations.\n\nInput Format:\nEach test consists of multiple sets of input data. The first line contains a single integer $t$ ($1 \\leq t \\leq 10^4$) \u2014 the number of sets of input data. This is followed by their description.\n\nThe first line of each set of input data contains two integers $n$ and $m$ ($1 \\leq n, m \\leq 100, n \\cdot m > 1$) \u2014 the number of rows and columns of matrix $a$.\n\nThe next $n$ lines describe the corresponding rows of the matrix. The $i$-th line contains $m$ integers $a_{i1}, a_{i2}, \\ldots, a_{im}$ ($1 \\leq a_{ij} \\leq 10^9$).\n\nIt is guaranteed that the sum of $n \\cdot m$ over all sets of input data does not exceed $2 \\cdot 10^5$.\n\nOutput Format:\nFor each set of input data, output $n$ lines with $m$ numbers in each line \u2014 the values of the cells of matrix $a$ after the stabilization algorithm.\n\nTags:\n['brute force', 'data structures', 'greedy', 'sortings']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "6\n1 2\n3 1\n2 1\n1\n1\n2 2\n1 2\n3 4\n2 3\n7 4 5\n1 8 10\n5 4\n92 74 31 74\n74 92 17 7\n31 17 92 3\n74 7 3 92\n7 31 1 1\n3 3\n1000000000 1 1000000000\n1 1000000000 1\n1000000000 1 1000000000",
                "output": "1 1 \n1 \n1 \n1 2 \n3 3 \n4 4 5 \n1 8 8 \n74 74 31 31 \n74 74 17 7 \n31 17 17 3 \n31 7 3 3 \n7 7 1 1 \n1 1 1 \n1 1 1 \n1 1 1"
            }
        ]
    },
    {
        "problem": "\nLet's consider the following simple problem. You are given a string $s$ of length $n$, consisting of lowercase Latin letters, as well as an array of indices $ind$ of length $m$ ($1 \\leq ind_i \\leq n$) and a string $c$ of length $m$, consisting of lowercase Latin letters. Then, in order, you perform the update operations, namely, during the $i$-th operation, you set $s_{ind_i} = c_i$. Note that you perform all $m$ operations from the first to the last.\n\nOf course, if you change the order of indices in the array $ind$ and/or the order of letters in the string $c$, you can get different results. Find the lexicographically smallest string $s$ that can be obtained after $m$ update operations, if you can rearrange the indices in the array $ind$ and the letters in the string $c$ as you like.\n\nA string $a$ is lexicographically less than a string $b$ if and only if one of the following conditions is met:\n\n  * $a$ is a prefix of $b$, but $a \\neq b$;   * in the first position where $a$ and $b$ differ, the symbol in string $a$ is earlier in the alphabet than the corresponding symbol in string $b$.\n\nInput Format:\nEach test consists of several sets of input data. The first line contains a single integer $t$ ($1 \\leq t \\leq 10^4$) \u2014 the number of sets of input data. Then follows their description.\n\nThe first line of each set of input data contains two integers $n$ and $m$ ($1 \\leq n, m \\leq 10^5$) \u2014 the length of the string $s$ and the number of updates.\n\nThe second line of each set of input data contains a string $s$ of length $n$, consisting of lowercase Latin letters.\n\nThe third line of each set of input data contains $m$ integers $ind_1, ind_2, \\ldots, ind_m$ ($1 \\leq ind_i \\leq n$) \u2014 the array of indices $ind$.\n\nThe fourth line of each set of input data contains a string $c$ of length $m$, consisting of lowercase Latin letters.\n\nIt is guaranteed that the sum of $n$ over all sets of input data does not exceed $2 \\cdot 10^5$. Similarly, the sum of $m$ over all sets of input data does not exceed $2 \\cdot 10^5$.\n\nOutput Format:\nFor each set of input data, output the lexicographically smallest string $s$ that can be obtained by rearranging the indices in the array $ind$ and the letters in the string $c$ as you like.\n\nTags:\n['data structures', 'greedy', 'sortings']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "4\n1 2\na\n1 1\ncb\n4 4\nmeow\n1 2 1 4\nzcwz\n7 4\nabacaba\n1 3 5 7\ndamn\n7 10\ntraktor\n7 6 5 4 3 2 1 6 4 2\ncodeforces",
                "output": "b\ncwoz\nabdcmbn\nccdeefo"
            }
        ]
    },
    {
        "problem": "\nYou are given a string $s$ of length $n > 1$, consisting of digits from $0$ to $9$. You must insert exactly $n - 2$ symbols $+$ (addition) or $\\times$ (multiplication) into this string to form a valid arithmetic expression.\n\nIn this problem, the symbols cannot be placed before the first or after the last character of the string $s$, and two symbols cannot be written consecutively. Also, note that the order of the digits in the string cannot be changed. Let's consider $s = 987009$:\n\n  * From this string, the following arithmetic expressions can be obtained: $9 \\times 8 + 70 \\times 0 + 9 = 81$, $98 \\times 7 \\times 0 + 0 \\times 9 = 0$, $9 + 8 + 7 + 0 + 09 = 9 + 8 + 7 + 0 + 9 = 33$. Note that the number $09$ is considered valid and is simply transformed into $9$.   * From this string, the following arithmetic expressions cannot be obtained: $+9 \\times 8 \\times 70 + 09$ (symbols should only be placed between digits), $98 \\times 70 + 0 + 9$ (since there are $6$ digits, there must be exactly $4$ symbols).\n\nThe result of the arithmetic expression is calculated according to the rules of mathematics \u2014 first all multiplication operations are performed, then addition. You need to find the minimum result that can be obtained by inserting exactly $n - 2$ addition or multiplication symbols into the given string $s$.\n\nInput Format:\nEach test consists of multiple test cases. The first line contains a single integer $t$ ($1 \\leq t \\leq 10^4$) \u2014 the number of test cases. Then follows their description.\n\nThe first line of each test case contains a single integer $n$ ($2 \\leq n \\leq 20$) \u2014 the length of the string $s$.\n\nThe second line of each test case contains a string $s$ of length $n$, consisting of digits from $0$ to $9$.\n\nOutput Format:\nFor each test case, output the minimum result of the arithmetic expression that can be obtained by inserting exactly $n - 2$ addition or multiplication symbols into the given string.\n\nTags:\n['brute force', 'dp', 'greedy', 'implementation', 'math', 'two pointers']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "18\n2\n10\n2\n74\n2\n00\n2\n01\n3\n901\n3\n101\n5\n23311\n6\n987009\n7\n1111111\n20\n99999999999999999999\n20\n00000000000000000000\n4\n0212\n18\n057235283621345395\n4\n1112\n20\n19811678487321784121\n4\n1121\n4\n2221\n3\n011",
                "output": "10\n74\n0\n1\n9\n1\n19\n0\n11\n261\n0\n0\n0\n12\n93\n12\n24\n0"
            }
        ]
    },
    {
        "problem": "\nYou are given an array of integers $a_1, a_2, \\ldots, a_n$ and an integer $k$. You need to make it beautiful with the least amount of operations.\n\nBefore applying operations, you can shuffle the array elements as you like. For one operation, you can do the following:\n\n  * Choose an index $1 \\leq i \\leq n$,   * Make $a_i = a_i + k$.\n\nThe array $b_1, b_2, \\ldots, b_n$ is beautiful if $b_i = b_{n - i + 1}$ for all $1 \\leq i \\leq n$.\n\nFind the minimum number of operations needed to make the array beautiful, or report that it is impossible.\n\nInput Format:\nEach test consists of several sets of input data. The first line contains a single integer $t$ ($1 \\leq t \\leq 10^4$) \u2014 the number of sets of input data. Then follows their description.\n\nThe first line of each set of input data contains two integers $n$ and $k$ ($1 \\leq n \\leq 10^5$, $1 \\leq k \\leq 10^9$) \u2014 the size of the array $a$ and the number $k$ from the problem statement.\n\nThe second line of each set of input data contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\leq a_i \\leq 10^9$) \u2014 the elements of the array $a$.\n\nIt is guaranteed that the sum of $n$ over all sets of input data does not exceed $2 \\cdot 10^5$.\n\nOutput Format:\nFor each set of input data, output the minimum number of operations needed to make the array beautiful, or $-1$ if it is impossible.\n\nTags:\n['greedy', 'math', 'number theory', 'sortings']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "11\n1 1000000000\n1\n2 1\n624323799 708290323\n3 1\n3 2 1\n4 1\n7 1 5 3\n5 1\n11 2 15 7 10\n7 1\n1 8 2 16 8 16 31\n13 1\n2 1 1 3 3 11 12 22 45 777 777 1500 74\n10 2\n1 2 1 2 1 2 1 2 1 2\n11 2\n1 2 1 2 1 2 1 2 1 2 1\n13 3\n2 3 9 14 17 10 22 20 18 30 1 4 28\n5 1\n2 3 5 3 5",
                "output": "0\n83966524\n1\n4\n6\n1\n48\n-1\n0\n14\n0"
            }
        ]
    },
    {
        "problem": "\nYou are given a connected undirected graph, the vertices of which are numbered with integers from $1$ to $n$. Your task is to minimize the number of pairs of vertices $1 \\leq u < v \\leq n$ between which there exists a path in this graph. To achieve this, you can remove exactly one edge from the graph.\n\nFind the smallest number of pairs of vertices!\n\nInput Format:\nEach test consists of several sets of input data. The first line contains a single integer $t$ ($1 \\leq t \\leq 10^4$) \u2014 the number of sets of input data. Then follows their description.\n\nThe first line of each set of input data contains two integers $n$ and $m$ ($2 \\leq n \\leq 10^5$, $n - 1 \\leq m \\leq \\min(10^5, \\frac{n \\cdot (n - 1)}{2})$) \u2014 the number of vertices in the graph and the number of edges.\n\nEach of the next $m$ lines contains two integers $u$ and $v$ ($1 \\leq u, v \\leq n, u \\neq v$), indicating that there is an undirected edge in the graph between vertices $u$ and $v$.\n\nIt is guaranteed that the given graph is connected and without multiple edges.\n\nIt is guaranteed that the sum of $n$ and the sum of $m$ over all sets of input data does not exceed $2 \\cdot 10^5$.\n\nOutput Format:\nFor each set of input data, output the smallest number of pairs of reachable vertices, if exactly one edge can be removed.\n\nTags:\n['dfs and similar', 'graphs', 'trees']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "6\n2 1\n1 2\n3 3\n1 2\n2 3\n1 3\n5 5\n1 2\n1 3\n3 4\n4 5\n5 3\n6 7\n1 2\n1 3\n2 3\n3 4\n4 5\n4 6\n5 6\n5 5\n1 2\n1 3\n2 3\n2 4\n3 5\n10 12\n1 2\n1 3\n2 3\n2 4\n4 5\n5 6\n6 7\n7 4\n3 8\n8 9\n9 10\n10 8",
                "output": "0\n3\n4\n6\n6\n21"
            }
        ]
    },
    {
        "problem": "\nThis is a simple version of the problem. The only difference is that in this version $n \\leq 10^5$ and the sum of $n$ for all sets of input data does not exceed $10^5$.\n\nYou are given a permutation $p$ of length $n$. Calculate the number of index pairs $1 \\leq i < j \\leq n$ such that $p_i \\cdot p_j$ is divisible by $i \\cdot j$ without remainder.\n\nA permutation is a sequence of $n$ integers, where each integer from $1$ to $n$ occurs exactly once. For example, $[1]$, $[3,5,2,1,4]$, $[1,3,2]$ are permutations, while $[2,3,2]$, $[4,3,1]$, $[0]$ are not.\n\nInput Format:\nEach test consists of multiple sets of input data. The first line contains a single integer $t$ ($1 \\leq t \\leq 10^4$) \u2014 the number of sets of input data. Then follows their description.\n\nThe first line of each set of input data contains a single integer $n$ ($1 \\leq n \\leq 10^5$) \u2014 the length of the permutation $p$.\n\nThe second line of each set of input data contains $n$ distinct integers $p_1, p_2, \\ldots, p_n$ ($1 \\leq p_i \\leq n$) \u2014 the permutation $p$.\n\nIt is guaranteed that the sum of $n$ for all sets of input data does not exceed $10^5$.\n\nOutput Format:\nFor each set of input data, output the number of index pairs $1 \\leq i < j \\leq n$ such that $p_i \\cdot p_j$ is divisible by $i \\cdot j$ without remainder.\n\nTags:\n['binary search', 'brute force', 'combinatorics', 'data structures', 'math', 'number theory']\n\nTime Limit: 3000 ms\nMemory Limit: 128 MB\n",
        "tests": [
            {
                "input": "6\n1\n1\n2\n1 2\n3\n2 3 1\n5\n2 4 1 3 5\n12\n8 9 7 12 1 10 6 3 2 4 11 5\n15\n1 2 4 6 8 10 12 14 3 9 15 5 7 11 13",
                "output": "0\n1\n1\n3\n9\n3"
            }
        ]
    },
    {
        "problem": "\nThis is the hard version of the problem. The only difference is that in this version $n \\leq 5 \\cdot 10^5$ and the sum of $n$ for all sets of input data does not exceed $5 \\cdot 10^5$.\n\nYou are given a permutation $p$ of length $n$. Calculate the number of index pairs $1 \\leq i < j \\leq n$ such that $p_i \\cdot p_j$ is divisible by $i \\cdot j$ without remainder.\n\nA permutation is a sequence of $n$ integers, in which each integer from $1$ to $n$ occurs exactly once. For example, $[1]$, $[3,5,2,1,4]$, $[1,3,2]$ are permutations, while $[2,3,2]$, $[4,3,1]$, $[0]$ are not.\n\nInput Format:\nEach test consists of several sets of input data. The first line contains a single integer $t$ ($1 \\leq t \\leq 10^4$) \u2014 the number of sets of input data. Then follows their description.\n\nThe first line of each set of input data contains a single integer $n$ ($1 \\leq n \\leq 5 \\cdot 10^5$) \u2014 the length of the permutation $p$.\n\nThe second line of each set of input data contains $n$ distinct integers $p_1, p_2, \\ldots, p_n$ ($1 \\leq p_i \\leq n$) \u2014 the permutation $p$.\n\nIt is guaranteed that the sum of $n$ for all sets of input data does not exceed $5 \\cdot 10^5$.\n\nOutput Format:\nFor each set of input data, output the number of index pairs $1 \\leq i < j \\leq n$ such that $p_i \\cdot p_j$ is divisible by $i \\cdot j$ without remainder.\n\nTags:\n['brute force', 'data structures', 'hashing', 'math', 'number theory']\n\nTime Limit: 3000 ms\nMemory Limit: 128 MB\n",
        "tests": [
            {
                "input": "6\n1\n1\n2\n1 2\n3\n2 3 1\n5\n2 4 1 3 5\n12\n8 9 7 12 1 10 6 3 2 4 11 5\n15\n1 2 4 6 8 10 12 14 3 9 15 5 7 11 13",
                "output": "0\n1\n1\n3\n9\n3"
            }
        ]
    },
    {
        "problem": "\nOh no, the ForceCodes servers are running out of memory! Luckily, you can help them out by uploading some of your RAM!\n\nYou want to upload $n$ GBs of RAM. Every second, you will upload either $0$ or $1$ GB of RAM. However, there is a restriction on your network speed: in any $k$ consecutive seconds, you can upload only at most $1$ GB of RAM in total.\n\nFind the minimum number of seconds needed to upload $n$ GBs of RAM!\n\nInput Format:\nEach test contains multiple test cases. The first line of input contains a single integer $t$ ($1 \\le t \\le 10^4$) \u2014 the number of test cases. The description of the test cases follows.\n\nThe first and only line of each test case contains two integers $n$ and $k$ ($1 \\le n, k \\le 100$) \u2014 the number of GBs that you want to upload and the length of the time window respectively.\n\nOutput Format:\nFor each test case, output a single integer \u2014 the minimum number of seconds needed to upload $n$ GBs of RAM.\n\nTags:\n['greedy', 'math']\n\nTime Limit: 1000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "6\n5 1\n2 2\n2 3\n1 7\n11 5\n100 100",
                "output": "5\n3\n4\n1\n51\n9901"
            }
        ]
    },
    {
        "problem": "\nYou are given an array of integers $a$ of length $n$.\n\nYou can apply the following operation any number of times (maybe, zero):\n\n  * First, choose an integer $k$ such that $1 \\le k \\le n$ and pay $k + 1$ coins.    * Then, choose exactly $k$ indices such that $1 \\le i_1 < i_2 < \\ldots < i_k \\le n$.    * Then, for each $x$ from $1$ to $k$, increase $a_{i_x}$ by $1$. \n\nFind the minimum number of coins needed to make $a$ non-decreasing. That is, $a_1 \\le a_2 \\le \\ldots \\le a_n$.\n\nInput Format:\nEach test contains multiple test cases. The first line of input contains a single integer $t$ ($1 \\le t \\le 10^4$) \u2014 the number of test cases. The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($1 \\le n \\le 10^5$) \u2014 the length of the array $a$.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\le a_i \\le 10^9$) \u2014 the elements of the array $a$.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $10^5$.\n\nOutput Format:\nFor each test case, output a single integer \u2014 the minimum number of coins needed to make $a$ non-decreasing.\n\nTags:\n['greedy']\n\nTime Limit: 1000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "5\n3\n1 7 9\n5\n2 1 4 7 6\n4\n1 3 2 4\n1\n179\n9\n344 12 37 60 311 613 365 328 675",
                "output": "0\n3\n2\n0\n1821"
            }
        ]
    },
    {
        "problem": "\nThere are $n$ flowers in a row, the $i$-th of them initially has a positive height of $h_i$ meters.\n\nEvery second, the wind will blow from the left, causing the height of some flowers to decrease.\n\nSpecifically, every second, for each $i$ from $1$ to $n$, in this order, the following happens:\n\n  * If $i = n$ or $h_i > h_{i + 1}$, the value of $h_i$ changes to $\\max(0, h_i - 1)$. \n\nHow many seconds will pass before $h_i=0$ for all $1 \\le i \\le n$ for the first time?\n\nInput Format:\nEach test contains multiple test cases. The first line of input contains a single integer $t$ ($1 \\le t \\le 10^4$) \u2014 the number of test cases. The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($1 \\le n \\le 10^5$) \u2014 the number of flowers.\n\nThe second line of each test case contains $n$ integers $h_1, h_2, \\ldots, h_n$ ($1 \\le h_i \\le 10 ^ 9$) \u2014 the heights of the flowers.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $10^5$.\n\nOutput Format:\nFor each test case, output a single integer \u2014 the number of seconds that will pass before $h_i=0$ for all $1 \\le i \\le n$.\n\nTags:\n['dp', 'greedy']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "4\n3\n1 1 2\n2\n3 1\n1\n9\n5\n7 4 4 3 2",
                "output": "4\n3\n9\n7"
            }
        ]
    },
    {
        "problem": "\nAlice and Bob are playing a game. Initially, there are $n$ cakes, with the $i$-th cake having a tastiness value of $a_i$.\n\nAlice and Bob take turns eating them, with Alice starting first:\n\n  * In her turn, Alice chooses and eats any remaining cake whose tastiness is strictly greater than the maximum tastiness of any of the cakes she's eaten before that. Note that on the first turn, she can choose any cake.    * In his turn, Bob chooses any remaining cake and eats it. \n\nThe game ends when the current player can't eat a suitable cake. Let $x$ be the number of cakes that Alice ate. Then, Alice wants to maximize $x$, while Bob wants to minimize $x$.\n\nFind out how many cakes Alice will eat if both players play optimally.\n\nInput Format:\nEach test contains multiple test cases. The first line of input contains a single integer $t$ ($1 \\le t \\le 500$) \u2014 the number of test cases. The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($1 \\le n \\le 5000$) \u2014 the number of cakes.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\le a_i \\le n$) \u2014 the tastiness values of the cakes.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $5000$.\n\nOutput Format:\nFor each test case, output a single integer \u2014 the number of cakes Alice will eat if both players play optimally.\n\nTags:\n['dp', 'games']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "9\n4\n1 4 2 3\n3\n1 1 1\n5\n1 4 2 3 4\n4\n3 4 1 4\n1\n1\n8\n4 3 2 5 6 8 3 4\n7\n6 1 1 3 5 3 1\n11\n6 11 6 8 7 5 3 11 2 3 5\n17\n2 6 5 3 9 1 6 2 5 6 3 2 3 9 6 1 6",
                "output": "2\n1\n3\n2\n1\n3\n2\n4\n4"
            }
        ]
    },
    {
        "problem": "\nGod's Blessing on This ArrayForces!\n\nA Random Pebble\n\nYou are given a tree with $n$ vertices, rooted at vertex $1$. The $i$-th vertex has an integer $a_i$ written on it.\n\nLet $L$ be the set of all direct children$^{\\text{\u2217}}$ of $v$. A tree is called wonderful, if for all vertices $v$ where $L$ is not empty, $$a_v \\le \\sum_{u \\in L}{a_u}.$$ In one operation, you choose any vertex $v$ and increase $a_v$ by $1$.\n\nFind the minimum number of operations needed to make the given tree wonderful!\n\n$^{\\text{\u2217}}$ Vertex $u$ is called a direct child of vertex $v$ if:\n\n  * $u$ and $v$ are connected by an edge, and    * $v$ is on the (unique) path from $u$ to the root of the tree.\n\nInput Format:\nEach test contains multiple test cases. The first line of input contains a single integer $t$ ($1 \\le t \\le 1000$) \u2014 the number of test cases. The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($2 \\le n \\le 5000$) \u2014 the number of vertices in the tree.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($0 \\le a_i \\le 10^9$) \u2014 the values initially written on the vertices.\n\nThe third line of each test case contains $n - 1$ integers $p_2, p_3 , \\ldots, p_n$ ($1 \\le p_i < i$), indicating that there is an edge from vertex $p_i$ to vertex $i$. It is guaranteed that the given edges form a tree.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $5000$.\n\nOutput Format:\nFor each test case, output a single integer \u2014 the minimum number of operations needed to make the tree wonderful.\n\nTags:\n['brute force', 'data structures', 'dfs and similar', 'dsu', 'greedy', 'trees']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "4\n5\n9 3 4 1 2\n1 1 3 3\n2\n5 3\n1\n2\n36 54\n1\n3\n0 0 0\n1 2",
                "output": "3\n2\n0\n0"
            }
        ]
    },
    {
        "problem": "\nThis is the easy version of the problem. The only difference between the two versions is the constraint on $n$. You can make hacks only if both versions of the problem are solved.\n\nYou are given an array of integers $a$ of length $n$.\n\nIn one operation, you will perform the following two-step process:\n\n  1. Choose an index $i$ such that $1 \\le i < |a|$ and $a_i = i$.    2. Remove $a_i$ and $a_{i+1}$ from the array and concatenate the remaining parts. \n\nFind the maximum number of times that you can perform the operation above.\n\nInput Format:\nEach test contains multiple test cases. The first line of input contains a single integer $t$ ($1 \\le t \\le 100$) \u2014 the number of test cases. The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($1 \\le n \\le 100$) \u2014 the length of the array $a$.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\le a_i \\le n$) \u2014 the elements of the array $a$.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $100$.\n\nOutput Format:\nFor each test case, output a single integer \u2014 the maximum number of times that you can perform the operation.\n\nTags:\n['dp']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "6\n5\n1 5 3 2 4\n8\n2 1 3 4 5 6 7 8\n3\n1 2 3\n4\n1 2 4 4\n5\n4 4 1 3 5\n1\n1",
                "output": "2\n3\n1\n2\n0\n0"
            }
        ]
    },
    {
        "problem": "\nThis is the hard version of the problem. The only difference between the two versions is the constraint on $n$. You can make hacks only if both versions of the problem are solved.\n\nYou are given an array of integers $a$ of length $n$.\n\nIn one operation, you will perform the following two-step process:\n\n  1. Choose an index $i$ such that $1 \\le i < |a|$ and $a_i = i$.    2. Remove $a_i$ and $a_{i+1}$ from the array and concatenate the remaining parts. \n\nFind the maximum number of times that you can perform the operation above.\n\nInput Format:\nEach test contains multiple test cases. The first line of input contains a single integer $t$ ($1 \\le t \\le 100$) \u2014 the number of test cases. The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($1 \\le n \\le 800$) \u2014 the length of the array $a$.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\le a_i \\le n$) \u2014 the elements of the array $a$.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $800$.\n\nOutput Format:\nFor each test case, output a single integer \u2014 the maximum number of times that you can perform the operation.\n\nTags:\n['dp']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "6\n5\n1 5 3 2 4\n8\n2 1 3 4 5 6 7 8\n3\n1 2 3\n4\n1 2 4 4\n5\n4 4 1 3 5\n1\n1",
                "output": "2\n3\n1\n2\n0\n0"
            }
        ]
    },
    {
        "problem": "\nThis is the easy version of the problem. The only difference between the two versions are the allowed characters in $s$. In the easy version, $s$ only contains the character ?. You can make hacks only if both versions of the problem are solved.\n\nYou are given a permutation $p$ of length $n$. You are also given a string $s$ of length $n$, consisting only of the character ?.\n\nFor each $i$ from $1$ to $n$:\n\n  * Define $l_i$ as the largest index $j < i$ such that $p_j > p_i$. If there is no such index, $l_i := i$.    * Define $r_i$ as the smallest index $j > i$ such that $p_j > p_i$. If there is no such index, $r_i := i$. \n\nInitially, you have an undirected graph with $n$ vertices (numbered from $1$ to $n$) and no edges. Then, for each $i$ from $1$ to $n$, add one edge to the graph:\n\n  * If $s_i =$ L, add the edge $(i, l_i)$ to the graph.    * If $s_i =$ R, add the edge $(i, r_i)$ to the graph.    * If $s_i =$ ?, either add the edge $(i, l_i)$ or the edge $(i, r_i)$ to the graph at your choice. \n\nFind the maximum possible diameter$^{\\text{\u2217}}$ over all connected graphs that you can form. Output $-1$ if it is not possible to form any connected graphs.\n\n$^{\\text{\u2217}}$ Let $d(s, t)$ denote the smallest number of edges on any path between $s$ and $t$.\n\nThe diameter of the graph is defined as the maximum value of $d(s, t)$ over all pairs of vertices $s$ and $t$.\n\nInput Format:\nEach test contains multiple test cases. The first line of input contains a single integer $t$ ($1 \\le t \\le 2 \\cdot 10^4$) \u2014 the number of test cases. The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($2 \\le n \\le 4 \\cdot 10^5$) \u2014 the length of the permutation $p$.\n\nThe second line of each test case contains $n$ integers $p_1,p_2,\\ldots, p_n$ ($1 \\le p_i \\le n$) \u2014 the elements of $p$, which are guaranteed to form a permutation.\n\nThe third line of each test case contains a string $s$ of length $n$. It is guaranteed that it consists only of the character ?.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $4 \\cdot 10^5$.\n\nOutput Format:\nFor each test case, output the maximum possible diameter over all connected graphs that you form, or $-1$ if it is not possible to form any connected graphs.\n\nTags:\n['divide and conquer', 'dp', 'trees']\n\nTime Limit: 7000 ms\nMemory Limit: 1024 MB\n",
        "tests": [
            {
                "input": "8\n5\n2 1 4 3 5\n?????\n2\n1 2\n??\n3\n3 1 2\n???\n7\n5 3 1 6 4 2 7\n???????\n5\n5 2 1 3 4\n?????\n6\n6 2 3 4 5 1\n??????\n8\n1 7 5 6 2 8 4 3\n????????\n12\n6 10 7 1 8 5 12 2 11 3 4 9\n????????????",
                "output": "4\n1\n2\n6\n4\n5\n5\n8"
            }
        ]
    },
    {
        "problem": "\nThis is the hard version of the problem. The only difference between the two versions are the allowed characters in $s$. You can make hacks only if both versions of the problem are solved.\n\nYou are given a permutation $p$ of length $n$. You are also given a string $s$ of length $n$, where each character is either L, R, or ?.\n\nFor each $i$ from $1$ to $n$:\n\n  * Define $l_i$ as the largest index $j < i$ such that $p_j > p_i$. If there is no such index, $l_i := i$.    * Define $r_i$ as the smallest index $j > i$ such that $p_j > p_i$. If there is no such index, $r_i := i$. \n\nInitially, you have an undirected graph with $n$ vertices (numbered from $1$ to $n$) and no edges. Then, for each $i$ from $1$ to $n$, add one edge to the graph:\n\n  * If $s_i =$ L, add the edge $(i, l_i)$ to the graph.    * If $s_i =$ R, add the edge $(i, r_i)$ to the graph.    * If $s_i =$ ?, either add the edge $(i, l_i)$ or the edge $(i, r_i)$ to the graph at your choice. \n\nFind the maximum possible diameter over all connected$^{\\text{\u2217}}$ graphs that you can form. Output $-1$ if it is not possible to form any connected graphs.\n\n$^{\\text{\u2217}}$ Let $d(s, t)$ denote the smallest number of edges on any path between $s$ and $t$.\n\nThe diameter of the graph is defined as the maximum value of $d(s, t)$ over all pairs of vertices $s$ and $t$.\n\nInput Format:\nEach test contains multiple test cases. The first line of input contains a single integer $t$ ($1 \\le t \\le 2 \\cdot 10^4$) \u2014 the number of test cases. The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($2 \\le n \\le 4 \\cdot 10^5$) \u2014 the length of the permutation $p$.\n\nThe second line of each test case contains $n$ integers $p_1,p_2,\\ldots, p_n$ ($1 \\le p_i \\le n$) \u2014 the elements of $p$, which are guaranteed to form a permutation.\n\nThe third line of each test case contains a string $s$ of length $n$. It is guaranteed that it consists only of the characters L, R, and ?.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $4 \\cdot 10^5$.\n\nOutput Format:\nFor each test case, output the maximum possible diameter over all connected graphs that you form, or $-1$ if it is not possible to form any connected graphs.\n\nTags:\n['divide and conquer', 'dp', 'trees']\n\nTime Limit: 7000 ms\nMemory Limit: 1024 MB\n",
        "tests": [
            {
                "input": "8\n5\n2 1 4 3 5\nR?RL?\n2\n1 2\nLR\n3\n3 1 2\nL?R\n7\n5 3 1 6 4 2 7\n?R?R?R?\n5\n5 2 1 3 4\n?????\n6\n6 2 3 4 5 1\n?LLRLL\n8\n1 7 5 6 2 8 4 3\n?R??????\n12\n6 10 7 1 8 5 12 2 11 3 4 9\n????????????",
                "output": "3\n-1\n-1\n4\n4\n3\n5\n8"
            }
        ]
    },
    {
        "problem": "\nThis temple only magnifies the mountain's power.\n\nBadeline\n\nThis is an interactive problem.\n\nYou are given two positive integers $n$ and $m$ ($\\bf{n \\le m}$).\n\nThe jury has hidden from you a rectangular matrix $a$ with $n$ rows and $m$ columns, where $a_{i,j} \\in \\\\{ -1, 0, 1 \\\\}$ for all $1 \\le i \\le n$ and $1 \\le j \\le m$. The jury has also selected a cell $(i_0, j_0)$. Your goal is to find $(i_0,j_0)$.\n\nIn one query, you give a cell $(i, j)$, then the jury will reply with an integer.\n\n  * If $(i, j) = (i_0, j_0)$, the jury will reply with $0$.    * Else, let $S$ be the sum of $a_{x,y}$ over all $x$ and $y$ such that $\\min(i, i_0) \\le x \\le \\max(i, i_0)$ and $\\min(j, j_0) \\le y \\le \\max(j, j_0)$. Then, the jury will reply with $|i - i_0| + |j - j_0| + |S|$. \n\nFind $(i_0, j_0)$ by making at most $n + 225$ queries.\n\nNote: the grader is not adaptive: $a$ and $(i_0,j_0)$ are fixed before any queries are made.\n\nInput Format:\nEach test contains multiple test cases. The first line of input contains a single integer $t$ ($1 \\le t \\le 50$) \u2014 the number of test cases. The description of the test cases follows.\n\nThe only line of each test case contains two integers $n$ and $m$ ($1 \\le n \\le m \\le 5000$) \u2014 the numbers of rows and the number of columns of the hidden matrix $a$ respectively.\n\nIt is guaranteed that the sum of $n \\cdot m$ over all test cases does not exceed $25 \\cdot 10^6$.\n\nOutput Format:\n\n\nTags:\n['interactive']\n\nTime Limit: 4000 ms\nMemory Limit: 512 MB\n",
        "tests": [
            {
                "input": "2\n3 4\n\n5\n\n3\n\n5\n\n1 1\n\n0",
                "output": "? 1 1\n\n? 3 3\n\n? 3 2\n\n! 1 4\n\n? 1 1\n\n! 1 1"
            }
        ]
    },
    {
        "problem": "\nA multiset is a set of numbers in which there can be equal elements, and the order of the numbers does not matter. For example, $\\\\{2,2,4\\\\}$ is a multiset.\n\nYou have a multiset $S$. Initially, the multiset contains only one positive integer $n$. That is, $S=\\\\{n\\\\}$. Additionally, there is a given positive integer $k$.\n\nIn one operation, you can select any positive integer $u$ in $S$ and remove one copy of $u$ from $S$. Then, insert no more than $k$ positive integers into $S$ so that the sum of all inserted integers is equal to $u$.\n\nFind the minimum number of operations to make $S$ contain $n$ ones.\n\nInput Format:\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 1000$). Description of the test cases follows.\n\nThe only line of each testcase contains two integers $n,k$ ($1\\le n\\le 1000,2\\le k\\le 1000$).\n\nOutput Format:\nFor each testcase, print one integer, which is the required answer.\n\nTags:\n['brute force', 'greedy', 'implementation', 'math']\n\nTime Limit: 1000 ms\nMemory Limit: 512 MB\n",
        "tests": [
            {
                "input": "4\n1 5\n5 2\n6 3\n16 4",
                "output": "0\n4\n3\n5"
            }
        ]
    },
    {
        "problem": "\nYou are given a sequence $[a_1,\\ldots,a_n]$ where each element $a_i$ is either $0$ or $1$. You can apply several (possibly zero) operations to the sequence. In each operation, you select two integers $1\\le l\\le r\\le |a|$ (where $|a|$ is the current length of $a$) and replace $[a_l,\\ldots,a_r]$ with a single element $x$, where $x$ is the majority of $[a_l,\\ldots,a_r]$.\n\nHere, the majority of a sequence consisting of $0$ and $1$ is defined as follows: suppose there are $c_0$ zeros and $c_1$ ones in the sequence, respectively.\n\n  * If $c_0\\ge c_1$, the majority is $0$.    * If $c_0<c_1$, the majority is $1$. \n\nFor example, suppose $a=[1,0,0,0,1,1]$. If we select $l=1,r=2$, the resulting sequence will be $[0,0,0,1,1]$. If we select $l=4,r=6$, the resulting sequence will be $[1,0,0,1]$.\n\nDetermine if you can make $a=[1]$ with a finite number of operations.\n\nInput Format:\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 4\\cdot 10^4$). Description of the test cases follows.\n\nThe first line of each testcase contains one integer $n$ ($1\\le n\\le 2\\cdot 10^5$).\n\nThe second line of each testcase contains a string consisting of $0$ and $1$, describing the sequence $a$.\n\nIt's guaranteed that the sum of $n$ over all testcases does not exceed $2\\cdot 10^5$.\n\nOutput Format:\nFor each testcase, if it's possible to make $a=[1]$, print YES. Otherwise, print NO. You can output the answer in any case (upper or lower). For example, the strings yEs, yes, Yes, and YES will be recognized as positive responses.\n\nTags:\n['greedy', 'implementation']\n\nTime Limit: 1500 ms\nMemory Limit: 512 MB\n",
        "tests": [
            {
                "input": "5\n1\n0\n1\n1\n2\n01\n9\n100000001\n9\n000011000",
                "output": "No\nYes\nNo\nYes\nNo"
            }
        ]
    },
    {
        "problem": "\nYou are given a positive integer $n$. Find the longest sequence of positive integers $a=[a_1,a_2,\\ldots,a_k]$ that satisfies the following conditions, and print the sequence:\n\n  * $a_i\\le n$ for all $1\\le i\\le k$.    * $a$ is strictly increasing. That is, $a_i>a_{i-1}$ for all $2\\le i\\le k$.    * $a_i\\,|\\,a_{i-1}=n$ for all $2\\le i\\le k$, where $|$ denotes the [bitwise OR operation](https://en.wikipedia.org/wiki/Bitwise_operation#OR).\n\nInput Format:\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 1000$). Description of the test cases follows.\n\nThe only line of each test case contains one integer $n$ ($1\\le n\\le 10^{18}$).\n\nIt's guaranteed that the sum of lengths of the longest valid sequences does not exceed $5\\cdot 10^5$.\n\nOutput Format:\nFor each testcase, print two lines. In the first line, print the length of your constructed sequence, $k$. In the second line, print $k$ positive integers, denoting the sequence. If there are multiple longest sequences, you can print any of them.\n\nTags:\n['bitmasks', 'constructive algorithms', 'greedy']\n\nTime Limit: 2000 ms\nMemory Limit: 512 MB\n",
        "tests": [
            {
                "input": "4\n1\n3\n14\n23",
                "output": "1\n1\n3\n1 2 3\n4\n4 10 12 14\n5\n7 18 21 22 23"
            }
        ]
    },
    {
        "problem": "\nYou, the monster killer, want to kill a group of monsters. The monsters are on a tree with $n$ vertices. On vertex with number $i$ ($1\\le i\\le n$), there is a monster with $a_i$ attack points. You want to battle with monsters for $10^{100}$ rounds.\n\nIn each round, the following happens in order:\n\n  1. All living monsters attack you. Your health decreases by the sum of attack points of all living monsters.    2. You select some (possibly all or none) monsters and kill them. After being killed, the monster will not be able to do any attacks in the future. \n\nThere is a restriction: in one round, you cannot kill two monsters that are directly connected by an edge.\n\nIf you choose what monsters to attack optimally, what is the smallest health decrement you can have after all rounds?\n\nInput Format:\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). Description of the test cases follows.\n\nThe first line of each test case contains an integer $n$ ($1\\le n\\le 3\\cdot 10^5$).\n\nThe second line of each test case contains $n$ integers $a_1,\\ldots,a_n$ ($1\\le a_i\\le 10^{12}$).\n\nThe following $n-1$ lines each contain two integers $x,y$ ($1\\le x,y\\le n$), denoting an edge on the tree connecting vertex $x$ and $y$.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $3\\cdot 10^5$.\n\nOutput Format:\nFor each test case, print one integer: the minimum possible health decrement.\n\nTags:\n['brute force', 'dfs and similar', 'dp', 'trees']\n\nTime Limit: 3000 ms\nMemory Limit: 512 MB\n",
        "tests": [
            {
                "input": "3\n1\n1000000000000\n5\n47 15 32 29 23\n1 2\n1 3\n2 4\n2 5\n7\n8 10 2 3 5 7 4\n1 2\n1 4\n3 2\n5 3\n6 2\n7 5",
                "output": "1000000000000\n193\n57"
            }
        ]
    },
    {
        "problem": "\nFor an array $[a_1,a_2,\\ldots,a_n]$ of length $n$, define $f(a)$ as the sum of the minimum element over all subsegments. That is, $$f(a)=\\sum_{l=1}^n\\sum_{r=l}^n \\min_{l\\le i\\le r}a_i.$$\n\nA permutation is a sequence of integers from $1$ to $n$ of length $n$ containing each number exactly once. You are given a permutation $[a_1,a_2,\\ldots,a_n]$. For each $i$, solve the following problem independently:\n\n  * Erase $a_i$ from $a$, concatenating the remaining parts, resulting in $b = [a_1,a_2,\\ldots,a_{i-1},\\;a_{i+1},\\ldots,a_{n}]$.    * Calculate $f(b)$.\n\nInput Format:\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^5$). Description of the test cases follows.\n\nThe first line of each test case contains an integer $n$ ($1\\le n\\le 5\\cdot 10^5$).\n\nThe second line of each test case contains $n$ distinct integers $a_1,\\ldots,a_n$ ($1\\le a_i\\le n$).\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $10^6$.\n\nOutput Format:\nFor each test case, print one line containing $n$ integers. The $i$-th integer should be the answer when erasing $a_i$.\n\nTags:\n['binary search', 'brute force', 'data structures', 'divide and conquer', 'implementation']\n\nTime Limit: 4000 ms\nMemory Limit: 512 MB\n",
        "tests": [
            {
                "input": "4\n1\n1\n3\n3 1 2\n5\n4 2 1 5 3\n8\n8 1 4 6 7 3 5 2",
                "output": "0 \n4 7 5 \n19 21 27 17 19 \n79 100 72 68 67 80 73 80"
            }
        ]
    },
    {
        "problem": "\nFor an array $u_1, u_2, \\ldots, u_n$, define\n\n  * a prefix maximum as an index $i$ such that $u_i>u_j$ for all $j<i$;    * a suffix maximum as an index $i$ such that $u_i>u_j$ for all $j>i$;    * an ascent as an index $i$ ($i>1$) such that $u_i>u_{i-1}$. \n\nYou are given three cost arrays: $[a_1, a_2, \\ldots, a_n]$, $[b_1, b_2, \\ldots, b_n]$, and $[c_0, c_1, \\ldots, c_{n-1}]$.\n\nDefine the cost of an array that has $x$ prefix maximums, $y$ suffix maximums, and $z$ ascents as $a_x\\cdot b_y\\cdot c_z$.\n\nLet the sum of costs of all permutations of $1,2,\\ldots,n$ be $f(n)$. Find $f(1)$, $f(2)$, ..., $f(n)$ modulo $998\\,244\\,353$.\n\nInput Format:\nThe first line contains an integer $n$ ($1\\le n\\le 700$).\n\nThe second line contains $n$ integers $a_1,\\ldots,a_n$ ($0\\le a_i<998\\,244\\,353$).\n\nThe third line contains $n$ integers $b_1,\\ldots,b_n$ ($0\\le b_i<998\\,244\\,353$).\n\nThe fourth line contains $n$ integers $c_0,\\ldots,c_{n-1}$ ($0\\le c_i<998\\,244\\,353$).\n\nOutput Format:\nPrint $n$ integers: the $i$-th one is $f(i)$ modulo $998\\,244\\,353$.\n\nTags:\n['combinatorics', 'dp', 'fft', 'math']\n\nTime Limit: 5000 ms\nMemory Limit: 512 MB\n",
        "tests": [
            {
                "input": "3\n1 1 1\n1 1 1\n1 1 1",
                "output": "1 2 6"
            },
            {
                "input": "3\n1 2 3\n2 3 1\n3 1 2",
                "output": "6 13 34"
            },
            {
                "input": "5\n1 4 2 5 3\n2 5 1 3 4\n300000000 100000000 500000000 400000000 200000000",
                "output": "600000000 303511294 612289529 324650937 947905622"
            }
        ]
    },
    {
        "problem": "\nMonocarp visited a retro arcade club with arcade cabinets. There got curious about the \"Catch the Coin\" cabinet.\n\nThe game is pretty simple. The screen represents a coordinate grid such that:\n\n  * the X-axis is directed from left to right;    * the Y-axis is directed from bottom to top;    * the center of the screen has coordinates $(0, 0)$. \n\nAt the beginning of the game, the character is located in the center, and $n$ coins appear on the screen \u2014 the $i$-th coin is at coordinates $(x_i, y_i)$. The coordinates of all coins are different and not equal to $(0, 0)$.\n\nIn one second, Monocarp can move the character in one of eight directions. If the character is at coordinates $(x, y)$, then it can end up at any of the coordinates $(x, y + 1)$, $(x + 1, y + 1)$, $(x + 1, y)$, $(x + 1, y - 1)$, $(x, y - 1)$, $(x - 1, y - 1)$, $(x - 1, y)$, $(x - 1, y + 1)$.\n\nIf the character ends up at the coordinates with a coin, then Monocarp collects that coin.\n\nAfter Monocarp makes a move, all coins fall down by $1$, that is, they move from $(x, y)$ to $(x, y - 1)$. You can assume that the game field is infinite in all directions.\n\nMonocarp wants to collect at least one coin, but cannot decide which coin to go for. Help him determine, for each coin, whether he can collect it.\n\nInput Format:\nThe first line contains a single integer $n$ ($1 \\le n \\le 500$) \u2014 the number of coins.\n\nIn the $i$-th of the next $n$ lines, two integers $x_i$ and $y_i$ ($-50 \\le x_i, y_i \\le 50$) are written \u2014 the coordinates of the $i$-th coin. The coordinates of all coins are different. No coin is located at $(0, 0)$.\n\nOutput Format:\nFor each coin, print \"YES\" if Monocarp can collect it. Otherwise, print \"NO\".\n\nTags:\n['implementation']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "5\n24 42\n-2 -1\n-1 -2\n0 -50\n15 0",
                "output": "YES\nYES\nNO\nNO\nYES"
            }
        ]
    },
    {
        "problem": "\nYou are given two strings $a$ and $b$, both consisting of lowercase Latin letters.\n\nA subsequence of a string is a string which can be obtained by removing several (possibly zero) characters from the original string. A substring of a string is a contiguous subsequence of that string.\n\nFor example, consider the string abac:\n\n  * a, b, c, ab, aa, ac, ba, bc, aba, abc, aac, bac and abac are its subsequences;    * a, b, c, ab, ba, ac, aba, bac and abac are its substrings. \n\nYour task is to calculate the minimum possible length of the string that contains $a$ as a substring and $b$ as a subsequence.\n\nInput Format:\nThe first line contains a single integer $t$ ($1 \\le t \\le 10^3$) \u2014 the number of test cases.\n\nThe first line of each test case contains a string $a$ ($1 \\le |a| \\le 100$), consisting of lowercase Latin letters.\n\nThe second line of each test case contains a string $b$ ($1 \\le |b| \\le 100$), consisting of lowercase Latin letters.\n\nOutput Format:\nFor each test case, print a single integer \u2014 the minimum possible length of the string that contains $a$ as a substring and $b$ as a subsequence.\n\nTags:\n['brute force', 'greedy', 'strings']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "5\naba\ncb\ner\ncf\nmmm\nmmm\ncontest\ntest\ncde\nabcefg",
                "output": "4\n4\n3\n7\n7"
            }
        ]
    },
    {
        "problem": "\nA movie company has released $2$ movies. These $2$ movies were watched by $n$ people. For each person, we know their attitude towards the first movie (liked it, neutral, or disliked it) and towards the second movie.\n\nIf a person is asked to leave a review for the movie, then:\n\n  * if that person liked the movie, they will leave a positive review, and the movie's rating will increase by $1$;    * if that person disliked the movie, they will leave a negative review, and the movie's rating will decrease by $1$;    * otherwise, they will leave a neutral review, and the movie's rating will not change. \n\nEvery person will review exactly one movie \u2014 and for every person, you can choose which movie they will review.\n\nThe company's rating is the minimum of the ratings of the two movies. Your task is to calculate the maximum possible rating of the company.\n\nInput Format:\nThe first line contains a single integer $t$ ($1 \\le t \\le 10^4$) \u2014 the number of test cases.\n\nThe first line of each test case contains a single integer $n$ ($1 \\le n \\le 2 \\cdot 10^5$).\n\nThe second line contains $n$ integers $a_1, a_2, \\dots, a_n$ ($-1 \\le a_i \\le 1$), where $a_i$ is equal to $-1$ if the first movie was disliked by the $i$-th viewer; equal to $1$ if the first movie was liked; and $0$ if the attitude is neutral.\n\nThe third line contains $n$ integers $b_1, b_2, \\dots, b_n$ ($-1 \\le b_i \\le 1$), where $b_i$ is equal to $-1$ if the second movie was disliked by the $i$-th viewer; equal to $1$ if the second movie was liked; and $0$ if the attitude is neutral.\n\nAdditional constraint on the input: the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\nOutput Format:\nFor each test case, print a single integer \u2014 the maximum possible rating of the company, if for each person, choose which movie to leave a review on.\n\nTags:\n['greedy', 'math']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "4\n2\n-1 1\n-1 -1\n1\n-1\n-1\n5\n0 -1 1 0 1\n-1 1 0 0 1\n4\n-1 -1 -1 1\n-1 1 1 1",
                "output": "0\n-1\n1\n1"
            }
        ]
    },
    {
        "problem": "\nYou are playing a famous computer game (that just works) where you have various skills you can level up. Today, you focused on the \"Smithing\" skill. Your tactic is obvious: forging weapons from ingots and then melting them back to return the materials partially. For simplicity, every time you create an item, you get $1$ experience point, and every time you melt an item, you also get $1$ experience point.\n\nThere are $n$ classes of weapons you can forge and $m$ types of metal ingots.\n\nYou can create one weapon of the $i$-th class, spending $a_i$ ingots of metal of the same type. Melting a weapon of the $i$-th class (which you crafted earlier) returns you $b_i$ ingots of the type of metal it was made of.\n\nYou have $c_j$ metal ingots of the $j$-th type, and you know that you can craft a weapon of any class from any metal type. Each combination of a weapon class and a metal type can be used any number of times.\n\nWhat is the maximum total amount of experience you can earn by crafting and melting weapons?\n\nInput Format:\nThe first line contains two integers $n$ and $m$ ($1 \\le n, m \\le 10^6$) \u2014 the number of weapon classes and metal types.\n\nThe second line contains $n$ integers $a_1, a_2, \\dots, a_n$ ($1 \\le a_i \\le 10^6$), where $a_i$ is the number of ingots you need to forge one weapon of the $i$-th class.\n\nThe third line contains $n$ integers $b_1, b_2, \\dots, b_n$ ($0 \\le b_i < a_i$), where $b_i$ is the number of ingots you return by melting one weapon of the $i$-th class you forged earlier.\n\nThe fourth line contains $m$ integers $c_1, c_2, \\dots, c_m$ ($1 \\le c_j \\le 10^9$) \u2014 the number of ingots you have of the corresponding metal type.\n\nOutput Format:\nPrint one integer \u2014 the maximum total experience points you can gain by repeatedly forging and melting weapons.\n\nTags:\n['brute force', 'data structures', 'dp', 'greedy', 'math', 'sortings', 'two pointers']\n\nTime Limit: 3000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "5 3\n9 6 7 5 5\n8 4 5 1 2\n10 4 7",
                "output": "12"
            },
            {
                "input": "3 4\n10 20 20\n0 0 0\n9 10 19 20",
                "output": "8"
            },
            {
                "input": "1 5\n3\n1\n1000000000 1000000000 1000000000 1000000000 1000000000",
                "output": "4999999990"
            }
        ]
    },
    {
        "problem": "\nConsider an array $a$ of $n$ integers, where every element is from $1$ to $k$, and every integer from $1$ to $k$ appears at least once.\n\nLet the array $b$ be constructed as follows: for the $i$-th element of $a$, $b_i$ is the distance to the closest element in $a$ which is not equal to $a_i$. In other words, $b_i = \\min \\limits_{j \\in [1, n], a_j \\ne a_i} |i - j|$.\n\nFor example, if $a = [1, 1, 2, 3, 3, 3, 3, 1]$, then $b = [2, 1, 1, 1, 2, 2, 1, 1]$.\n\nCalculate the number of different arrays $b$ you can obtain if you consider all possible arrays $a$, and print it modulo $998244353$.\n\nInput Format:\nThe only line of the input contains two integers $n$ and $k$ ($2 \\le n \\le 2 \\cdot 10^5$; $2 \\le k \\le \\min(n, 10)$).\n\nOutput Format:\nPrint one integer \u2014 the number of different arrays $b$ you can obtain, taken modulo $998244353$.\n\nTags:\n['combinatorics', 'dp', 'math']\n\nTime Limit: 2000 ms\nMemory Limit: 512 MB\n",
        "tests": [
            {
                "input": "2 2",
                "output": "1"
            },
            {
                "input": "4 3",
                "output": "3"
            },
            {
                "input": "6 2",
                "output": "20"
            },
            {
                "input": "6 5",
                "output": "3"
            },
            {
                "input": "133 7",
                "output": "336975971"
            }
        ]
    },
    {
        "problem": "\nYou are given a matrix, consisting of $n$ rows and $m$ columns.\n\nYou can perform two types of actions on it:\n\n  * paint the entire column in blue;    * paint the entire row in red. \n\nNote that you cannot choose which color to paint the row or column.\n\nIn one second, you can perform either one action or multiple actions at the same time. If you perform one action, it will be free. If you perform $k > 1$ actions at the same time, it will cost $k^2$ coins. When multiple actions are performed at the same time, for each cell affected by actions of both types, the color can be chosen independently.\n\nYou are asked to process $q$ queries. Before each query, all cells become colorless. Initially, there are no restrictions on the color of any cells. In the $i$-th query, a restriction of the following form is added:\n\n  * $x_i~y_i~c_i$ \u2014 the cell in row $x_i$ in column $y_i$ should be painted in color $c_i$. \n\nThus, after $i$ queries, there are $i$ restrictions on the required colors of the matrix cells. After each query, output the minimum cost of painting the matrix according to the restrictions.\n\nInput Format:\nThe first line contains three integers $n, m$ and $q$ ($1 \\le n, m, q \\le 2 \\cdot 10^5$) \u2014 the size of the matrix and the number of queries.\n\nIn the $i$-th of the next $q$ lines, two integers $x_i, y_i$ and a character $c_i$ ($1 \\le x_i \\le n$; $1 \\le y_i \\le m$; $c_i \\in$ {'R', 'B'}, where 'R' means red, and 'B' means blue) \u2014 description of the $i$-th restriction. The cells in all queries are pairwise distinct.\n\nOutput Format:\nPrint $q$ integers \u2014 after each query, output the minimum cost of painting the matrix according to the restrictions.\n\nTags:\n['dfs and similar', 'divide and conquer', 'graphs']\n\nTime Limit: 6000 ms\nMemory Limit: 512 MB\n",
        "tests": [
            {
                "input": "2 2 4\n1 1 R\n2 2 R\n1 2 B\n2 1 B",
                "output": "0\n0\n0\n16"
            },
            {
                "input": "3 5 10\n1 1 B\n2 5 B\n2 2 B\n2 3 R\n2 1 B\n3 2 R\n3 3 B\n1 2 R\n1 3 B\n3 1 B",
                "output": "0\n0\n0\n0\n0\n0\n16\n16\n25\n25"
            }
        ]
    },
    {
        "problem": "\nAlice and Bob are playing a game in an array $a$ of size $n$.\n\nThey take turns to do operations, with Alice starting first. The player who can not operate will lose. At first, a variable $mx$ is set to $0$.\n\nIn one operation, a player can do:\n\n  * Choose an index $i$ ($1 \\le i \\le n$) such that $a_{i} \\geq mx$ and set $mx$ to $a_{i}$. Then, set $a_{i}$ to $0$.\n\nDetermine whether Alice has a winning strategy.\n\nInput Format:\nThe first line contains an integer $t$ ($1 \\leq t \\leq 10^3$) \u2014 the number of test cases.\n\nFor each test case:\n\n  * The first line contains an integer $n$ ($2 \\leq n \\leq 50$) \u2014 the size of the array.    * The second line contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\leq a_i \\leq n$) \u2014 the elements of the array.\n\nOutput Format:\nFor each test case, if Alice has a winning strategy, output \"YES\". Otherwise, output \"NO\".\n\nYou can output the answer in any case (upper or lower). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as positive responses.\n\nTags:\n['brute force', 'games', 'greedy', 'sortings']\n\nTime Limit: 1000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "5\n2\n2 1\n2\n1 1\n3\n3 3 3\n4\n3 3 4 4\n4\n1 2 2 2",
                "output": "YES\nNO\nYES\nNO\nYES"
            }
        ]
    },
    {
        "problem": "\nFor an array $b$ of size $m$, we define:\n\n  * the maximum prefix position of $b$ is the smallest index $i$ that satisfies $b_1+\\ldots+b_i=\\max_{j=1}^{m}(b_1+\\ldots+b_j)$;   * the maximum suffix position of $b$ is the largest index $i$ that satisfies $b_i+\\ldots+b_m=\\max_{j=1}^{m}(b_j+\\ldots+b_m)$.\n\nYou are given three integers $n$, $x$, and $y$ ($x > y$). Construct an array $a$ of size $n$ satisfying:\n\n  * $a_i$ is either $1$ or $-1$ for all $1 \\le i \\le n$;   * the maximum prefix position of $a$ is $x$;   * the maximum suffix position of $a$ is $y$.\n\nIf there are multiple arrays that meet the conditions, print any. It can be proven that such an array always exists under the given conditions.\n\nInput Format:\nThe first line contains an integer $t$ ($1 \\leq t \\leq 10^4$) \u2014 the number of test cases.\n\nFor each test case:\n\n  * The only line contains three integers $n$, $x$, and $y$ ($2 \\leq n \\leq 10^5, 1 \\le y \\lt x \\le n)$. \n\nIt is guaranteed that the sum of $n$ over all test cases will not exceed $10^5$.\n\nOutput Format:\nFor each test case, output $n$ space-separated integers $a_1, a_2, \\ldots, a_n$ in a new line.\n\nTags:\n['constructive algorithms', 'greedy']\n\nTime Limit: 1000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "3\n2 2 1\n4 4 3\n6 5 1",
                "output": "1 1\n1 -1 1 1\n1 1 -1 1 1 -1"
            }
        ]
    },
    {
        "problem": "\nWe define the $\\operatorname{MAD}$ (Maximum Appearing Duplicate) in an array as the largest number that appears at least twice in the array. Specifically, if there is no number that appears at least twice, the $\\operatorname{MAD}$ value is $0$.\n\nFor example, $\\operatorname{MAD}([1, 2, 1]) = 1$, $\\operatorname{MAD}([2, 2, 3, 3]) = 3$, $\\operatorname{MAD}([1, 2, 3, 4]) = 0$.\n\nYou are given an array $a$ of size $n$. Initially, a variable $sum$ is set to $0$.\n\nThe following process will be executed in a sequential loop until all numbers in $a$ become $0$:\n\n  1. Set $sum := sum + \\sum_{i=1}^{n} a_i$;    2. Let $b$ be an array of size $n$. Set $b_i :=\\ \\operatorname{MAD}([a_1, a_2, \\ldots, a_i])$ for all $1 \\le i \\le n$, and then set $a_i := b_i$ for all $1 \\le i \\le n$. \n\nFind the value of $sum$ after the process.\n\nInput Format:\nThe first line contains an integer $t$ ($1 \\leq t \\leq 2 \\cdot 10^4$) \u2014 the number of test cases.\n\nFor each test case:\n\n  * The first line contains an integer $n$ ($1 \\leq n \\leq 2 \\cdot 10^5$) \u2014 the size of the array $a$;    * The second line contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\leq a_i \\leq n$) \u2014 the elements of the array. \n\nIt is guaranteed that the sum of $n$ over all test cases will not exceed $2 \\cdot 10^5$.\n\nOutput Format:\nFor each test case, output the value of $sum$ in a new line.\n\nTags:\n['brute force', 'greedy', 'math']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "4\n1\n1\n3\n2 2 3\n4\n2 1 1 2\n4\n4 4 4 4",
                "output": "1\n13\n9\n40"
            }
        ]
    },
    {
        "problem": "\nYou are given an array $a$ of size $n$.\n\nThere is an $n \\times n$ grid. In the $i$-th row, the first $a_i$ cells are black and the other cells are white. In other words, note $(i,j)$ as the cell in the $i$-th row and $j$-th column, cells $(i,1), (i,2), \\ldots, (i,a_i)$ are black, and cells $(i,a_i+1), \\ldots, (i,n)$ are white.\n\nYou can do the following operations any number of times in any order:\n\n  * Dye a $2 \\times 2$ subgrid white;    * Dye a whole row white. Note you can not dye a whole column white. \n\nFind the minimum number of operations to dye all cells white.\n\nInput Format:\nThe first line contains an integer $t$ ($1 \\leq t \\leq 10^4$) \u2014 the number of test cases.\n\nFor each test case:\n\n  * The first line contains an integer $n$ ($1 \\leq n \\leq 2 \\cdot 10^5$) \u2014 the size of the array $a$.    * The second line contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($0 \\leq a_i \\leq n$). \n\nIt's guaranteed that the sum of $n$ over all test cases will not exceed $2 \\cdot 10^5$.\n\nOutput Format:\nFor each test case, output a single integer \u2014 the minimum number of operations to dye all cells white.\n\nTags:\n['bitmasks', 'brute force', 'dp', 'greedy', 'implementation']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "10\n1\n0\n4\n2 4 4 2\n4\n3 2 1 0\n3\n0 3 0\n3\n0 1 3\n3\n3 1 0\n4\n3 1 0 3\n4\n0 2 2 2\n6\n1 3 4 2 0 4\n8\n2 2 5 2 3 4 2 4",
                "output": "0\n3\n2\n1\n2\n2\n3\n2\n4\n6"
            }
        ]
    },
    {
        "problem": "\nThis is the easy version of the problem. The only difference is the limit on the number of queries.\n\nThis is an interactive problem.\n\nYou are given a tree of $n$ nodes with node $1$ as its root node.\n\nThere is a hidden mole in one of the nodes. To find its position, you can pick an integer $x$ ($1 \\le x \\le n$) to make an inquiry to the jury. Next, the jury will return $1$ when the mole is in subtree $x$. Otherwise, the judge will return $0$. If the judge returns $0$ and the mole is not in root node $1$, the mole will move to the parent node of the node it is currently on.\n\nUse at most $300$ operations to find the current node where the mole is located.\n\nInput Format:\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 100$). The description of the test cases follows.\n\nOutput Format:\n\n\nTags:\n['binary search', 'data structures', 'dfs and similar', 'interactive', 'trees']\n\nTime Limit: 4000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "2\n2\n1 2\n\n1\n\n6\n1 2\n1 3\n1 4\n4 5\n5 6\n\n0\n\n0\n\n1",
                "output": "? 2\n\n! 2\n\n\n\n\n\n\n? 2\n\n? 6\n\n? 4\n\n! 4"
            }
        ]
    },
    {
        "problem": "\nThis is the hard version of the problem. The only difference is the limit on the number of queries.\n\nThis is an interactive problem.\n\nYou are given a tree of $n$ nodes with node $1$ as its root node.\n\nThere is a hidden mole in one of the nodes. To find its position, you can pick an integer $x$ ($1 \\le x \\le n$) to make an inquiry to the jury. Next, the jury will return $1$ when the mole is in subtree $x$. Otherwise, the judge will return $0$. If the judge returns $0$ and the mole is not in root node $1$, the mole will move to the parent node of the node it is currently on.\n\nUse at most $160$ operations to find the current node where the mole is located.\n\nInput Format:\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 100$). The description of the test cases follows.\n\nOutput Format:\n\n\nTags:\n['binary search', 'data structures', 'dfs and similar', 'divide and conquer', 'interactive', 'trees']\n\nTime Limit: 4000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "2\n2\n1 2\n\n1\n\n6\n1 2\n1 3\n1 4\n4 5\n5 6\n\n0\n\n0\n\n1",
                "output": "? 2\n\n! 2\n\n\n\n\n\n\n? 2\n\n? 6\n\n? 4\n\n! 4"
            }
        ]
    },
    {
        "problem": "\nYou are given an array $a$ of size $n$.\n\nA segment $[l, r](1 \\le l < r \\le n)$ is called a polygonal segment only if the following conditions hold:\n\n  * $(r-l+1) \\geq 3$;    * Considering $a_l, a_{l+1}, \\ldots, a_r$ as side lengths, these sides can form a polygon with $(r-l+1)$ sides. \n\nProcess $q$ queries of two types:\n\n  * \"1 l r\": find the length of the longest segment among all polygonal segments $[l_0,r_0]$ satisfying $l \\le l_0 \\le r_0 \\le r$. If there is no such polygonal segment, output $-1$ instead;    * \"2 i x\": assign $a_i := x$.\n\nInput Format:\nThe first line contains an integer $t$ ($1 \\leq t \\leq 10^4$) \u2014 the number of test cases.\n\nFor each test case:\n\n  * The first line of each testcase contains two integers $n$, $q$ ($4 \\le n \\le 2\\cdot 10^5$, $1 \\le q \\le 10^5$);    * The second line of each testcase contains $n$ integers $a_1,a_2,\\ldots, a_n$ ($1 \\le a_i \\le 10^{12}$);    * The following $q$ lines contain the description of queries. Each line is of one of two types:     * \"1 l r\" ($1 \\le l < r \\le n$, $r-l+1\\ge 3$);      * \"2 i x\" ($1 \\le i \\le n$, $1 \\le x \\le 10^{12}$). \n\nIt is guaranteed that the sum of $n$ over all test cases will not exceed $2 \\cdot 10^5$, and the sum of $q$ over all test cases will not exceed $10^5$.\n\nOutput Format:\nFor each query, if there is no suitable segment, output $-1$ in a new line. Otherwise, output the length of the longest segment satisfying the condition above in a new line.\n\nTags:\n['brute force', 'data structures', 'divide and conquer', 'dp', 'greedy', 'two pointers']\n\nTime Limit: 8000 ms\nMemory Limit: 512 MB\n",
        "tests": [
            {
                "input": "2\n5 6\n3 1 2 2 8\n1 1 3\n1 1 4\n1 1 5\n2 1 5\n1 1 4\n1 1 5\n4 10\n500000000000 500000000000 1000000000000 500000000000\n1 1 3\n1 2 4\n1 1 4\n2 1 499999999999\n2 3 999999999999\n1 1 3\n1 2 4\n1 1 4\n2 3 1000000000000\n1 1 3",
                "output": "-1\n4\n4\n3\n5\n-1\n-1\n4\n-1\n3\n4\n-1"
            }
        ]
    },
    {
        "problem": "\nYou are given an array $a$ of $n$ integers, where $n$ is odd.\n\nIn one operation, you will remove two adjacent elements from the array $a$, and then concatenate the remaining parts of the array. For example, given the array $[4,7,4,2,9]$, we can obtain the arrays $[4,2,9]$ and $[4,7,9]$ by the operations $[\\underline{4,7}, 4,2,9] \\to [4,2,9]$ and $[4,7,\\underline{4,2},9] \\to [4,7,9]$ respectively. However, we cannot obtain the array $[7,2,9]$ as it requires deleting non-adjacent elements $[\\underline{4},7,\\underline{4},2,9]$.\n\nYou will repeatedly perform this operation until exactly one element remains in $a$.\n\nFind the maximum possible value of the remaining element in $a$.\n\nInput Format:\nEach test contains multiple test cases. The first line contains a single integer $t$ ($1 \\le t \\le 1000$) \u2014 the number of test cases. The description of test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($1 \\le n \\le 99$; $n$ is odd) \u2014 the length of the array $a$.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\le a_i \\le 100$) \u2014 the elements of the array $a$.\n\nNote that there is no bound on the sum of $n$ over all test cases.\n\nOutput Format:\nFor each test case, output a single integer \u2014 the maximum possible value of the remaining element in $a$.\n\nTags:\n['greedy', 'implementation']\n\nTime Limit: 1000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "4\n1\n6\n3\n1 3 2\n5\n4 7 4 2 9\n7\n3 1 4 1 5 9 2",
                "output": "6\n2\n9\n5"
            }
        ]
    },
    {
        "problem": "\nYou are given an array $b$ of $n - 1$ integers.\n\nAn array $a$ of $n$ integers is called good if $b_i = a_i \\, \\& \\, a_{i + 1}$ for $1 \\le i \\le n-1$, where $\\&$ denotes the [bitwise AND operator](https://en.wikipedia.org/wiki/Bitwise_operation#AND).\n\nConstruct a good array, or report that no good arrays exist.\n\nInput Format:\nEach test contains multiple test cases. The first line contains a single integer $t$ ($1 \\le t \\le 10^4$) \u2014 the number of test cases. The description of test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($2 \\le n \\le 10^5$) \u2014 the length of the array $a$.\n\nThe second line of each test case contains $n - 1$ integers $b_1, b_2, \\ldots, b_{n - 1}$ ($0 \\le b_i < 2^{30}$) \u2014 the elements of the array $b$.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $10^5$.\n\nOutput Format:\nFor each test case, output a single integer $-1$ if no good arrays exist.\n\nOtherwise, output $n$ space-separated integers $a_1, a_2, \\ldots, a_n$ ($0 \\le a_i < 2^{30}$) \u2014 the elements of a good array $a$.\n\nIf there are multiple solutions, you may output any of them.\n\nTags:\n['bitmasks', 'constructive algorithms', 'greedy']\n\nTime Limit: 1000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "4\n2\n1\n3\n2 0\n4\n1 2 3\n5\n3 5 4 2",
                "output": "5 3\n3 2 1\n-1\n3 7 5 6 3"
            }
        ]
    },
    {
        "problem": "\nYou are given an array $a$ of $n$ integers.\n\nIn one operation, you will perform the following two-step move:\n\n  1. Choose an integer $x$ ($0 \\le x \\le 10^{9}$).    2. Replace each $a_i$ with $|a_i - x|$, where $|v|$ denotes the [absolute value](https://en.wikipedia.org/wiki/Absolute_value) of $v$. \n\nFor example, by choosing $x = 8$, the array $[5, 7, 10]$ will be changed into $[|5-8|, |7-8|, |10-8|] = [3,1,2]$.\n\nConstruct a sequence of operations to make all elements of $a$ equal to $0$ in at most $40$ operations or determine that it is impossible. You do not need to minimize the number of operations.\n\nInput Format:\nEach test contains multiple test cases. The first line contains a single integer $t$ ($1 \\le t \\le 10^4$) \u2014 the number of test cases. The description of test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($1 \\le n \\le 2 \\cdot 10^5$) \u2014 the length of the array $a$.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($0 \\le a_i \\le 10^9$) \u2014 the elements of the array $a$.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\nOutput Format:\nFor each test case, output a single integer $-1$ if it is impossible to make all array elements equal to $0$ in at most $40$ operations.\n\nOtherwise, output two lines. The first line of output should contain a single integer $k$ ($0 \\le k \\le 40$) \u2014 the number of operations. The second line of output should contain $k$ integers $x_1, x_2, \\ldots, x_k$ ($0 \\le x_i \\le 10^{9}$) \u2014 the sequence of operations, denoting that on the $i$-th operation, you chose $x=x_i$.\n\nIf there are multiple solutions, output any of them.\n\nYou do not need to minimize the number of operations.\n\nTags:\n['constructive algorithms', 'greedy', 'math']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "5\n1\n5\n2\n0 0\n3\n4 6 8\n4\n80 40 20 10\n5\n1 2 3 4 5",
                "output": "1\n5\n0\n\n3\n6 1 1\n7\n60 40 20 10 30 25 5\n-1"
            }
        ]
    },
    {
        "problem": "\nYou are given an undirected graph with $n$ vertices, numbered from $1$ to $n$. There is an edge between vertices $u$ and $v$ if and only if $u \\oplus v$ is a [prime number](https://en.wikipedia.org/wiki/Prime_number), where $\\oplus$ denotes the [bitwise XOR operator](https://en.wikipedia.org/wiki/Bitwise_operation#XOR).\n\nColor all vertices of the graph using the minimum number of colors, such that no two vertices directly connected by an edge have the same color.\n\nInput Format:\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 500$). The description of test cases follows.\n\nThe only line contains a single integer $n$ ($1 \\le n \\le 2 \\cdot 10^5$) \u2014 the number of vertices in the graph.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\nOutput Format:\nFor each test case, output two lines.\n\nThe first line should contain a single integer $k$ ($1 \\le k \\le n$) \u2014 the minimum number of colors required.\n\nThe second line should contain $n$ integers $c_1, c_2, \\ldots, c_n$ ($1 \\le c_i \\le k$) \u2014 the color of each vertex.\n\nIf there are multiple solutions, output any of them.\n\nTags:\n['bitmasks', 'constructive algorithms', 'graphs', 'greedy', 'math', 'number theory']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "6\n1\n2\n3\n4\n5\n6",
                "output": "1\n1\n2\n1 2\n2\n1 2 2\n3\n1 2 2 3\n3\n1 2 2 3 3\n4\n1 2 2 3 3 4"
            }
        ]
    },
    {
        "problem": "\nThis is an interactive problem.\n\nConsider an undirected connected graph consisting of $n$ vertices and $m$ edges. Each vertex can be colored with one of three colors: $1$, $2$, or $3$. Initially, all vertices are uncolored.\n\nAlice and Bob are playing a game consisting of $n$ rounds. In each round, the following two-step process happens:\n\n  1. Alice chooses two different colors.    2. Bob chooses an uncolored vertex and colors it with one of the two colors chosen by Alice. \n\nAlice wins if there exists an edge connecting two vertices of the same color. Otherwise, Bob wins.\n\nYou are given the graph. Your task is to decide which player you wish to play as and win the game.\n\nInput Format:\nEach test contains multiple test cases. The first line contains a single integer $t$ ($1 \\le t \\le 1000$) \u2014 the number of test cases. The description of test cases follows.\n\nThe first line of each test case contains two integers $n$, $m$ ($1 \\le n \\le 10^4$, $n - 1 \\le m \\le \\min(\\frac{n \\cdot (n - 1)}{2}, 10^4)$) \u2014 the number of vertices and the number of edges in the graph, respectively.\n\nEach of the next $m$ lines of each test case contains two integers $u_i$, $v_i$ ($1 \\le u_i, v_i \\le n$) \u2014 the edges of the graph. It is guaranteed that the graph is connected and there are no multiple edges or self-loops.\n\nIt is guaranteed that the sum of $n$ and the sum of $m$ over all test cases does not exceed $10^4$.\n\nOutput Format:\n\n\nTags:\n['constructive algorithms', 'dfs and similar', 'games', 'graphs', 'greedy', 'interactive']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "2\n3 3\n1 2\n2 3\n3 1\n\n\n3 1\n\n2 2\n\n1 1\n4 4\n1 2\n2 3\n3 4\n4 1\n\n2 3\n\n1 2\n\n2 1\n\n3 1",
                "output": "Alice\n3 1\n\n1 2\n\n2 1\n\n\n\n\n\n\nBob\n\n1 2\n\n2 1\n\n4 1\n\n3 3"
            }
        ]
    },
    {
        "problem": "\nYou are given $n$ sticks, numbered from $1$ to $n$. The length of the $i$-th stick is $a_i$.\n\nYou need to answer $q$ queries. In each query, you are given two integers $l$ and $r$ ($1 \\le l < r \\le n$, $r - l + 1 \\ge 6$). Determine whether it is possible to choose $6$ distinct sticks from the sticks numbered $l$ to $r$, to form $2$ non-degenerate triangles$^{\\text{\u2217}}$.\n\n$^{\\text{\u2217}}$A triangle with side lengths $a$, $b$, and $c$ is called non-degenerate if:\n\n  * $a < b + c$,    * $b < a + c$, and    * $c < a + b$.\n\nInput Format:\nThe first line contains two integers $n$ and $q$ ($6 \\le n \\le 10^5$, $1 \\le q \\le 10^5$) \u2014 the number of sticks and the number of queries respectively.\n\nThe second line contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\le a_i \\le 10^9$) \u2014 $a_i$ denotes the length of the $i$-th stick.\n\nEach of the following $q$ lines contains two integers $l$ and $r$ ($1 \\le l < r \\le n$, $r - l + 1 \\ge 6$) \u2014 the parameters of each query.\n\nOutput Format:\nFor each query, output \"YES\" (without quotes) if it is possible to form $2$ triangles, and \"NO\" (without quotes) otherwise.\n\nYou can output the answer in any case (upper or lower). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as positive responses.\n\nTags:\n['brute force', 'greedy', 'implementation', 'math', 'sortings']\n\nTime Limit: 5000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "10 5\n5 2 2 10 4 10 6 1 5 3\n1 6\n2 7\n2 8\n5 10\n4 10",
                "output": "YES\nNO\nYES\nNO\nYES"
            }
        ]
    },
    {
        "problem": "\nYou are given a grid consisting of $n$ rows and $m$ columns, where each cell is initially white. Additionally, you are given an integer $k$, where $1 \\le k \\le \\min(n, m)$.\n\nYou will process $q$ operations of two types:\n\n  * $\\mathtt{H}$ (horizontal operation) \u2014 You choose a $1 \\times k$ rectangle completely within the grid, where all cells in this rectangle are white. Then, all cells in this rectangle are changed to black.    * $\\mathtt{V}$ (vertical operation) \u2014 You choose a $k \\times 1$ rectangle completely within the grid, where all cells in this rectangle are white. Then, all cells in this rectangle are changed to black. \n\nAfter each operation, if any rows or columns become completely black, all cells in these rows and columns are simultaneously reset to white. Specifically, if all cells in the row and column a cell is contained in become black, all cells in both the row and column will be reset to white.\n\nChoose the rectangles in a way that you can perform all given operations, or determine that it is impossible.\n\nInput Format:\nEach test contains multiple test cases. The first line contains a single integer $t$ ($1 \\le t \\le 1000$) \u2014 the number of test cases. The description of test cases follows.\n\nThe first line of each test case contains four integers $n$, $m$, $k$, and $q$ ($1 \\le n, m \\le 100$, $1 \\le k \\le \\min(n, m)$, $1 \\le q \\le 1000$) \u2014 the number of rows and columns in the grid, the size of the operation rectangle, and the number of operations, respectively.\n\nThe second line of each test case contains a string $s$ of length $q$, consisting only of characters $\\mathtt{H}$ and $\\mathtt{V}$ \u2014 the sequence of operation types.\n\nIt is guaranteed that the sum of $q$ over all test cases does not exceed $1000$.\n\nOutput Format:\nFor each test case, output a single integer $-1$ if it is impossible to perform all the operations.\n\nOtherwise, output $q$ lines. Each line contains two integers $i$, $j$ ($1 \\le i \\le n$, $1 \\le j \\le m$) \u2014 the coordinates of the top-left cell of the operation rectangle.\n\nIf there are multiple solutions, output any of them.\n\nTags:\n['constructive algorithms', 'greedy', 'implementation']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "1\n4 5 3 6\nHVVHHV",
                "output": "1 1\n2 1\n1 1\n2 3\n3 3\n2 2"
            }
        ]
    },
    {
        "problem": "\nAlice and Bob are playing a game with $n$ piles of stones, where the $i$-th pile has $a_i$ stones. Players take turns making moves, with Alice going first.\n\nOn each move, the player does the following three-step process:\n\n  1. Choose an integer $k$ ($1 \\leq k \\leq \\frac n 2$). Note that the value of $k$ can be different for different moves.    2. Remove $k$ piles of stones.    3. Choose another $k$ piles of stones and split each pile into two piles. The number of stones in each new pile must be a prime number. \n\nThe player who is unable to make a move loses.\n\nDetermine who will win if both players play optimally.\n\nInput Format:\nEach test contains multiple test cases. The first line contains a single integer $t$ ($1 \\le t \\le 10^4$) \u2014 the number of test cases. The description of test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($2 \\le n \\le 2 \\cdot 10^5$) \u2014 the number of piles of stones.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\le a_i \\le 2 \\cdot 10^5$) \u2014 the number of stones in the piles.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\nOutput Format:\nFor each test case, output \"Alice\" (without quotes) if Alice wins and \"Bob\" (without quotes) otherwise.\n\nYou can output each letter in any case (upper or lower). For example, the strings \"alIcE\", \"Alice\", and \"alice\" will all be considered identical.\n\nTags:\n['bitmasks', 'dp', 'fft', 'games', 'math', 'number theory']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "4\n2\n2 1\n3\n3 5 7\n4\n4 6 8 10\n5\n8 8 8 8 8",
                "output": "Bob\nAlice\nAlice\nBob"
            }
        ]
    },
    {
        "problem": "\nThis is an interactive problem.\n\nYou are given a grid with $n$ rows and $m$ columns. You need to fill each cell with a unique integer from $1$ to $n \\cdot m$.\n\nAfter filling the grid, you will play a game on this grid against the interactor. Players take turns selecting one of the previously unselected cells from the grid, with the interactor going first.\n\nOn the first turn, the interactor can choose any cell from the grid. After that, any chosen cell must be orthogonally adjacent to at least one previously selected cell. Two cells are considered orthogonally adjacent if they share an edge. The game continues until all cells have been selected.\n\nYour goal is to let the sum of numbers in the cells selected by you be strictly less than the sum of numbers in the cells selected by the interactor.\n\nInput Format:\nEach test contains multiple test cases. The first line contains a single integer $t$ ($1 \\le t \\le 100$) \u2014 the number of test cases. The description of test cases follows.\n\nThe only line of each test case contains two integers $n$ and $m$ ($4 \\le n, m \\le 10$) \u2014 the number of rows and columns in the grid.\n\nOutput Format:\n\n\nTags:\n['constructive algorithms', 'games', 'graph matchings', 'greedy', 'interactive']\n\nTime Limit: 5000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "1\n4 4\n\n\n\n\n3 4\n\n4 4\n\n4 2\n\n4 1\n\n1 4\n\n1 2\n\n2 2\n\n2 1",
                "output": "2 3 4 10\n12 6 11 15\n5 13 16 8\n9 7 1 14\n\n2 4\n\n4 3\n\n3 3\n\n3 1\n\n1 3\n\n1 1\n\n2 3\n\n3 2"
            }
        ]
    },
    {
        "problem": "\nKmes has written three integers $a$, $b$ and $c$ in order to remember that he has to give Noobish_Monk $a \\times b \\times c$ bananas.\n\nNoobish_Monk has found these integers and decided to do the following at most $5$ times:\n\n  * pick one of these integers;    * increase it by $1$. \n\nFor example, if $a = 2$, $b = 3$ and $c = 4$, then one can increase $a$ three times by one and increase $b$ two times. After that $a = 5$, $b = 5$, $c = 4$. Then the total number of bananas will be $5 \\times 5 \\times 4 = 100$.\n\nWhat is the maximum value of $a \\times b \\times c$ Noobish_Monk can achieve with these operations?\n\nInput Format:\nEach test contains multiple test cases. The first line of input contains a single integer $t$ ($1 \\le t \\le 1000$) \u2014 the number of test cases. The description of the test cases follows.\n\nThe first and only line of each test case contains three integers $a$, $b$ and $c$ ($1 \\le a, b, c \\le 10$) \u2014 Kmes's integers.\n\nOutput Format:\nFor each test case, output a single integer \u2014 the maximum amount of bananas Noobish_Monk can get.\n\nTags:\n['brute force', 'constructive algorithms', 'greedy', 'math', 'sortings']\n\nTime Limit: 1000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "2\n2 3 4\n10 1 10",
                "output": "100\n600"
            }
        ]
    },
    {
        "problem": "\nTo celebrate his recovery, k1o0n has baked an enormous $n$ metres long potato casserole.\n\nTurns out, Noobish_Monk just can't stand potatoes, so he decided to ruin k1o0n's meal. He has cut it into $k$ pieces, of lengths $a_1, a_2, \\dots, a_k$ meters.\n\nk1o0n wasn't keen on that. Luckily, everything can be fixed. In order to do that, k1o0n can do one of the following operations:\n\n  * Pick a piece with length $a_i \\ge 2$ and divide it into two pieces with lengths $1$ and $a_i - 1$. As a result, the number of pieces will increase by $1$;    * Pick a slice $a_i$ and another slice with length $a_j=1$ ($i \\ne j$) and merge them into one piece with length $a_i+1$. As a result, the number of pieces will decrease by $1$. \n\nHelp k1o0n to find the minimum number of operations he needs to do in order to merge the casserole into one piece with length $n$.\n\nFor example, if $n=5$, $k=2$ and $a = [3, 2]$, it is optimal to do the following:\n\n  1. Divide the piece with length $2$ into two pieces with lengths $2-1=1$ and $1$, as a result $a = [3, 1, 1]$.    2. Merge the piece with length $3$ and the piece with length $1$, as a result $a = [4, 1]$.    3. Merge the piece with length $4$ and the piece with length $1$, as a result $a = [5]$.\n\nInput Format:\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$).\n\nDescription of each test case consists of two lines. The first line contains two integers $n$ and $k$ ($2 \\le n \\le 10^9$, $2 \\le k \\le 10^5$) \u2014 length of casserole and the number of pieces.\n\nThe second line contains $k$ integers $a_1, a_2, \\ldots, a_k$ ($1 \\le a_i \\le n - 1$, $\\sum a_i = n$) \u2014 lengths of pieces of casserole, which Noobish_Monk has cut.\n\nIt is guaranteed that the sum of $k$ over all $t$ test cases doesn't exceed $2 \\cdot 10^5$.\n\nOutput Format:\nFor each test case, output the minimum number of operations K1o0n needs to restore his pie after the terror of Noobish_Monk.\n\nTags:\n['greedy', 'math', 'sortings']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "4\n5 3\n3 1 1\n5 2\n3 2\n11 4\n2 3 1 5\n16 6\n1 6 1 1 1 6",
                "output": "2\n3\n9\n15"
            }
        ]
    },
    {
        "problem": "\nGorilla and Noobish_Monk found three numbers $n$, $m$, and $k$ ($m < k$). They decided to construct a permutation$^{\\dagger}$ of length $n$.\n\nFor the permutation, Noobish_Monk came up with the following function: $g(i)$ is the sum of all the numbers in the permutation on a prefix of length $i$ that are not greater than $m$. Similarly, Gorilla came up with the function $f$, where $f(i)$ is the sum of all the numbers in the permutation on a prefix of length $i$ that are not less than $k$. A prefix of length $i$ is a subarray consisting of the first $i$ elements of the original array.\n\nFor example, if $n = 5$, $m = 2$, $k = 5$, and the permutation is $[5, 3, 4, 1, 2]$, then:\n\n  * $f(1) = 5$, because $5 \\ge 5$; $g(1) = 0$, because $5 > 2$;    * $f(2) = 5$, because $3 < 5$; $g(2) = 0$, because $3 > 2$;    * $f(3) = 5$, because $4 < 5$; $g(3) = 0$, because $4 > 2$;    * $f(4) = 5$, because $1 < 5$; $g(4) = 1$, because $1 \\le 2$;    * $f(5) = 5$, because $2 < 5$; $g(5) = 1 + 2 = 3$, because $2 \\le 2$. \n\nHelp them find a permutation for which the value of $\\left(\\sum_{i=1}^n f(i) - \\sum_{i=1}^n g(i)\\right)$ is maximized.\n\n$^{\\dagger}$A permutation of length $n$ is an array consisting of $n$ distinct integers from $1$ to $n$ in any order. For example, $[2,3,1,5,4]$ is a permutation, but $[1,2,2]$ is not a permutation (as $2$ appears twice in the array) and $[1,3,4]$ is also not a permutation (as $n=3$, but $4$ appears in the array).\n\nInput Format:\nThe first line contains a single integer $t$ ($1 \\le t \\le 10^4$)  \u2014 the number of test cases.\n\nThe only line of each case contains three integers $n$, $m$, $k$ ($2\\le n \\le 10^5$; $1 \\le m < k \\le n$) \u2014 the size of the permutation to be constructed and two integers.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\nOutput Format:\nFor each test case, output the permutation  \u2014 a set of numbers that satisfies the conditions of the problem. If there are multiple solutions, output any of them.\n\nTags:\n['constructive algorithms', 'math']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "3\n5 2 5\n3 1 3\n10 3 8",
                "output": "5 3 4 1 2\n3 2 1\n10 9 8 4 7 5 6 1 2 3"
            }
        ]
    },
    {
        "problem": "\nErnKor is ready to do anything for Julen, even to swim through crocodile- infested swamps. We decided to test this love. ErnKor will have to swim across a river with a width of $1$ meter and a length of $n$ meters.\n\nThe river is very cold. Therefore, in total (that is, throughout the entire swim from $0$ to $n+1$) ErnKor can swim in the water for no more than $k$ meters. For the sake of humanity, we have added not only crocodiles to the river, but also logs on which he can jump. Our test is as follows:\n\nInitially, ErnKor is on the left bank and needs to reach the right bank. They are located at the $0$ and $n+1$ meters respectively. The river can be represented as $n$ segments, each with a length of $1$ meter. Each segment contains either a log 'L', a crocodile 'C', or just water 'W'. ErnKor can move as follows:\n\n  * If he is on the surface (i.e., on the bank or on a log), he can jump forward for no more than $m$ ($1 \\le m \\le 10$) meters (he can jump on the bank, on a log, or in the water).    * If he is in the water, he can only swim to the next river segment (or to the bank if he is at the $n$-th meter).    * ErnKor cannot land in a segment with a crocodile in any way. \n\nDetermine if ErnKor can reach the right bank.\n\nInput Format:\nThe first line contains a single integer $t$ ($1 \\le t \\le 10^4$)  \u2014 the number of test cases.\n\nThe first line of each test case contains three numbers $n, m, k$ ($0 \\le k \\le 2 \\cdot 10^5$, $1 \\le n \\le 2 \\cdot 10^5$, $1 \\le m \\le 10$) \u2014 the length of the river, the distance ErnKor can jump, and the number of meters ErnKor can swim without freezing.\n\nThe second line of each test case contains a string $a$ of length $n$. $a_i$ denotes the object located at the $i$-th meter. ($a_i \\in \\\\{$'W','C','L'$\\\\}$)\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\nOutput Format:\nFor each test case, output \"YES\" if ErnKor can pass the test, and output \"NO\" otherwise.\n\nYou can output the answer in any case (upper or lower). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as positive responses.\n\nTags:\n['dp', 'greedy', 'implementation']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "6\n6 2 0\nLWLLLW\n6 1 1\nLWLLLL\n6 1 1\nLWLLWL\n6 2 15\nLWLLCC\n6 10 0\nCCCCCC\n6 6 1\nWCCCCW",
                "output": "YES\nYES\nNO\nNO\nYES\nYES"
            }
        ]
    },
    {
        "problem": "\nOne of the first programming problems by K1o0n looked like this: \"Noobish_Monk has $n$ $(1 \\le n \\le 100)$ friends. Each of them gave him $a$ $(1 \\le a \\le 10000)$ apples for his birthday. Delighted with such a gift, Noobish_Monk returned $b$ $(1 \\le b \\le \\min(10000, a \\cdot n))$ apples to his friends. How many apples are left with Noobish_Monk?\"\n\nK1o0n wrote a solution, but accidentally considered the value of $n$ as a string, so the value of $n \\cdot a - b$ was calculated differently. Specifically:\n\n  * when multiplying the string $n$ by the integer $a$, he will get the string $s=\\underbrace{n + n + \\dots + n + n}_{a\\ \\text{times}}$    * when subtracting the integer $b$ from the string $s$, the last $b$ characters will be removed from it. If $b$ is greater than or equal to the length of the string $s$, it will become empty. \n\nLearning about this, ErnKor became interested in how many pairs $(a, b)$ exist for a given $n$, satisfying the constraints of the problem, on which K1o0n's solution gives the correct answer.\n\n\"The solution gives the correct answer\" means that it outputs a non-empty string, and this string, when converted to an integer, equals the correct answer, i.e., the value of $n \\cdot a - b$.\n\nInput Format:\nThe first line contains a single integer $t$ ($1 \\le t \\le 100$)  \u2014 the number of test cases.\n\nFor each test case, a single line of input contains an integer $n$ ($1 \\le n \\le 100$).\n\nIt is guaranteed that in all test cases, $n$ is distinct.\n\nOutput Format:\nFor each test case, output the answer in the following format:\n\nIn the first line, output the integer $x$ \u2014 the number of bad tests for the given $n$.\n\nIn the next $x$ lines, output two integers $a_i$ and $b_i$ \u2014 such integers that K1o0n's solution on the test \"$n$ $a_i$ $b_i$\" gives the correct answer.\n\nTags:\n['brute force', 'constructive algorithms', 'implementation', 'math', 'strings']\n\nTime Limit: 3000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "3\n2\n3\n10",
                "output": "3\n20 18 \n219 216 \n2218 2214 \n1\n165 162 \n1\n1262 2519"
            }
        ]
    },
    {
        "problem": "\nIn his favorite cafe Kmes once again wanted to try the herring under a fur coat. Previously, it would not have been difficult for him to do this, but the cafe recently introduced a new purchasing policy.\n\nNow, in order to make a purchase, Kmes needs to solve the following problem: $n$ cards with prices for different positions are laid out in front of him, on the $i$-th card there is an integer $a_i$, among these prices there is no whole positive integer $x$.\n\nKmes is asked to divide these cards into the minimum number of bad segments (so that each card belongs to exactly one segment). A segment is considered bad if it is impossible to select a subset of cards with a product equal to $x$. All segments, in which Kmes will divide the cards, must be bad.\n\nFormally, the segment $(l, r)$ is bad if there are no indices $i_1 < i_2 < \\ldots < i_k$ such that $l \\le i_1, i_k \\le r$, and $a_{i_1} \\cdot a_{i_2} \\ldots \\cdot a_{i_k} = x$.\n\nHelp Kmes determine the minimum number of bad segments in order to enjoy his favorite dish.\n\nInput Format:\nThe first line contains a single integer $t$ ($1 \\le t \\le 10^3$) \u2014 the number of test cases.\n\nThe first line of each set of input data gives you $2$ integers $n$ and $x$ ($1 \\le n \\le 10^5, 2 \\le x \\le 10^5$) \u2014 the number of cards and the integer, respectively.\n\nThe second line of each set of input data contains $n$ integers $a_i$ ($1 \\le a_i \\le 2 \\cdot 10^5, a_i \\neq x$) \u2014 the prices on the cards.\n\nIt is guaranteed that the sum of $n$ over all sets of test data does not exceed $10^5$.\n\nOutput Format:\nFor each set of input data, output the minimum number of bad segments.\n\nTags:\n['brute force', 'dp', 'greedy', 'number theory', 'two pointers']\n\nTime Limit: 4000 ms\nMemory Limit: 512 MB\n",
        "tests": [
            {
                "input": "8\n6 4\n2 3 6 2 1 2\n9 100000\n50000 25000 12500 6250 3125 2 4 8 16\n5 2\n1 1 1 1 1\n8 6\n4 3 4 3 4 3 4 3\n7 12\n6 11 1 3 11 10 2\n10 5\n2 4 4 2 4 4 4 3 1 1\n7 8\n4 6 5 1 2 4 1\n8 27\n3 9 17 26 2 20 9 3",
                "output": "3\n2\n1\n1\n2\n1\n3\n3"
            }
        ]
    },
    {
        "problem": "\nK1o0n gave you an array $a$ of length $n$, consisting of numbers $1, 2, \\ldots, n$. Accept it? Of course! But what to do with it? Of course, calculate $\\text{MEOW}(a)$.\n\nLet $\\text{MEX}(S, k)$ be the $k$-th positive (strictly greater than zero) integer in ascending order that is not present in the set $S$. Denote $\\text{MEOW}(a)$ as the sum of $\\text{MEX}(b, |b| + 1)$, over all distinct subsets $b$ of the array $a$.\n\nExamples of $\\text{MEX}(S, k)$ values for sets:\n\n  * $\\text{MEX}(\\\\{3,2\\\\}, 1) = 1$, because $1$ is the first positive integer not present in the set;    * $\\text{MEX}(\\\\{4,2,1\\\\}, 2) = 5$, because the first two positive integers not present in the set are $3$ and $5$;    * $\\text{MEX}(\\\\{\\\\}, 4) = 4$, because there are no numbers in the empty set, so the first $4$ positive integers not present in it are $1, 2, 3, 4$.\n\nInput Format:\nThe first line contains a single integer $t$ ($1 \\le t \\le 10^4$) \u2014 the number of test cases.\n\nIn a single line of each test case, an integer $n$ ($1 \\le n \\le 5000$) is entered, the size of the array of gifted numbers.\n\nIt is guaranteed that the sum of $n^2$ over all test cases does not exceed $25 \\cdot 10^6$.\n\nOutput Format:\nFor each test case, output a single number \u2014 $\\text{MEOW}(a)$. Since it may be very large, output it modulo $10^9 + 7$.\n\nTags:\n['combinatorics', 'dp', 'math']\n\nTime Limit: 2500 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "5\n2\n3\n4999\n5\n1",
                "output": "12\n31\n354226409\n184\n4"
            }
        ]
    },
    {
        "problem": "\nTim is doing a test consisting of $4n$ questions; each question has $4$ options: 'A', 'B', 'C', and 'D'. For each option, there are exactly $n$ correct answers corresponding to that option \u2014 meaning there are $n$ questions with the answer 'A', $n$ questions with the answer 'B', $n$ questions with the answer 'C', and $n$ questions with the answer 'D'.\n\nFor each question, Tim wrote his answer on the answer sheet. If he could not figure out the answer, he would leave a question mark '?' for that question.\n\nYou are given his answer sheet of $4n$ characters. What is the maximum number of correct answers Tim can get?\n\nInput Format:\nThe first line contains a single integer $t$ ($1 \\le t \\le 1000$) \u2014 the number of test cases.\n\nThe first line of each test case contains an integer $n$ ($1 \\le n \\le 100$).\n\nThe second line of each test case contains a string $s$ of $4n$ characters ($s_i \\in \\\\{\\texttt{A}, \\texttt{B}, \\texttt{C}, \\texttt{D}, \\texttt{?}\\\\}$) \u2014 Tim's answers for the questions.\n\nOutput Format:\nFor each test case, print a single integer \u2014 the maximum score that Tim can achieve.\n\nTags:\n['greedy', 'implementation']\n\nTime Limit: 1000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "6\n1\nABCD\n2\nAAAAAAAA\n2\nAAAABBBB\n2\n????????\n3\nABCABCABCABC\n5\nACADC??ACAC?DCAABC?C",
                "output": "4\n2\n4\n0\n9\n13"
            }
        ]
    },
    {
        "problem": "\nGiven an array $a$ of $n$ positive integers.\n\nIn one operation, you can pick any pair of indexes $(i, j)$ such that $a_i$ and $a_j$ have distinct parity, then replace the smaller one with the sum of them. More formally:\n\n  * If $a_i < a_j$, replace $a_i$ with $a_i + a_j$;    * Otherwise, replace $a_j$ with $a_i + a_j$. \n\nFind the minimum number of operations needed to make all elements of the array have the same parity.\n\nInput Format:\nThe first line contains a single integer $t$ ($1 \\le t \\le 10^4$) \u2014 the number of test cases.\n\nThe first line of each test case contains a single integer $n$ ($1 \\le n \\le 2 \\cdot 10^5$).\n\nThe second line contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\le a_i \\le 10^9$) \u2014 the elements of array $a$.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\nOutput Format:\nFor each test case, output a single integer \u2014 the minimum number of operations required.\n\nTags:\n['constructive algorithms', 'greedy']\n\nTime Limit: 1000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "7\n5\n1 3 5 7 9\n4\n4 4 4 4\n3\n2 3 4\n4\n3 2 2 8\n6\n4 3 6 1 2 1\n6\n3 6 1 2 1 2\n5\n999999996 999999997 999999998 999999999 1000000000",
                "output": "0\n0\n2\n4\n3\n3\n3"
            }
        ]
    },
    {
        "problem": "\nThere is an apartment consisting of $n$ rooms, each with its light initially turned off.\n\nTo control the lights in these rooms, the owner of the apartment decided to install chips in the rooms so that each room has exactly one chip, and the chips are installed at different times. Specifically, these times are represented by the array $a_1, a_2, \\ldots, a_n$, where $a_i$ is the time (in minutes) at which a chip is installed in the $i$-th room.\n\nAs soon as a chip is installed, it changes the room's light status every $k$ minutes \u2014 it turns on the light for $k$ minutes, then turns it off for the next $k$ minutes, then turns it back on for the next $k$ minutes, and so on. In other words, the light status is changed by the chip at minute $a_i$, $a_i + k$, $a_i + 2k$, $a_i + 3k$, $\\ldots$ for the $i$-th room.\n\nWhat is the earliest moment when all rooms in the apartment have their lights turned on?\n\nInput Format:\nThe first line contains a single integer $t$ ($1 \\le t \\le 10^4$) \u2014 the number of test cases.\n\nThe first line of each test case contains two integers $n$ and $k$ ($1 \\le k \\le n \\le 2 \\cdot 10^5$) \u2014 the number of rooms in the apartment and the period of the chips.\n\nThe second line contains $n$ distinct integers $a_1, a_2, \\ldots, a_n$ ($1 \\le a_i \\le 10^9$) \u2014 the moments when the chips are installed.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\nOutput Format:\nFor each test case, print a single integer \u2014 the answer to the question (in minutes). If there is no such moment that the lights are turned on in all the rooms, print $-1$ instead.\n\nTags:\n['implementation', 'math']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "9\n4 4\n2 3 4 5\n4 3\n2 3 4 5\n4 3\n3 4 8 9\n3 3\n6 2 1\n1 1\n1\n7 5\n14 34 6 25 46 7 17\n6 5\n40 80 99 60 90 50\n6 5\n64 40 50 68 70 10\n2 1\n1 1000000000",
                "output": "5\n-1\n10\n8\n1\n47\n100\n-1\n-1"
            }
        ]
    },
    {
        "problem": "\nGiven two positive integers $n$ and $k$, and another array $a$ of $n$ integers.\n\nIn one operation, you can select any subarray of size $k$ of $a$, then remove it from the array without changing the order of other elements. More formally, let $(l, r)$ be an operation on subarray $a_l, a_{l+1}, \\ldots, a_r$ such that $r-l+1=k$, then performing this operation means replacing $a$ with $[a_1, \\ldots, a_{l-1}, a_{r+1}, \\ldots, a_n]$.\n\nFor example, if $a=[1,2,3,4,5]$ and we perform operation $(3,5)$ on this array, it will become $a=[1,2]$. Moreover, operation $(2, 4)$ results in $a=[1,5]$, and operation $(1,3)$ results in $a=[4,5]$.\n\nYou have to repeat the operation while the length of $a$ is greater than $k$ (which means $|a| \\gt k$). What is the largest possible median$^\\dagger$ of all remaining elements of the array $a$ after the process?\n\n$^\\dagger$The median of an array of length $n$ is the element whose index is $\\left \\lfloor (n+1)/2 \\right \\rfloor$ after we sort the elements in non-decreasing order. For example: $median([2,1,5,4,3]) = 3$, $median([5]) = 5$, and $median([6,8,2,4]) = 4$.\n\nInput Format:\nThe first line contains a single integer $t$ ($1 \\le t \\le 10^4$) \u2014 the number of test cases.\n\nThe first line of each test case contains two integers $n$ and $k$ ($1 \\le n, k \\le 5 \\cdot 10^5$).\n\nThe second line contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\le a_i \\le 10^9$) \u2014 the array $a$.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $5 \\cdot 10^5$.\n\nOutput Format:\nFor each test case, print a single integer \u2014 the largest median possible after performing the operations.\n\nTags:\n['binary search', 'dp', 'greedy']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "5\n4 3\n3 9 9 2\n5 3\n3 2 5 6 4\n7 1\n5 9 2 6 5 4 6\n8 2\n7 1 2 6 8 3 4 5\n4 5\n3 4 5 6",
                "output": "3\n4\n9\n6\n4"
            }
        ]
    },
    {
        "problem": "\nGiven a matrix $a$ of size $n \\times m$, each cell of which contains a non-negative integer. The integer lying at the intersection of the $i$-th row and the $j$-th column of the matrix is called $a_{i,j}$.\n\nLet's define $f(i)$ and $g(j)$ as the [XOR](https://en.wikipedia.org/wiki/Exclusive_or) of all integers in the $i$-th row and the $j$-th column, respectively. In one operation, you can either:\n\n  * Select any row $i$, then assign $a_{i,j} := g(j)$ for each $1 \\le j \\le m$; or    * Select any column $j$, then assign $a_{i,j} := f(i)$ for each $1 \\le i \\le n$. \n\n![](CDN_BASE_URL/3bba110245afb461968dbb618fc60828) An example of applying an operation on column $2$ of the matrix.\n\nIn this example, as we apply an operation on column $2$, all elements in this column are changed:\n\n  * $a_{1,2} := f(1) = a_{1,1} \\oplus a_{1,2} \\oplus a_{1,3} \\oplus a_{1,4} = 1 \\oplus 1 \\oplus 1 \\oplus 1 = 0$    * $a_{2,2} := f(2) = a_{2,1} \\oplus a_{2,2} \\oplus a_{2,3} \\oplus a_{2,4} = 2 \\oplus 3 \\oplus 5 \\oplus 7 = 3$    * $a_{3,2} := f(3) = a_{3,1} \\oplus a_{3,2} \\oplus a_{3,3} \\oplus a_{3,4} = 2 \\oplus 0 \\oplus 3 \\oplus 0 = 1$    * $a_{4,2} := f(4) = a_{4,1} \\oplus a_{4,2} \\oplus a_{4,3} \\oplus a_{4,4} = 10 \\oplus 11 \\oplus 12 \\oplus 16 = 29$ \n\nYou can apply the operations any number of times. Then, we calculate the $\\textit{beauty}$ of the final matrix by summing the absolute differences between all pairs of its adjacent cells.\n\nMore formally, $\\textit{beauty}(a) = \\sum|a_{x,y} - a_{r,c}|$ for all cells $(x, y)$ and $(r, c)$ if they are adjacent. Two cells are considered adjacent if they share a side.\n\nFind the minimum $\\textit{beauty}$ among all obtainable matrices.\n\nInput Format:\nThe first line contains a single integer $t$ ($1 \\le t \\le 250$) \u2014 the number of test cases.\n\nThe first line of each test case contains two integers $n$ and $m$ ($1 \\le n, m \\le 15$) \u2014 the number of rows and columns of $a$, respectively.\n\nThe next $n$ lines, each containing $m$ integers $a_{i,1}, a_{i,2}, \\ldots, a_{i,m}$ ($0 \\le a_{i,j} < 2^{20}$) \u2014 description of the matrix $a$.\n\nIt is guaranteed that the sum of $(n^2 + m^2)$ over all test cases does not exceed $500$.\n\nOutput Format:\nFor each test case, print a single integer $b$ \u2014 the smallest possible $\\textit{beauty}$ of the matrix.\n\nTags:\n['bitmasks', 'constructive algorithms', 'dp', 'implementation']\n\nTime Limit: 5000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "4\n1 2\n1 3\n2 3\n0 1 0\n5 4 4\n2 3\n0 2 4\n4 5 1\n3 3\n1 2 3\n4 5 6\n7 8 9",
                "output": "1\n3\n13\n24"
            }
        ]
    },
    {
        "problem": "\nThis is the easy version of the problem. The only difference is that in this version $k \\le n$. You can make hacks only if both versions of the problem are solved.      Given a $w \\times h$ rectangle on the $Oxy$ plane, with points $(0, 0)$ at the bottom-left and $(w, h)$ at the top-right of the rectangle.\n\nYou also have a robot initially at point $(0, 0)$ and a script $s$ of $n$ characters. Each character is either L, R, U, or D, which tells the robot to move left, right, up, or down respectively.\n\nThe robot can only move inside the rectangle; otherwise, it will change the script $s$ as follows:\n\n  * If it tries to move outside a vertical border, it changes all L characters to R's (and vice versa, all R's to L's).    * If it tries to move outside a horizontal border, it changes all U characters to D's (and vice versa, all D's to U's). \n\nThen, it will execute the changed script starting from the character which it couldn't execute.\n\n![](CDN_BASE_URL/ff5ae9758c965c2d8398c936e9581dab) An example of the robot's movement process, $s = \\texttt{\"ULULURD\"}$\n\nThe script $s$ will be executed for $k$ times continuously. All changes to the string $s$ will be retained even when it is repeated. During this process, how many times will the robot move to the point $(0, 0)$ in total? Note that the initial position does NOT count.\n\nInput Format:\nThe first line contains a single integer $t$ ($1 \\le t \\le 10^4$) \u2014 the number of test cases.\n\nThe first line of each test case contains four integers $n$, $k$, $w$, and $h$ ($1 \\le n, w, h \\le 10^6$; $1 \\le k \\le n$).\n\nThe second line contains a single string $s$ of size $n$ ($s_i \\in \\\\{\\texttt{L}, \\texttt{R}, \\texttt{U}, \\texttt{D}\\\\}$) \u2014 the script to be executed.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $10^6$.\n\nOutput Format:\nFor each test case, print a single integer \u2014 the number of times the robot reaches $(0, 0)$ when executing script $s$ for $k$ times continuously.\n\nTags:\n['brute force', 'chinese remainder theorem', 'constructive algorithms', 'math', 'number theory']\n\nTime Limit: 3000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "5\n2 2 2 2\nUR\n4 2 1 1\nLLDD\n6 3 3 1\nRLRRRL\n5 5 3 3\nRUURD\n7 5 3 4\nRRDLUUU",
                "output": "0\n4\n3\n0\n1"
            }
        ]
    },
    {
        "problem": "\nThis is the hard version of the problem. The only difference is that in this version $k \\le 10^{12}$. You can make hacks only if both versions of the problem are solved.\n\nGiven a $w \\times h$ rectangle on the $Oxy$ plane, with points $(0, 0)$ at the bottom-left and $(w, h)$ at the top-right of the rectangle.\n\nYou also have a robot initially at point $(0, 0)$ and a script $s$ of $n$ characters. Each character is either L, R, U, or D, which tells the robot to move left, right, up, or down respectively.\n\nThe robot can only move inside the rectangle; otherwise, it will change the script $s$ as follows:\n\n  * If it tries to move outside a vertical border, it changes all L characters to R's (and vice versa, all R's to L's).    * If it tries to move outside a horizontal border, it changes all U characters to D's (and vice versa, all D's to U's). \n\nThen, it will execute the changed script starting from the character which it couldn't execute.\n\n![](CDN_BASE_URL/ff5ae9758c965c2d8398c936e9581dab) An example of the robot's movement process, $s = \\texttt{\"ULULURD\"}$\n\nThe script $s$ will be executed for $k$ times continuously. All changes to the string $s$ will be retained even when it is repeated. During this process, how many times will the robot move to the point $(0, 0)$ in total? Note that the initial position does NOT count.\n\nInput Format:\nThe first line contains a single integer $t$ ($1 \\le t \\le 10^4$) \u2014 the number of test cases.\n\nThe first line of each test case contains four integers $n$, $k$, $w$, and $h$ ($1 \\le n, w, h \\le 10^6$; $1 \\le k \\le 10^{12}$).\n\nThe second line contains a single string $s$ of size $n$ ($s_i \\in \\\\{\\texttt{L}, \\texttt{R}, \\texttt{U}, \\texttt{D}\\\\}$) \u2014 the script to be executed.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $10^6$.\n\nOutput Format:\nFor each test case, print a single integer \u2014 the number of times the robot reaches $(0, 0)$ when executing script $s$ for $k$ times continuously.\n\nTags:\n['chinese remainder theorem', 'math', 'number theory']\n\nTime Limit: 3000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "6\n2 4 2 2\nUR\n4 2 1 1\nLLDD\n6 3 3 1\nRLRRRL\n5 6 3 3\nRUURD\n7 5 3 4\nRRDLUUU\n7 123456789999 3 2\nULULURD",
                "output": "1\n4\n3\n1\n1\n41152263332"
            }
        ]
    },
    {
        "problem": "\nPetr, watching Sergey's stream, came up with a matrix $a$, consisting of $n$ rows and $m$ columns (the number in the $i$-th row and $j$-th column is denoted as $a_{i, j}$), which contains all integers from $1$ to $n \\cdot m$. But he didn't like the arrangement of the numbers, and now he wants to come up with a new matrix $b$, consisting of $n$ rows and $m$ columns, which will also contain all integers from $1$ to $n \\cdot m$, such that for any $1 \\leq i \\leq n, 1 \\leq j \\leq m$ it holds that $a_{i, j} \\ne b_{i, j}$.\n\nYou are given the matrix $a$, construct any matrix $b$ that meets Petr's requirements, or determine that it is impossible.\n\nHurry up! Otherwise, he will donate all his money to the stream in search of an answer to his question.\n\nInput Format:\nEach test consists of multiple test cases. The first line contains an integer $t$ ($1 \\leq t \\leq 10^3$) \u2014 the number of test cases. Then follows the description of the test cases.\n\nThe first line of each test case contains two integers $n$ and $m$ ($1 \\leq n, m \\leq 10$) \u2014 the number of rows and columns of matrix $a$.\n\nThe next $n$ lines contain $m$ integers each, describing matrix $a$. The $i$-th of these lines contains the elements of matrix $a_{i, 1}, a_{i, 2}, \\ldots, a_{i, m}$.\n\nIt is guaranteed that all numbers in matrix $a$ are distinct and $1 \\leq a_{i, j} \\leq n \\cdot m$.\n\nIt is guaranteed that the sum of $n \\cdot m$ over all test cases does not exceed $5 \\cdot 10^4$.\n\nOutput Format:\nFor each test case, output $n \\cdot m$ integers \u2014 any suitable matrix $b$, or $-1$ if such a matrix does not exist.\n\nTags:\n['constructive algorithms', 'greedy', 'implementation']\n\nTime Limit: 1000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "5\n1 1\n1\n2 1\n2\n1\n1 5\n2 4 5 3 1\n2 4\n1 2 3 4\n5 6 7 8\n3 3\n4 2 1\n9 8 3\n6 7 5",
                "output": "-1\n1 \n2 \n4 5 3 1 2 \n6 7 8 5 \n2 3 4 1 \n8 3 9 \n7 5 6 \n2 1 4"
            }
        ]
    },
    {
        "problem": "\nVova really loves the [XOR](https://en.wikipedia.org/wiki/Bitwise_operation#XOR) operation (denoted as $\\oplus$). Recently, when he was going to sleep, he came up with a fun game.\n\nAt the beginning of the game, Vova chooses two binary sequences $s$ and $t$ of length $n$ and gives them to Vanya. A binary sequence is a sequence consisting only of the numbers $0$ and $1$. Vanya can choose integers $l, r$ such that $1 \\leq l \\leq r \\leq n$, and for all $l \\leq i \\leq r$ simultaneously replace $s_i$ with $s_i \\oplus s_{i - l + 1}$, where $s_i$ is the $i$-th element of the sequence $s$.\n\nIn order for the game to be interesting, there must be a possibility to win. Vanya wins if, with an unlimited number of actions, he can obtain the sequence $t$ from the sequence $s$. Determine if the game will be interesting for the sequences $s$ and $t$.\n\nInput Format:\nEach test consists of multiple test cases. The first line contains an integer $q$ ($1 \\le q \\le 10^{4}$) \u2014 the number of test cases. Then follows the description of the test cases.\n\nThe first line of each test case contains a single integer $n$ ($1 \\leq n \\leq 2 \\cdot 10^5$) \u2014 the length of the sequences $s$ and $t$.\n\nThe second line of each test case contains a binary sequence $s$ of length $n$.\n\nThe third line of each test case contains a binary sequence $t$ of length $n$.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\nOutput Format:\nFor each test case, output \"Yes\" if the game will be interesting, otherwise output \"No\".\n\nYou can output each letter in any case (for example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as a positive answer).\n\nTags:\n['bitmasks', 'constructive algorithms', 'greedy', 'math']\n\nTime Limit: 1000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "6\n1\n0\n1\n7\n0110100\n0110100\n9\n100101010\n101111110\n4\n0011\n1011\n4\n0100\n0001\n8\n10110111\n01100000",
                "output": "NO\nYES\nYES\nNO\nYES\nYES"
            }
        ]
    },
    {
        "problem": "\nYaroslav is playing a computer game, and at one of the levels, he encountered $n$ mushrooms arranged in a row. Each mushroom has its own level of toxicity; the $i$-th mushroom from the beginning has a toxicity level of $a_i$. Yaroslav can choose two integers $1 \\le l \\le r \\le n$, and then his character will take turns from left to right to eat mushrooms from this subsegment one by one, i.e., the mushrooms with numbers $l, l+1, l+2, \\ldots, r$.\n\nThe character has a toxicity level $g$, initially equal to $0$. The computer game is defined by the number $x$ \u2014 the maximum toxicity level at any given time. When eating a mushroom with toxicity level $k$, the following happens:\n\n  1. The toxicity level of the character is increased by $k$.    2. If $g \\leq x$, the process continues; otherwise, $g$ becomes zero and the process continues. \n\nYaroslav became interested in how many ways there are to choose the values of $l$ and $r$ such that the final value of $g$ is not zero. Help Yaroslav find this number!\n\nInput Format:\nEach test consists of multiple test cases. The first line contains an integer $t$ ($1 \\le t \\le 10^{4}$) \u2014 the number of test cases. Then follows the description of the test cases.\n\nThe first line of each test case contains two integers $n$, $x$ ($1 \\leq n \\leq 2 \\cdot 10^5, 1 \\le x \\le 10^9$) \u2014 the number of mushrooms and the maximum toxicity level.\n\nThe second line of each test case contains $n$ numbers $a_1, a_2, \\ldots, a_n$ ($1 \\leq a_i \\leq 10^9$).\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\nOutput Format:\nFor each test case, output a single number \u2014 the number of subsegments such that the final value of $g$ will not be zero.\n\nTags:\n['binary search', 'dp', 'two pointers']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "5\n4 2\n1 1 1 1\n3 2\n1 2 3\n1 6\n10\n6 3\n1 2 1 4 3 8\n5 999999999\n999999999 999999998 1000000000 1000000000 500000000",
                "output": "8\n2\n0\n10\n7"
            }
        ]
    },
    {
        "problem": "\nVanya has a graph with $n$ vertices (numbered from $1$ to $n$) and an array $a$ of $n$ integers; initially, there are no edges in the graph. Vanya got bored, and to have fun, he decided to perform $n - 1$ operations.\n\nOperation number $x$ (operations are numbered in order starting from $1$) is as follows:\n\n  * Choose $2$ different numbers $1 \\leq u,v \\leq n$, such that $|a_u - a_v|$ is divisible by $x$.    * Add an undirected edge between vertices $u$ and $v$ to the graph. \n\nHelp Vanya get a connected$^{\\text{\u2217}}$ graph using the $n - 1$ operations, or determine that it is impossible.\n\n$^{\\text{\u2217}}$A graph is called connected if it is possible to reach any vertex from any other by moving along the edges.\n\nInput Format:\nEach test consists of multiple test cases. The first line contains an integer $t$ ($1 \\le t \\le 10^{3}$) \u2014 the number of test cases. Then follows the description of the test cases.\n\nThe first line of each test case contains the number $n$ ($1 \\leq n \\leq 2000$) \u2014 the number of vertices in the graph.\n\nThe second line of each test case contains $n$ numbers $a_1, a_2, \\cdots a_n$ ($1 \\leq a_i \\leq 10^9$).\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2000$.\n\nOutput Format:\nFor each test case, if there is no solution, then output \"No\" (without quotes).\n\nOtherwise, output \"Yes\" (without quotes), and then output $n - 1$ lines, where in the $i$-th line, output the numbers $u$ and $v$ that need to be chosen for operation $i$.\n\nYou can output each letter in any case (for example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as a positive answer).\n\nTags:\n['constructive algorithms', 'dsu', 'graphs', 'greedy', 'math', 'number theory', 'trees']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "8\n2\n1 4\n4\n99 7 1 13\n5\n10 2 31 44 73\n5\n87 6 81 44 32\n5\n62 35 33 79 16\n5\n6 51 31 69 42\n5\n52 63 25 21 5\n12\n33 40 3 11 31 43 37 8 50 5 12 22",
                "output": "YES\n2 1\nYES\n4 1\n2 1\n3 2\nYES\n5 1\n4 1\n3 1\n2 1\nYES\n4 1\n3 1\n2 1\n5 4\nYES\n3 1\n5 1\n2 1\n4 2\nYES\n4 1\n5 1\n2 1\n3 2\nYES\n2 1\n5 2\n3 1\n4 3\nYES\n9 1\n12 9\n11 1\n10 1\n6 1\n7 6\n2 1\n8 2\n5 2\n3 1\n4 1"
            }
        ]
    },
    {
        "problem": "\nYou are given a forest of $k$ rooted trees$^{\\text{\u2217}}$. Lumberjack Timofey wants to cut down the entire forest by applying the following operation:\n\n  * Select a subtree$^{\\text{\u2020}}$ of any vertex of one of the trees and remove it from the tree. \n\nTimofey loves bitwise operations, so he wants the [bitwise OR](https://en.wikipedia.org/wiki/Bitwise_operation#OR) of the sizes of the subtrees he removed to be maximum. Help him and find the maximum result he can obtain.\n\n$^{\\text{\u2217}}$ A tree is a connected graph without cycles, loops, or multiple edges. In a rooted tree, a selected vertex is called a root. A forest is a collection of one or more trees.\n\n$^{\\text{\u2020}}$ The subtree of a vertex $v$ is the set of vertices for which $v$ lies on the shortest path from this vertex to the root, including $v$ itself.\n\nInput Format:\nEach test consists of multiple test cases. The first line contains an integer $t$ ($1 \\leq t \\leq 10^4$) \u2014 the number of test cases. Then follows the description of the test cases.\n\nThe first line of each test case contains a single integer $k$ ($1 \\leq k \\leq 10^6$) \u2014 the number of trees in the forest.\n\nThis is followed by a description of each of the $k$ trees:\n\nThe first line contains a single integer $n$ ($1 \\leq n \\leq 10^6$) \u2014 the size of the tree. The vertices of the tree are numbered with integers from $1$ to $n$. The root of the tree is vertex number $1$.\n\nThe second line contains $n - 1$ integers $p_2, p_3, \\ldots p_n$ ($1 \\leq p_i < i$), where $p_i$ \u2014 the parent of vertex $i$.\n\nIt is guaranteed that the sum of $k$ and $n$ for all sets of input data does not exceed $10^6$.\n\nOutput Format:\nFor each test case, output a single integer \u2014 the maximum result that can be obtained.\n\nTags:\n['bitmasks', 'greedy', 'math', 'trees']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "3\n1\n1\n\n\n2\n4\n1 2 2\n6\n1 1 3 1 3\n1\n10\n1 2 2 1 1 5 7 6 4",
                "output": "1\n7\n10"
            }
        ]
    },
    {
        "problem": "\nPelican Town represents $n$ houses connected by $m$ bidirectional roads. Some roads have NPCs standing on them. Farmer Buba needs to walk on each road with an NPC and talk to them.\n\nHelp the farmer find a route satisfying the following properties:\n\n  * The route starts at some house, follows the roads, and ends at the same house.    * The route does not follow any road more than once (in both directions together).    * The route follows each road with an NPC exactly once. \n\nNote that the route can follow roads without NPCs, and you do not need to minimize the length of the route.\n\nIt is guaranteed that you can reach any house from any other by walking on the roads with NPCs only.\n\nInput Format:\nEach test consists of multiple test cases. The first line contains an integer $t$ ($1 \\le t \\le 10^{4}$) \u2014 the number of test cases. Then follows the description of the test cases.\n\nThe first line of each test case contains two integers $n$ and $m$ ($2 \\leq n \\leq 5 \\cdot 10^5, 1 \\leq m \\leq 5 \\cdot 10^5$) \u2014 the number of houses and roads in Pelican Town respectively.\n\nIn each of the next $m$ lines, three integers $u$, $v$, and $c$ ($1 \\leq u, v \\leq n, c = 0/1$) are given \u2014 the ends of the road and whether an NPC is on this road. If $c = 1$, then the road has an NPC. If $c = 0$, then the road has no NPC.\n\nThe graph may contain multiple edges and loops, and if there are multiple edges with NPCs standing on them, the route must follow each of these roads.\n\nIt is guaranteed that you can reach any house from any other by walking on the roads with NPCs only.\n\nIt is guaranteed that the sum of $n$ and $m$ for all test cases does not exceed $5 \\cdot 10^5$.\n\nOutput Format:\nFor each test case, if there is no solution, then output \"No\" (without quotes).\n\nOtherwise, output \"Yes\" (without quotes), and then output $k$ \u2014 the number of roads in the route. In the next line, output $k + 1$ numbers \u2014 the houses of the route in the order of traversal. Note that the first house should match the last one, as the route is cyclic.\n\nIf there are multiple answers, you can print any of them.\n\nYou can output each letter in any case (for example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as a positive answer).\n\nTags:\n['constructive algorithms', 'dfs and similar', 'graphs', 'trees']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "3\n3 2\n1 2 1\n2 3 1\n3 3\n1 2 1\n1 3 1\n2 3 0\n5 9\n1 2 0\n5 2 1\n5 4 1\n5 1 1\n2 3 1\n5 2 1\n4 1 0\n4 3 0\n5 2 0",
                "output": "NO\nYES\n3\n1 2 3 1 \nYES\n7\n1 2 5 4 3 2 5 1"
            }
        ]
    },
    {
        "problem": "\nAfter winning another Bed Wars game, Masha and Olya wanted to relax and decided to play a new game. Masha gives Olya an array $a$ of length $n$ and a number $s$. Now Olya's task is to find a non-negative number $x$ such that $\\displaystyle\\sum_{i=1}^{n} a_i \\oplus x = s$. But she is very tired after a tight round, so please help her with this.\n\nBut this task seemed too simple to them, so they decided to make the numbers larger (up to $2^k$) and provide you with their binary representation.\n\nInput Format:\nEach test consists of several test cases. The first line contains a single integer $t$ ($1 \\le t \\le 10^4$) \u2014 the number of test cases. Then follows the description of the test cases.\n\nThe first line of each test case contains two integers $n$ and $k$ ($1 \\le n, k, n \\cdot k \\le 2 \\cdot 10^6$) \u2014 the length of the array $a$ and the length of the binary representation of all numbers.\n\nThe second line contains a string of length $k$, consisting of zeros and ones \u2014 the binary representation of the number $s$, starting from the most significant bits.\n\nThe next $n$ lines also contain strings of length $k$, consisting of zeros and ones, the $i$-th of these strings contains the binary representation of the number $a_i$, starting from the most significant bits.\n\nIt is guaranteed that the sum of the values $n \\cdot k$ for all test cases does not exceed $2 \\cdot 10^6$.\n\nOutput Format:\nFor each test case, output a string of length $k$ on a separate line, consisting of zeros or ones \u2014 the binary representation of any suitable number $x$ ($x \\ge 0$), starting from the most significant bits, or $-1$ if such $x$ does not exist.\n\nTags:\n['bitmasks', 'brute force', 'dp', 'graphs', 'math']\n\nTime Limit: 2000 ms\nMemory Limit: 512 MB\n",
        "tests": [
            {
                "input": "4\n4 5\n01011\n01110\n00110\n01100\n01111\n2 8\n00101001\n10111111\n10011110\n5 4\n0101\n0010\n0000\n0000\n0010\n0011\n6 5\n00011\n10110\n11001\n01010\n11100\n10011\n10000",
                "output": "01110\n10011010\n0010\n-1"
            }
        ]
    },
    {
        "problem": "\nThis is an interactive problem!\n\nTimofey is writing a competition called Capture the Flag (or CTF for short). He has one task left, which involves hacking a security system. The entire system is based on polynomial hashes$^{\\text{\u2217}}$.\n\nTimofey can input a string consisting of lowercase Latin letters into the system, and the system will return its polynomial hash. To hack the system, Timofey needs to find the polynomial hash parameters ($p$ and $m$) that the system uses.\n\nTimofey doesn't have much time left, so he will only be able to make $3$ queries. Help him solve the task.\n\n$^{\\text{\u2217}}$ The polynomial hash of a string $s$, consisting of lowercase Latin letters of length $n$, based on $p$ and modulo $m$ is $(\\mathrm{ord}(s_1) \\cdot p ^ 0 + \\mathrm{ord}(s_2) \\cdot p ^ 1 + \\mathrm{ord}(s_3) \\cdot p ^ 2 + \\ldots + \\mathrm{ord}(s_n) \\cdot p ^ {n - 1}) \\bmod m$. Where $s_i$ denotes the $i$-th character of the string $s$, $\\mathrm{ord}(\\mathrm{chr})$ denotes the ordinal number of the character $\\mathrm{chr}$ in the English alphabet, and $x \\bmod m$ is the remainder of $x$ when divided by $m$.\n\nInput Format:\nEach test consists of multiple test cases. The first line contains an integer $t$ ($1 \\leq t \\leq 10^3$) \u2014 the number of test cases.\n\nIt is guaranteed that the $p$ and $m$ used by the system satisfy the conditions: $26 < p \\leq 50$ and $p + 1 < m \\leq 2 \\cdot 10^9$.\n\nOutput Format:\n\n\nTags:\n['combinatorics', 'constructive algorithms', 'games', 'greedy', 'hashing', 'interactive', 'math', 'number theory', 'strings']\n\nTime Limit: 1000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "1\n\n32\n\n28",
                "output": "? aa\n\n? yb\n\n! 31 59"
            }
        ]
    },
    {
        "problem": "\nVitaly503 is given a checkered board with a side of $n$ and $k$ chips. He realized that all these $k$ chips need to be placed on the cells of the board (no more than one chip can be placed on a single cell).\n\nLet's denote the cell in the $i$-th row and $j$-th column as $(i ,j)$. A diagonal is the set of cells for which the value $i + j$ is the same. For example, cells $(3, 1)$, $(2, 2)$, and $(1, 3)$ lie on the same diagonal, but $(1, 2)$ and $(2, 3)$ do not. A diagonal is called occupied if it contains at least one chip.\n\nDetermine what is the minimum possible number of occupied diagonals among all placements of $k$ chips.\n\nInput Format:\nEach test consists of several sets of input data. The first line contains a single integer $t$ ($1 \\le t \\le 500$) \u2014 the number of sets of input data. Then follow the descriptions of the sets of input data.\n\nThe only line of each set of input data contains two integers $n$, $k$ ($1 \\le n \\le 100, 0 \\le k \\le n^2$) \u2014 the side of the checkered board and the number of available chips, respectively.\n\nOutput Format:\nFor each set of input data, output a single integer \u2014 the minimum number of occupied diagonals with at least one chip that he can get after placing all $k$ chips.\n\nTags:\n['brute force', 'greedy', 'implementation', 'math']\n\nTime Limit: 1000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "7\n1 0\n2 2\n2 3\n2 4\n10 50\n100 239\n3 9",
                "output": "0\n1\n2\n3\n6\n3\n5"
            }
        ]
    },
    {
        "problem": "\nThis is the easy version of the problem. The only difference is that in this version, the flowers are specified by enumeration.\n\nA girl is preparing for her birthday and wants to buy the most beautiful bouquet. There are a total of $n$ flowers in the store, each of which is characterized by the number of petals, and a flower with $k$ petals costs $k$ coins. The girl has decided that the difference in the number of petals between any two flowers she will use in her bouquet should not exceed one. At the same time, the girl wants to assemble a bouquet with the maximum possible number of petals. Unfortunately, she only has $m$ coins, and she cannot spend more. What is the maximum total number of petals she can assemble in the bouquet?\n\nInput Format:\nEach test consists of several test cases. The first line contains a single integer $t$ ($1 \\le t \\le 10\\,000$) \u2014 the number of test cases. This is followed by descriptions of the test cases.\n\nThe first line of each test case contains two integers $n$, $m$ ($1 \\le n \\le 2 \\cdot 10^5, 1 \\le m \\le 10^{18}$) \u2014 the number of flowers in the store and the number of coins the girl possesses, respectively. The second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\le a_i \\le 10^9$), where $a_i$ is the number of petals of the $i$-th flower in the store.\n\nThe sum of $n$ over all test cases does not exceed $2 \\cdot {10}^5$.\n\nOutput Format:\nFor each test case, output a single integer \u2014 the maximum possible number of petals in the bouquet that the girl can assemble while meeting all the conditions listed above.\n\nTags:\n['binary search', 'brute force', 'greedy', 'sortings', 'two pointers']\n\nTime Limit: 1500 ms\nMemory Limit: 512 MB\n",
        "tests": [
            {
                "input": "5\n5 10\n1 1 2 2 3\n8 20\n4 2 7 5 6 1 1 1\n8 100000\n239 30 610 122 24 40 8 2\n11 13\n2 4 11 1 1 2 3 5 4 3 2\n8 1033\n206 206 206 207 207 207 207 1000",
                "output": "7\n13\n610\n13\n1033"
            }
        ]
    },
    {
        "problem": "\nThis is the hard version of the problem. The only difference is that in this version, instead of listing the number of petals for each flower, the number of petals and the quantity of flowers in the store is set for all types of flowers.\n\nA girl is preparing for her birthday and wants to buy the most beautiful bouquet. There are a total of $n$ different types of flowers in the store, each of which is characterized by the number of petals and the quantity of this type of flower. A flower with $k$ petals costs $k$ coins. The girl has decided that the difference in the number of petals between any two flowers she will use to decorate her cake should not exceed one. At the same time, the girl wants to assemble a bouquet with the maximum possible number of petals. Unfortunately, she only has $m$ coins, and she cannot spend more. What is the maximum total number of petals she can assemble in the bouquet?\n\nInput Format:\nEach test consists of several test cases. The first line contains a single integer $t$ ($1 \\le t \\le 10\\,000$) \u2014 the number of test cases. This is followed by descriptions of the test cases.\n\nThe first line of each test case contains two integers $n$, $m$ ($1 \\le n \\le 2 \\cdot 10^5, 1 \\le m \\le 10^{18}$) \u2014 the number of types of flowers in the store and the number of coins the girl possesses, respectively. The second line of each test case contains $n$ different integers $a_1, a_2, \\ldots, a_n$ ($1 \\le a_i \\le 10^9$), where $a_i$ is the number of petals of the $i$-th flower type in the store (for different indexes $i \\neq j$, it must be $a_i \\neq a_j$). The third line of each test case contains $n$ integers $c_1, c_2, \\ldots, c_n$ ($1 \\le c_i \\le 10^9$), where $c_i$ is the quantity of the $i$-th flower type in the store.\n\nThe sum of $n$ over all test cases does not exceed $2 \\cdot {10}^5$.\n\nOutput Format:\nFor each test case, print one integer \u2014 the maximum possible number of petals in a bouquet that a girl can collect, observing all the conditions listed above.\n\nTags:\n['binary search', 'data structures', 'greedy', 'math', 'sortings', 'two pointers']\n\nTime Limit: 1500 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "7\n3 10\n1 2 3\n2 2 1\n3 1033\n206 207 1000\n3 4 1\n6 20\n4 2 7 5 6 1\n1 2 1 3 1 7\n8 100000\n239 30 610 122 24 40 8 2\n12 13123 112 1456 124 100 123 10982\n6 13\n2 4 11 1 3 5\n2 2 1 2 2 1\n8 10330\n206 210 200 201 198 199 222 1000\n9 10 11 12 13 14 15 16\n2 10000000000\n11 12\n87312315 753297050",
                "output": "7\n1033\n19\n99990\n13\n10000\n9999999999"
            }
        ]
    },
    {
        "problem": "\nikrpprpp found an array $a$ consisting of integers. He likes justice, so he wants to make $a$ fair \u2014 that is, make it non-decreasing. To do that, he can perform an act of justice on an index $1 \\le i \\le n$ of the array, which will replace $a_i$ with $a_i ^ 2$ (the element at position $i$ with its square). For example, if $a = [2,4,3,3,5,3]$ and ikrpprpp chooses to perform an act of justice on $i = 4$, $a$ becomes $[2,4,3,9,5,3]$.\n\nWhat is the minimum number of acts of justice needed to make the array non- decreasing?\n\nInput Format:\nFirst line contains an integer $t$ ($1 \\le t \\le 1000$) \u2014 the number of test cases. It is followed by the description of test cases.\n\nFor each test case, the first line contains an integer $n$ \u2014 size of the array $a$. The second line contains $n$ ($1 \\le n \\le 2 \\cdot 10 ^5$) integers $a_1, a_2,\\ldots, a_n$ ($1 \\le a_i \\le 10 ^ 6$).\n\nThe sum of $n$ over all test cases does not exceed $2 \\cdot {10}^5$.\n\nOutput Format:\nFor each testcase, print an integer \u2014 minimum number of acts of justice required to make the array $a$ non-decreasing. If it is impossible to do that, print $-1$.\n\nTags:\n['brute force', 'constructive algorithms', 'greedy', 'implementation', 'math', 'number theory']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "7\n3\n1 2 3\n2\n3 2\n3\n3 1 5\n4\n1 1 2 3\n3\n4 3 2\n9\n16 2 4 2 256 2 4 2 8\n11\n10010 10009 10008 10007 10006 10005 10004 10003 10002 10001 10000",
                "output": "0\n1\n-1\n0\n3\n15\n55"
            }
        ]
    },
    {
        "problem": "\nYou're a linguist studying a mysterious ancient language. You know that\n\n  1. Its words consist only of the first $c$ letters of the Latin alphabet.    2. Each word has a case which can be unambiguously determined by its last letter (different letters correspond to different cases). For example, words \"ABACABA\" and \"ABA\" (if they exist) have the same case in this language because they both have the same ending 'A', whereas \"ALICE\" and \"BOB\" have different cases. If the language does not have a case corresponding to some letter, it means that the word cannot end with this letter.    3. The length of each word is $k$ or less. \n\nYou have a single text written in this language. Unfortunately, as the language is really ancient, spaces between words are missing and all letters are uppercase. You wonder what is the minimum number of cases the language can have. Can you find this out?\n\nInput Format:\nEach test consists of several test cases. The first line contains a single integer $t$ ($1 \\le t \\le 10\\,000$) \u2014 the number of test cases. It is followed by descriptions of the test cases.\n\nThe first line of each test case contains three integers $n$, $c$, $k$ ($1 \\le k \\le n \\le 2^{18}$, $1 \\le c \\le 18$) \u2014 the length of the text, the number of letters in the language, and the maximum length of the word.\n\nThe second line contains a string of $n$ characters \u2014 the text itself. Each character is one of the first $c$ uppercase letters of the Latin alphabet.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2^{18}$ and the sum of $2^c$ over all test cases does not exceed $2^{18}$.\n\nOutput Format:\nFor each test case, output a single line consisting of a single integer \u2014 the minimum number of cases in the language.\n\nTags:\n['bitmasks', 'brute force', 'dp', 'strings']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "7\n5 5 1\nABCDE\n3 1 2\nAAA\n3 2 2\nAAB\n10 2 2\nABABABABAB\n4 4 4\nDCBA\n1 17 1\nQ\n9 3 2\nABCABCABC",
                "output": "5\n1\n2\n1\n1\n1\n2"
            }
        ]
    },
    {
        "problem": "\nThis is the easy version of a problem. The only difference between an easy and a hard version is the constraints on $t$ and $n$. You can make hacks only if both versions of the problem are solved.\n\nArthur is giving a lesson to his famous $2 n$ knights. Like any other students, they're sitting at the desks in pairs, but out of habit in a circle. The knight $2 i - 1$ is sitting at the desk with the knight $2 i$.\n\nEach knight has intelligence, which can be measured by an integer. Let's denote the intelligence of the $i$-th knight as $a_i$. Arthur wants the maximal difference in total intelligence over all pairs of desks to be as small as possible. More formally, he wants to minimize $\\max\\limits_{1 \\le i \\le n} (a_{2 i - 1} + a_{2 i}) - \\min\\limits_{1 \\le i \\le n} (a_{2 i - 1} + a_{2 i})$.\n\nHowever, the Code of Chivalry only allows swapping the opposite knights in the circle, i.e., Arthur can simultaneously perform $a_i := a_{i + n}$, $a_{i + n} := a_i$ for any $1 \\le i \\le n$. Arthur can make any number of such swaps. What is the best result he can achieve?\n\nInput Format:\nEach test consists of several test cases. The first line contains a single integer $t$ ($1 \\le t \\le 1000$) \u2014 the number of test cases. It is followed by descriptions of the test cases.\n\nThe first line of each test case contains a single integer $n$ ($1 \\le n \\le 2000$) \u2014 the number of desks.\n\nThe second line consists of $2n$ integers $a_1, a_2, \\ldots, a_{2 n}$ ($1 \\le a_i \\le 10^9$) \u2014 the intelligence values of the knights.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2000$.\n\nOutput Format:\nFor each test case, output a single line containing one integer \u2014 the minimal difference Arthur can achieve.\n\nTags:\n['2-sat', 'data structures', 'dp', 'matrices', 'two pointers']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "5\n2\n6 6 4 4\n1\n10 17\n3\n1 10 1 10 1 10\n3\n3 3 4 5 5 4\n5\n1 2 3 4 5 6 7 8 9 10",
                "output": "0\n0\n0\n2\n4"
            }
        ]
    },
    {
        "problem": "\nThis is the hard version of a problem. The only difference between an easy and a hard version is the constraints on $t$ and $n$. You can make hacks only if both versions of the problem are solved.\n\nArthur is giving a lesson to his famous $2 n$ knights. Like any other students, they're sitting at the desks in pairs, but out of habit in a circle. The knight $2 i - 1$ is sitting at the desk with the knight $2 i$.\n\nEach knight has intelligence, which can be measured by an integer. Let's denote the intelligence of the $i$-th knight as $a_i$. Arthur wants the maximal difference in total intelligence over all pairs of desks to be as small as possible. More formally, he wants to minimize $\\max\\limits_{1 \\le i \\le n} (a_{2 i - 1} + a_{2 i}) - \\min\\limits_{1 \\le i \\le n} (a_{2 i - 1} + a_{2 i})$.\n\nHowever, the Code of Chivalry only allows swapping the opposite knights in the circle, i.e., Arthur can simultaneously perform $a_i := a_{i + n}$, $a_{i + n} := a_i$ for any $1 \\le i \\le n$. Arthur can make any number of such swaps. What is the best result he can achieve?\n\nInput Format:\nEach test consists of several test cases. The first line contains a single integer $t$ ($1 \\le t \\le 10\\,000$) \u2014 the number of test cases. It is followed by descriptions of the test cases.\n\nThe first line of each test case contains a single integer $n$ ($1 \\le n \\le 100\\,000$) \u2014 the number of desks.\n\nThe second line consists of $2n$ integers $a_1, a_2, \\ldots, a_{2 n}$ ($1 \\le a_i \\le 10^9$) \u2014 the intelligence values of the knights.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $100\\,000$.\n\nOutput Format:\nFor each test case, output a single line containing one integer \u2014 the minimal difference Arthur can achieve.\n\nTags:\n['data structures', 'dp', 'matrices', 'two pointers']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "5\n2\n6 6 4 4\n1\n10 17\n3\n1 10 1 10 1 10\n3\n3 3 4 5 5 4\n5\n1 2 3 4 5 6 7 8 9 10",
                "output": "0\n0\n0\n2\n4"
            }
        ]
    },
    {
        "problem": "\nIt's another beautiful day on Farmer John's farm.\n\nAfter Farmer John arrived at his farm, he counted $n$ legs. It is known only chickens and cows live on the farm, and a chicken has $2$ legs while a cow has $4$.\n\nWhat is the minimum number of animals Farmer John can have on his farm assuming he counted the legs of all animals?\n\nInput Format:\nThe first line contains single integer $t$ ($1 \\leq t \\leq 10^3$) \u2014 the number of test cases.\n\nEach test case contains an integer $n$ ($2 \\leq n \\leq 2 \\cdot 10^3$, $n$ is even).\n\nOutput Format:\nFor each test case, output an integer, the minimum number of animals Farmer John can have on his farm.\n\nTags:\n['binary search', 'math', 'ternary search']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "3\n2\n6\n8",
                "output": "1\n2\n2"
            }
        ]
    },
    {
        "problem": "\nTina has a square grid with $n$ rows and $n$ columns. Each cell in the grid is either $0$ or $1$.\n\nTina wants to reduce the grid by a factor of $k$ ($k$ is a divisor of $n$). To do this, Tina splits the grid into $k \\times k$ nonoverlapping blocks of cells such that every cell belongs to exactly one block.\n\nTina then replaces each block of cells with a single cell equal to the value of the cells in the block. It is guaranteed that every cell in the same block has the same value.\n\nFor example, the following demonstration shows a grid being reduced by factor of $3$.\n\nOriginal grid $0$| $0$| $0$| $1$| $1$| $1$   ---|---|---|---|---|---   $0$| $0$| $0$| $1$| $1$| $1$   $0$| $0$| $0$| $1$| $1$| $1$   $1$| $1$| $1$| $0$| $0$| $0$   $1$| $1$| $1$| $0$| $0$| $0$   $1$| $1$| $1$| $0$| $0$| $0$   Reduced grid $0$| $1$   ---|---   $1$| $0$      Help Tina reduce the grid by a factor of $k$.\n\nInput Format:\nThe first line contains $t$ ($1 \\leq t \\leq 100$) \u2013 the number of test cases.\n\nThe first line of each test case contains two integers $n$ and $k$ ($1 \\leq n \\leq 1000$, $1 \\le k \\le n$, $k$ is a divisor of $n$) \u2014 the number of rows and columns of the grid, and the factor that Tina wants to reduce the grid by.\n\nEach of the following $n$ lines contain $n$ characters describing the cells of the grid. Each character is either $0$ or $1$. It is guaranteed every $k$ by $k$ block has the same value.\n\nIt is guaranteed the sum of $n$ over all test cases does not exceed $1000$.\n\nOutput Format:\nFor each test case, output the grid reduced by a factor of $k$ on a new line.\n\nTags:\n['greedy', 'implementation']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "4\n4 4\n0000\n0000\n0000\n0000\n6 3\n000111\n000111\n000111\n111000\n111000\n111000\n6 2\n001100\n001100\n111111\n111111\n110000\n110000\n8 1\n11111111\n11111111\n11111111\n11111111\n11111111\n11111111\n11111111\n11111111",
                "output": "0\n01\n10\n010\n111\n100\n11111111\n11111111\n11111111\n11111111\n11111111\n11111111\n11111111\n11111111"
            }
        ]
    },
    {
        "problem": "\nYou are given two strings $a$ and $b$ of length $n$. Then, you are (forced against your will) to answer $q$ queries.\n\nFor each query, you are given a range bounded by $l$ and $r$. In one operation, you can choose an integer $i$ ($l \\leq i \\leq r$) and set $a_i = x$ where $x$ is any character you desire. Output the minimum number of operations you must perform such that $\\texttt{sorted(a[l..r])} = \\texttt{sorted(b[l..r])}$. The operations you perform on one query does not affect other queries.\n\nFor an arbitrary string $c$, $\\texttt{sorted(c[l..r])}$ denotes the substring consisting of characters $c_l, c_{l+1}, ... , c_r$ sorted in lexicographical order.\n\nInput Format:\nThe first line contains $t$ ($1 \\leq t \\leq 1000$) \u2013 the number of test cases.\n\nThe first line of each test case contains two integers $n$ and $q$ ($1 \\leq n, q \\leq 2 \\cdot 10^5$) \u2013 the length of both strings and the number of queries.\n\nThe following line contains $a$ of length $n$. It is guaranteed $a$ only contains lowercase latin letters.\n\nThe following line contains $b$ of length $n$. It is guaranteed $b$ only contains lowercase latin letters.\n\nThe following $q$ lines contain two integers $l$ and $r$ ($1 \\leq l \\leq r \\leq n$) \u2013 the range of the query.\n\nIt is guaranteed the sum of $n$ and $q$ over all test cases does not exceed $2 \\cdot 10^5$.\n\nOutput Format:\nFor each query, output an integer, the minimum number of operations you need to perform in a new line.\n\nTags:\n['dp', 'greedy', 'sortings', 'strings']\n\nTime Limit: 5000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "3\n5 3\nabcde\nedcba\n1 5\n1 4\n3 3\n4 2\nzzde\nazbe\n1 3\n1 4\n6 3\nuwuwuw\nwuwuwu\n2 4\n1 3\n1 6",
                "output": "0\n1\n0\n2\n2\n1\n1\n0"
            }
        ]
    },
    {
        "problem": "\nCounting is Fun!\n\n\u2014 satyam343\n\nGiven two integers $n$ and $x$, find the number of triplets ($a,b,c$) of positive integers such that $ab + ac + bc \\le n$ and $a + b + c \\le x$.\n\nNote that order matters (e.g. ($1, 1, 2$) and ($1, 2, 1$) are treated as different) and $a$, $b$, $c$ must be strictly greater than $0$.\n\nInput Format:\nThe first line contains a single integer $t$ ($1 \\leq t \\leq 10^4$)  \u2014 the number of test cases.\n\nEach test case contains two integers $n$ and $x$ ($1 \\leq n,x \\leq 10^6$).\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $10^6$ and that the sum of $x$ over all test cases does not exceed $10^6$.\n\nOutput Format:\nOutput a single integer \u2014 the number of triplets ($a,b,c$) of positive integers such that $ab + ac + bc \\le n$ and $a + b + c \\le x$.\n\nTags:\n['binary search', 'brute force', 'combinatorics', 'math', 'number theory']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "4\n7 4\n10 5\n7 1000\n900000 400000",
                "output": "4\n10\n7\n1768016938"
            }
        ]
    },
    {
        "problem": "\nIn a desperate attempt to obtain your waifu favorite character, you have hacked into the source code of the game. After days of struggling, you finally find the binary string that encodes the gacha system of the game. In order to decode it, you must first solve the following problem.\n\nYou are given a binary string $s$ of length $n$. For each pair of integers $(l, r)$ $(1 \\leq l \\leq r \\leq n)$, count the number of pairs $(x, y)$ $(l \\leq x \\leq y \\leq r)$ such that the amount of $\\mathtt{0}$ equals the amount of $\\mathtt{1}$ in the substring $s_xs_{x+1}...s_y$.\n\nOutput the sum of counts over all possible $(l, r)$ modulo $10^9+7$.\n\nInput Format:\nThe first line contains $t$ ($1 \\leq t \\leq 1000$) \u2014 the number of test cases.\n\nEach test case contains a binary string $s$ ($1 \\leq |s| \\leq 2 \\cdot 10^5$). It is guaranteed $s$ only contains characters $\\mathtt{0}$ and $\\mathtt{1}$.\n\nIt is guaranteed the sum of $|s|$ over all test cases does not exceed $2 \\cdot 10^5$.\n\nOutput Format:\nFor each test case, output an integer, the answer modulo $10^9+7$.\n\nTags:\n['combinatorics', 'data structures', 'implementation', 'math']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "4\n0000\n01010101\n1100111001\n11000000111",
                "output": "0\n130\n147\n70"
            }
        ]
    },
    {
        "problem": "\nSparkle gives you two arrays $a$ and $b$ of length $n$. Initially, your score is $0$. In one operation, you can choose an integer $i$ and add $a_i$ to your score. Then, you must set $a_i$ = $\\max(0, a_i - b_i)$.\n\nYou only have time to perform $k$ operations before Sparkle sets off a nuclear bomb! What is the maximum score you can acquire after $k$ operations?\n\nInput Format:\nThe first line contains $t$ ($1 \\leq t \\leq 1000$) \u2014 the number of test cases.\n\nThe first line of each test case contains $n$ and $k$ ($1 \\leq n \\leq 2 \\cdot 10^5, 1 \\leq k \\leq 10^9$) \u2014 the length of the arrays and the number of operations you can perform.\n\nThe following line contains $n$ integers $a_1, a_2, ... a_n$ ($1 \\leq a_i \\leq 10^9$).\n\nThe following line contains $n$ integers $b_1, b_2, ... b_n$ ($1 \\leq b_i \\leq 10^9$).\n\nIt is guaranteed that the sum of $n$ for all test cases does not exceed $2 \\cdot 10^5$.\n\nOutput Format:\nFor each test case, output an integer, the maximum score you can acquire after $k$ operations.\n\nTags:\n['binary search', 'greedy', 'math']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "5\n3 4\n5 6 7\n2 3 4\n5 9\n32 52 68 64 14\n18 14 53 24 8\n5 1000\n1 2 3 4 5\n5 4 3 2 1\n1 1000000\n1000000\n1\n10 6\n3 3 5 10 6 8 6 8 7 7\n6 1 7 4 1 1 8 9 3 1",
                "output": "21\n349\n27\n500000500000\n47"
            }
        ]
    },
    {
        "problem": "\nOn Penacony, The Land of the Dreams, there exists $n$ houses and $n$ roads. There exists a road between house $i$ and $i+1$ for all $1 \\leq i \\leq n-1$ and a road between house $n$ and house $1$. All roads are bidirectional. However, due to the crisis on Penacony, the overseeing family has gone into debt and may not be able to maintain all roads.\n\nThere are $m$ pairs of friendships between the residents of Penacony. If the resident living in house $a$ is friends with the resident living in house $b$, there must be a path between houses $a$ and $b$ through maintained roads.\n\nWhat is the minimum number of roads that must be maintained?\n\nInput Format:\nThe first line contains $t$ ($1 \\leq t \\leq 10^4$) \u2013 the number of test cases.\n\nThe first line of each test case contains two integers $n$ and $m$ ($3 \\leq n \\leq 2 \\cdot 10^5, 1 \\leq m \\leq 2 \\cdot 10^5$) \u2013 the number of houses and the number of friendships.\n\nThe next $m$ lines contain two integers $a$ and $b$ ($1 \\leq a < b \\leq n$) \u2013 the resident in house $a$ is friends with the resident in house $b$. It is guaranteed all ($a, b$) are distinct.\n\nIt is guaranteed the sum of $n$ and $m$ over all test cases does not exceed $2 \\cdot 10^5$.\n\nOutput Format:\nFor each test case, output an integer, the minimum number of roads that must be maintained.\n\nTags:\n['brute force', 'data structures', 'graphs', 'greedy', 'hashing']\n\nTime Limit: 3000 ms\nMemory Limit: 512 MB\n",
        "tests": [
            {
                "input": "7\n8 3\n1 8\n2 7\n4 5\n13 4\n1 13\n2 12\n3 11\n4 10\n10 2\n2 3\n3 4\n10 4\n3 8\n5 10\n2 10\n4 10\n4 1\n1 3\n5 2\n3 5\n1 4\n5 2\n2 5\n1 3",
                "output": "4\n7\n2\n7\n2\n3\n3"
            }
        ]
    },
    {
        "problem": "\nMonocarp's current password on Codeforces is a string $s$, consisting of lowercase Latin letters. Monocarp thinks that his current password is too weak, so he wants to insert exactly one lowercase Latin letter into the password to make it stronger. Monocarp can choose any letter and insert it anywhere, even before the first character or after the last character.\n\nMonocarp thinks that the password's strength is proportional to the time it takes him to type the password. The time it takes to type the password is calculated as follows:\n\n  * the time to type the first character is $2$ seconds;    * for each character other than the first, the time it takes to type it is $1$ second if it is the same as the previous character, or $2$ seconds otherwise. \n\nFor example, the time it takes to type the password abacaba is $14$; the time it takes to type the password a is $2$; the time it takes to type the password aaabacc is $11$.\n\nYou have to help Monocarp \u2014 insert a lowercase Latin letter into his password so that the resulting password takes the maximum possible amount of time to type.\n\nInput Format:\nThe first line contains one integer $t$ ($1 \\le t \\le 1000$) \u2014 the number of test cases.\n\nEach test case consists of one line containing the string $s$ ($1 \\le |s| \\le 10$), consisting of lowercase Latin letters.\n\nOutput Format:\nFor each test case, print one line containing the new password \u2014 a string which can be obtained from $s$ by inserting one lowercase Latin letter. The string you print should have the maximum possible required time to type it. If there are multiple answers, print any of them.\n\nTags:\n['brute force', 'implementation', 'strings']\n\nTime Limit: 2000 ms\nMemory Limit: 512 MB\n",
        "tests": [
            {
                "input": "4\na\naaa\nabb\npassword",
                "output": "wa\naada\nabcb\npastsword"
            }
        ]
    },
    {
        "problem": "\nThere is a grid, consisting of $2$ rows and $n$ columns. Each cell of the grid is either free or blocked.\n\nA free cell $y$ is reachable from a free cell $x$ if at least one of these conditions holds:\n\n  * $x$ and $y$ share a side;    * there exists a free cell $z$ such that $z$ is reachable from $x$ and $y$ is reachable from $z$. \n\nA connected region is a set of free cells of the grid such that all cells in it are reachable from one another, but adding any other free cell to the set violates this rule.\n\nFor example, consider the following layout, where white cells are free, and dark grey cells are blocked:\n\n![](CDN_BASE_URL/35b42e4e3c64eee3071df3d7b48861e8)\n\nThere are $3$ regions in it, denoted with red, green and blue color respectively:\n\n![](CDN_BASE_URL/b2528153b76de41b1afcd49c1578a191)\n\nThe given grid contains at most $1$ connected region. Your task is to calculate the number of free cells meeting the following constraint:\n\n  * if this cell is blocked, the number of connected regions becomes exactly $3$.\n\nInput Format:\nThe first line contains a single integer $t$ ($1 \\le t \\le 10^4$) \u2014 the number of test cases.\n\nThe first line of each test case contains a single integer $n$ ($1 \\le n \\le 2 \\cdot 10^5$) \u2014 the number of columns.\n\nThe $i$-th of the next two lines contains a description of the $i$-th row of the grid \u2014 the string $s_i$, consisting of $n$ characters. Each character is either . (denoting a free cell) or x (denoting a blocked cell).\n\nAdditional constraint on the input:\n\n  * the given grid contains at most $1$ connected region;    * the sum of $n$ over all test cases doesn't exceed $2 \\cdot 10^5$.\n\nOutput Format:\nFor each test case, print a single integer \u2014 the number of cells such that the number of connected regions becomes $3$ if this cell is blocked.\n\nTags:\n['constructive algorithms', 'two pointers']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "4\n8\n.......x\n.x.xx...\n2\n..\n..\n3\nxxx\nxxx\n9\n..x.x.x.x\nx.......x",
                "output": "1\n0\n0\n2"
            }
        ]
    },
    {
        "problem": "\nMonocarp had a regular bracket sequence $s$ of length $n$ ($n$ is even). He even came up with his own way to calculate its cost.\n\nHe knows that in a regular bracket sequence (RBS), each opening bracket is paired up with the corresponding closing bracket. So he decided to calculate the cost of RBS as the sum of distances between pairs of corresponding bracket pairs.\n\nFor example, let's look at RBS (())(). It has three pairs of brackets:\n\n  * (__)__: the distance between brackets at position $1$ and at $4$ is $4 - 1 = 3$;    * _()___: the distance is $3 - 2 = 1$;    * ____(): the distance is $6 - 5 = 1$. \n\nSo the cost of (())() is $3 + 1 + 1 = 5$.\n\nUnfortunately, due to data corruption, Monocarp lost all characters on odd positions $s_1, s_3, \\dots, s_{n-1}$. Only characters on even positions ($s_2, s_4, \\dots, s_{n}$) remain. For example, (())() turned to _(_)_).\n\nMonocarp wants to restore his RBS by placing brackets on the odd positions. But since the restored RBS may not be unique, he wants to choose one with minimum cost. It's too hard to do for Monocarp alone, so can you help him?\n\nReminder: A regular bracket sequence is a string consisting of only brackets, such that this sequence, when inserted 1-s and +-s, gives a valid mathematical expression. For example, (), (()) or (()())() are RBS, while ), ()( or ())(() are not.\n\nInput Format:\nThe first line contains a single integer $t$ ($1 \\le t \\le 5000$) \u2014 the number of test cases. Next $t$ cases follow.\n\nThe first line of each test case contains a single integer $n$ ($2 \\le n \\le 2 \\cdot 10^5$; $n$ is even) \u2014 the length of string $s$.\n\nThe second line of each test case contains a string $s$ of length $n$, where all characters on the odd positions are '_' and all characters on the even positions are either '(' or ')'.\n\nAdditional constraints:\n\n  * $s$ can be restored to at least one regular bracket sequence;    * the total sum of $n$ over all test cases doesn't exceed $2 \\cdot 10^5$.\n\nOutput Format:\nFor each test case, print one integer \u2014 the minimum cost of the regular bracket sequence that can be obtained from $s$ by replacing '_'-s with brackets.\n\nTags:\n['constructive algorithms', 'data structures', 'greedy']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "4\n6\n_(_)_)\n2\n_)\n8\n_)_)_)_)\n8\n_(_)_(_)",
                "output": "5\n1\n4\n8"
            }
        ]
    },
    {
        "problem": "\nYou are given a rooted tree, consisting of $n$ vertices. The vertices in the tree are numbered from $1$ to $n$, and the root is the vertex $1$. The value $a_i$ is written at the $i$-th vertex.\n\nYou can perform the following operation any number of times (possibly zero): choose a vertex $v$ which has at least one child; increase $a_v$ by $1$; and decrease $a_u$ by $1$ for all vertices $u$ that are in the subtree of $v$ (except $v$ itself). However, after each operation, the values on all vertices should be non-negative.\n\nYour task is to calculate the maximum possible value written at the root using the aforementioned operation.\n\nInput Format:\nThe first line contains a single integer $t$ ($1 \\le t \\le 10^4$) \u2014 the number of test cases.\n\nThe first line of each test case contains a single integer $n$ ($2 \\le n \\le 2 \\cdot 10^5$) \u2014 the number of vertices in the tree.\n\nThe second line contains $n$ integers $a_1, a_2, \\dots, a_n$ ($0 \\le a_i \\le 10^9$) \u2014 the initial values written at vertices.\n\nThe third line contains $n-1$ integers $p_2, p_3, \\dots, p_n$ ($1 \\le p_i \\le n$), where $p_i$ is the parent of the $i$-th vertex in the tree. Vertex $1$ is the root.\n\nAdditional constraint on the input: the sum of $n$ over all test cases doesn't exceed $2 \\cdot 10^5$.\n\nOutput Format:\nFor each test case, print a single integer \u2014 the maximum possible value written at the root using the aforementioned operation.\n\nTags:\n['binary search', 'dfs and similar', 'dp', 'greedy', 'trees']\n\nTime Limit: 3000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "3\n4\n0 1 0 2\n1 1 3\n2\n3 0\n1\n5\n2 5 3 9 6\n3 1 5 2",
                "output": "1\n3\n6"
            }
        ]
    },
    {
        "problem": "\nMonocarp is playing a computer game. He starts the game being level $1$. He is about to fight $n$ monsters, in order from $1$ to $n$. The level of the $i$-th monster is $a_i$.\n\nFor each monster in the given order, Monocarp's encounter goes as follows:\n\n  * if Monocarp's level is strictly higher than the monster's level, the monster flees (runs away);    * otherwise, Monocarp fights the monster. \n\nAfter every $k$-th fight with a monster (fleeing monsters do not count), Monocarp's level increases by $1$. So, his level becomes $2$ after $k$ monsters he fights, $3$ after $2k$ monsters, $4$ after $3k$ monsters, and so on.\n\nYou need to process $q$ queries of the following form:\n\n  * $i~x$: will Monocarp fight the $i$-th monster (or will this monster flee) if the parameter $k$ is equal to $x$?\n\nInput Format:\nThe first line contains two integers $n$ and $q$ ($1 \\le n, q \\le 2 \\cdot 10^5$) \u2014 the number of monsters and the number of queries.\n\nThe second line contains $n$ integers $a_1, a_2, \\dots, a_n$ ($1 \\le a_i \\le 2 \\cdot 10^5$) \u2014 the levels of the monsters.\n\nIn the $j$-th of the following $q$ lines, two integers $i$ and $x$ ($1 \\le i, x \\le n$) \u2014 the index of the monster and the number of fights required for a level up in the $j$-th query.\n\nOutput Format:\nFor each query, output \"YES\", if Monocarp will fight the $i$-th monster in this query, and \"NO\", if the $i$-th monster flees.\n\nTags:\n['binary search', 'brute force', 'data structures', 'divide and conquer', 'implementation']\n\nTime Limit: 4000 ms\nMemory Limit: 512 MB\n",
        "tests": [
            {
                "input": "4 16\n2 1 2 1\n1 1\n2 1\n3 1\n4 1\n1 2\n2 2\n3 2\n4 2\n1 3\n2 3\n3 3\n4 3\n1 4\n2 4\n3 4\n4 4",
                "output": "YES\nNO\nYES\nNO\nYES\nYES\nYES\nNO\nYES\nYES\nYES\nNO\nYES\nYES\nYES\nYES"
            },
            {
                "input": "7 15\n1 1 2 1 1 1 1\n5 3\n2 2\n2 2\n1 6\n5 1\n5 5\n7 7\n3 5\n7 4\n4 3\n2 5\n1 2\n5 6\n4 1\n6 1",
                "output": "NO\nYES\nYES\nYES\nNO\nYES\nYES\nYES\nNO\nNO\nYES\nYES\nYES\nNO\nNO"
            }
        ]
    },
    {
        "problem": "\nYou have $n$ chips, and you are going to place all of them in one of $x$ points, numbered from $1$ to $x$. There can be multiple chips in each point.\n\nAfter placing the chips, you can perform the following four operations (in any order, any number of times):\n\n  * choose a chip in point $i \\ge 3$, remove it and place two chips: one in $i-1$, one in $i-2$;    * choose two chips in adjacent points $i$ and $i+1$, remove them and place a new chip in $i+2$;    * choose a chip in point $1$ and move it to $2$;    * choose a chip in point $2$ and move it to $1$. \n\nNote that the coordinates of the chips you place during the operations cannot be less than $1$, but can be greater than $x$.\n\nDenote the cost of chip placement as the minimum number of chips which can be present on the line after you perform these operations, starting from the placement you've chosen.\n\nFor example, the cost of placing two chips in points $3$ and one chip in point $5$ is $2$, because you can reduce the number of chips to $2$ as follows:\n\n  * choose a chip in point $3$, remove it, place a chip in $1$ and another chip in $2$;    * choose the chips in points $2$ and $3$, remove them and place a chip in $4$;    * choose the chips in points $4$ and $5$, remove them and place a chip in $6$. \n\nYou are given three integers $n$, $x$ and $m$. Calculate the number of placements of exactly $n$ chips in points from $1$ to $x$ having cost equal to $m$, and print it modulo $998244353$. Two placements are considered different if the number of chips in some point differs between these placements.\n\nInput Format:\nThe only line contains three integers $n$, $x$ and $m$ ($1 \\le m \\le n \\le 1000$; $2 \\le x \\le 10$).\n\nOutput Format:\nPrint one integer \u2014 the number of placements with cost equal to $m$, taken modulo $998244353$.\n\nTags:\n['brute force', 'combinatorics', 'dp', 'greedy', 'math']\n\nTime Limit: 5000 ms\nMemory Limit: 512 MB\n",
        "tests": [
            {
                "input": "2 3 1",
                "output": "5"
            },
            {
                "input": "42 10 5",
                "output": "902673363"
            },
            {
                "input": "1000 10 8",
                "output": "187821763"
            }
        ]
    },
    {
        "problem": "\nI couldn't think of a good title for this problem, so I decided to learn from LeetCode.\n\n\u2014 Sun Tzu, The Art of War\n\nYou are given three integers $x_c$, $y_c$, and $k$ ($-100 \\leq x_c, y_c \\leq 100$, $1 \\leq k \\leq 1000$).\n\nYou need to find $k$ distinct points ($x_1, y_1$), ($x_2, y_2$), $\\ldots$, ($x_k, y_k$), having integer coordinates, on the 2D coordinate plane such that:\n\n  * their center$^{\\text{\u2217}}$ is ($x_c, y_c$)    * $-10^9 \\leq x_i, y_i \\leq 10^9$ for all $i$ from $1$ to $k$ \n\nIt can be proven that at least one set of $k$ distinct points always exists that satisfies these conditions.\n\n$^{\\text{\u2217}}$The center of $k$ points ($x_1, y_1$), ($x_2, y_2$), $\\ldots$, ($x_k, y_k$) is $\\left( \\frac{x_1 + x_2 + \\ldots + x_k}{k}, \\frac{y_1 + y_2 + \\ldots + y_k}{k} \\right)$.\n\nInput Format:\nThe first line contains $t$ ($1 \\leq t \\leq 100$) \u2014 the number of test cases.\n\nEach test case contains three integers $x_c$, $y_c$, and $k$ ($-100 \\leq x_c, y_c \\leq 100$, $1 \\leq k \\leq 1000$) \u2014 the coordinates of the center and the number of distinct points you must output.\n\nIt is guaranteed that the sum of $k$ over all test cases does not exceed $1000$.\n\nOutput Format:\nFor each test case, output $k$ lines, the $i$-th line containing two space separated integers, $x_i$ and $y_i$, ($-10^9 \\leq x_i, y_i \\leq 10^9$) \u2014 denoting the position of the $i$-th point.\n\nIf there are multiple answers, print any of them. It can be shown that a solution always exists under the given constraints.\n\nTags:\n['constructive algorithms', 'implementation', 'math']\n\nTime Limit: 1000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "4\n10 10 1\n0 0 3\n-5 -8 8\n4 -5 3",
                "output": "10 10\n-1 -1\n5 -1\n-4 2\n-6 -7\n-5 -7\n-4 -7\n-4 -8\n-4 -9\n-5 -9\n-6 -9\n-6 -8\n1000 -1000\n-996 995\n8 -10"
            }
        ]
    },
    {
        "problem": "\nIt is known that [Farmer John likes Permutations](https://usaco.org/index.php?page=viewproblem2&cpid=1421), but I like them too!\n\n\u2014 Sun Tzu, The Art of Constructing Permutations\n\nYou are given a permutation$^{\\text{\u2217}}$ $p$ of length $n$.\n\nFind a permutation $q$ of length $n$ that minimizes the number of pairs ($i, j$) ($1 \\leq i \\leq j \\leq n$) such that $p_i + p_{i+1} + \\ldots + p_j = q_i + q_{i+1} + \\ldots + q_j$.\n\n$^{\\text{\u2217}}$A permutation of length $n$ is an array consisting of $n$ distinct integers from $1$ to $n$ in arbitrary order. For example, $[2,3,1,5,4]$ is a permutation, but $[1,2,2]$ is not a permutation ($2$ appears twice in the array), and $[1,3,4]$ is also not a permutation ($n=3$ but there is $4$ in the array).\n\nInput Format:\nThe first line contains $t$ ($1 \\leq t \\leq 10^4$) \u2014 the number of test cases.\n\nThe first line of each test case contains $n$ ($1 \\leq n \\leq 2 \\cdot 10^5$).\n\nThe following line contains $n$ space-separated integers $p_1, p_2, \\ldots, p_n$ ($1 \\leq p_i \\leq n$) \u2014 denoting the permutation $p$ of length $n$.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\nOutput Format:\nFor each test case, output one line containing any permutation of length $n$ (the permutation $q$) such that $q$ minimizes the number of pairs.\n\nTags:\n['constructive algorithms', 'math', 'number theory']\n\nTime Limit: 1500 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "3\n2\n1 2\n5\n1 2 3 4 5\n7\n4 7 5 1 2 6 3",
                "output": "2 1\n3 5 4 2 1\n6 2 1 4 7 3 5"
            }
        ]
    },
    {
        "problem": "\nI see satyam343. I'm shaking. Please more median problems this time. I love those. Please satyam343 we believe in you.\n\n\u2014 satyam343's biggest fan\n\nYou are given an array $a$ of length $n$ and an integer $k$. You are also given a binary array $b$ of length $n$.\n\nYou can perform the following operation at most $k$ times:\n\n  * Select an index $i$ ($1 \\leq i \\leq n$) such that $b_i = 1$. Set $a_i = a_i + 1$ (i.e., increase $a_i$ by $1$). \n\nYour score is defined to be $\\max\\limits_{i = 1}^{n} \\left( a_i + \\operatorname{median}(c_i) \\right)$, where $c_i$ denotes the array of length $n-1$ that you get by deleting $a_i$ from $a$. In other words, your score is the maximum value of $a_i + \\operatorname{median}(c_i)$ over all $i$ from $1$ to $n$.\n\nFind the maximum score that you can achieve if you perform the operations optimally.\n\nFor an arbitrary array $p$, $\\operatorname{median}(p)$ is defined as the $\\left\\lfloor \\frac{|p|+1}{2} \\right\\rfloor$-th smallest element of $p$. For example, $\\operatorname{median} \\left( [3,2,1,3] \\right) = 2$ and $\\operatorname{median} \\left( [6,2,4,5,1] \\right) = 4$.\n\nInput Format:\nThe first line contains an integer $t$ ($1 \\leq t \\leq 10^4$) \u2014 the number of test cases.\n\nEach test case begins with two integers $n$ and $k$ ($2 \\leq n \\leq 2 \\cdot 10^5$, $0 \\leq k \\leq 10^9$) \u2014 the length of the $a$ and the number of operations you can perform.\n\nThe following line contains $n$ space separated integers $a_1, a_2, \\ldots, a_n$ ($1 \\leq a_i \\leq 10^9$) \u2014 denoting the array $a$.\n\nThe following line contains $n$ space separated integers $b_1, b_2, \\ldots, b_n$ ($b_i$ is $0$ or $1$) \u2014 denoting the array $b$.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\nOutput Format:\nFor each test case, output the maximum value of score you can get on a new line.\n\nTags:\n['binary search', 'brute force', 'constructive algorithms', 'greedy', 'implementation']\n\nTime Limit: 3000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "8\n2 10\n3 3\n1 1\n3 10\n3 3 3\n0 0 0\n4 4\n2 1 5 1\n0 1 0 1\n5 4\n7 5 2 5 4\n0 0 1 0 1\n5 1\n5 15 15 2 11\n1 0 0 1 1\n5 2\n10 11 4 10 15\n1 1 0 1 0\n4 4\n1 1 2 5\n1 1 0 0\n2 1000000000\n1000000000 1000000000\n1 1",
                "output": "16\n6\n8\n13\n21\n26\n8\n3000000000"
            }
        ]
    },
    {
        "problem": "\nMOOOOOOOOOOOOOOOOO\n\n\u2014 Bessie the Cow, The Art of Racing on Islands\n\nTwo of Farmer John's cows, Bessie and Elsie, are planning to race on $n$ islands. There are $n - 1$ main bridges, connecting island $i$ to island $i + 1$ for all $1 \\leq i \\leq n - 1$. Additionally, there are $m$ alternative bridges. Elsie can use both main and alternative bridges, while Bessie can only use main bridges. All bridges are one way and can only be used to travel from an island with a lower index to an island with a higher index.\n\nInitially, Elsie starts on island $1$, and Bessie starts on island $s$. The cows alternate turns, with Bessie making the first turn. Suppose the cow is on island $i$. During a cow's turn, if there are any bridges connecting island $i$ to island $j$, then the cow can move to island $j$. Then, island $i$ collapses, and all bridges connecting to island $i$ also collapse. Also, note the following:\n\n  * If there are no bridges connecting island $i$ to another island, then island $i$ collapses, and this cow is eliminated from the race.    * If the other cow is also on island $i$, then after this cow moves to another island, the island collapses, and the other cow is eliminated from the race.    * After an island or bridge collapses, no cows may use them.    * If a cow is eliminated, their turn is skipped for the rest of the race. \n\nThe race ends once either cow reaches island $n$. It can be shown that regardless of the cows' strategies, at least one cow reaches island $n$. Bessie wins if and only if she reaches island $n$ first.\n\nFor each $1 \\leq s \\leq n - 1$, determine whether Bessie wins if she starts the race on island $s$. Assume both cows follow optimal strategies to ensure their own respective victories.\n\nInput Format:\nThe first line contains $t$ ($1 \\leq t \\leq 10^4$) \u2013 the number of test cases.\n\nThe first line of each test case contains $n$ and $m$ ($2 \\leq n \\leq 2 \\cdot 10^5$, $0 \\leq m \\leq 2 \\cdot 10^5$) \u2013 the number of islands and the number of alternative bridges.\n\nThe next $m$ lines of each test case contain $u$ and $v$ ($1 \\leq u < v \\leq n$) \u2013 the islands that the alternative bridge connects. It is guaranteed all alternative bridges are distinct, and they do not coincide with the main bridges.\n\nIt is guaranteed that neither the sum of $n$ nor the sum of $m$ over all test cases exceeds $2 \\cdot 10^5$.\n\nOutput Format:\nFor each test case, output a binary string of length $n - 1$ on a new line. The $i$'th character is $1$ if it is possible for Bessie to win if she starts on island $i$. Otherwise, it is $0$.\n\nTags:\n['data structures', 'dp', 'graphs', 'greedy', 'shortest paths']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "5\n6 0\n6 1\n2 6\n6 1\n1 5\n10 4\n1 3\n1 6\n2 7\n3 8\n15 3\n2 8\n4 9\n8 15",
                "output": "11111\n11011\n10011\n100001111\n11000111000111"
            }
        ]
    },
    {
        "problem": "\nDrink water.\n\n\u2014 Sun Tzu, The Art of Becoming a Healthy Programmer\n\nThis is the easy version of the problem. The only difference is that $x=n$ in this version. You must solve both versions to be able to hack.\n\nYou are given two integers $n$ and $x$ ($x=n$). There are $n$ balls lined up in a row, numbered from $1$ to $n$ from left to right. Initially, there is a value $a_i$ written on the $i$-th ball.\n\nFor each integer $i$ from $1$ to $n$, we define a function $f(i)$ as follows:\n\n  * Suppose you have a set $S = \\\\{1, 2, \\ldots, i\\\\}$.\n\n  * In each operation, you have to select an integer $l$ ($1 \\leq l < i$) from $S$ such that $l$ is not the largest element of $S$. Suppose $r$ is the smallest element in $S$ which is greater than $l$.\n\n    * If $a_l > a_r$, you set $a_l = a_l + a_r$ and remove $r$ from $S$.      * If $a_l < a_r$, you set $a_r = a_l + a_r$ and remove $l$ from $S$.      * If $a_l = a_r$, you choose either the integer $l$ or $r$ to remove from $S$:        * If you choose to remove $l$ from $S$, you set $a_r = a_l + a_r$ and remove $l$ from $S$.        * If you choose to remove $r$ from $S$, you set $a_l = a_l + a_r$ and remove $r$ from $S$. \n\n  * $f(i)$ denotes the number of integers $j$ ($1 \\le j \\le i$) such that it is possible to obtain $S = \\\\{j\\\\}$ after performing the above operations exactly $i - 1$ times. \n\nFor each integer $i$ from $x$ to $n$, you need to find $f(i)$.\n\nInput Format:\nThe first line contains $t$ ($1 \\leq t \\leq 10^4$) \u2014 the number of test cases.\n\nThe first line of each test case contains two integers $n$ and $x$ ($1 \\leq n \\leq 2 \\cdot 10^5; x = n$) \u2014 the number of balls and the smallest index $i$ for which you need to find $f(i)$.\n\nThe second line of each test case contains $a_1, a_2, \\ldots, a_n$ ($1 \\leq a_i \\leq 10^9$) \u2014 the initial number written on each ball.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\nOutput Format:\nFor each test case, output $n-x+1$ space separated integers on a new line, where the $j$-th integer should represent $f(x+j-1)$.\n\nTags:\n['binary search', 'brute force', 'data structures', 'divide and conquer', 'greedy']\n\nTime Limit: 4000 ms\nMemory Limit: 512 MB\n",
        "tests": [
            {
                "input": "3\n5 5\n1 2 3 2 1\n7 7\n4 5 1 2 1 4 5\n11 11\n1 2 3 1 1 9 3 2 4 1 3",
                "output": "3\n4\n4"
            }
        ]
    },
    {
        "problem": "\nDrink water.\n\n\u2014 Sun Tzu, The Art of Becoming a Healthy Programmer\n\nThis is the hard version of the problem. The only difference is that $x=1$ in this version. You must solve both versions to be able to hack.\n\nYou are given two integers $n$ and $x$ ($x=1$). There are $n$ balls lined up in a row, numbered from $1$ to $n$ from left to right. Initially, there is a value $a_i$ written on the $i$-th ball.\n\nFor each integer $i$ from $1$ to $n$, we define a function $f(i)$ as follows:\n\n  * Suppose you have a set $S = \\\\{1, 2, \\ldots, i\\\\}$.\n\n  * In each operation, you have to select an integer $l$ ($1 \\leq l < i$) from $S$ such that $l$ is not the largest element of $S$. Suppose $r$ is the smallest element in $S$ which is greater than $l$.\n\n    * If $a_l > a_r$, you set $a_l = a_l + a_r$ and remove $r$ from $S$.      * If $a_l < a_r$, you set $a_r = a_l + a_r$ and remove $l$ from $S$.      * If $a_l = a_r$, you choose either the integer $l$ or $r$ to remove from $S$:        * If you choose to remove $l$ from $S$, you set $a_r = a_l + a_r$ and remove $l$ from $S$.        * If you choose to remove $r$ from $S$, you set $a_l = a_l + a_r$ and remove $r$ from $S$. \n\n  * $f(i)$ denotes the number of integers $j$ ($1 \\le j \\le i$) such that it is possible to obtain $S = \\\\{j\\\\}$ after performing the above operations exactly $i - 1$ times. \n\nFor each integer $i$ from $x$ to $n$, you need to find $f(i)$.\n\nInput Format:\nThe first line contains $t$ ($1 \\leq t \\leq 10^4$) \u2014 the number of test cases.\n\nThe first line of each test case contains two integers $n$ and $x$ ($1 \\leq n \\leq 2 \\cdot 10^5; x = 1$) \u2014 the number of balls and the smallest index $i$ for which you need to find $f(i)$.\n\nThe second line of each test case contains $a_1, a_2, \\ldots, a_n$ ($1 \\leq a_i \\leq 10^9$) \u2014 the initial number written on each ball.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\nOutput Format:\nFor each test case, output $n-x+1$ space separated integers on a new line, where the $j$-th integer should represent $f(x+j-1)$.\n\nTags:\n['binary search', 'brute force', 'data structures', 'divide and conquer', 'greedy', 'implementation']\n\nTime Limit: 4000 ms\nMemory Limit: 512 MB\n",
        "tests": [
            {
                "input": "3\n5 1\n1 2 3 2 1\n7 1\n4 5 1 2 1 4 5\n11 1\n1 2 3 1 1 9 3 2 4 1 3",
                "output": "1 1 2 2 3\n1 1 1 1 1 3 4\n1 1 2 2 2 1 1 1 3 3 4"
            }
        ]
    },
    {
        "problem": "\nGiven a two-digit positive integer $n$, find the sum of its digits.\n\nInput Format:\nThe first line contains an integer $t$ ($1 \\leq t \\leq 90$) \u2014 the number of test cases.\n\nThe only line of each test case contains a single two-digit positive integer $n$ ($10 \\leq n \\leq 99$).\n\nOutput Format:\nFor each test case, output a single integer \u2014 the sum of the digits of $n$.\n\nTags:\n['implementation', 'math']\n\nTime Limit: 1000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "8\n77\n21\n40\n34\n19\n84\n10\n99",
                "output": "14\n3\n4\n7\n10\n12\n1\n18"
            }
        ]
    },
    {
        "problem": "\nSuneet and Slavic play a card game. The rules of the game are as follows:\n\n  * Each card has an integer value between $1$ and $10$.    * Each player receives $2$ cards which are face-down (so a player doesn't know their cards).    * The game is turn-based and consists exactly of two turns. In a round, both players pick a random unflipped card and flip it. The player who flipped a card with a strictly greater number wins the round. In case of equality, no one wins the round.    * A player wins a game if he wins the most number of rounds (i.e. strictly greater than the other player). In case of equality, no one wins the game. \n\nSince Suneet and Slavic aren't best friends, you need to calculate the number of ways the game could happen that Suneet would end up as the winner.\n\nFor a better understanding, please check the notes section.\n\nInput Format:\nThe first line contains an integer $t$ ($1 \\leq t \\leq 10^4$) \u2014 the number of test cases.\n\nThe first and only line of each test case contains $4$ integers $a_1$, $a_2$, $b_1$, $b_2$ ($1 \\leq a_1, a_2, b_1, b_2 \\leq 10$) where $a_1$ and $a_2$ represent the cards Suneet has, and $b_1$ and $b_2$ represent the cards Slavic has, respectively.\n\nOutput Format:\nFor each test case, output a single integer \u2014 the number of games Suneet would win considering all possible games.\n\nTags:\n['brute force', 'constructive algorithms', 'implementation']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "5\n3 8 2 6\n1 1 1 1\n10 10 2 2\n1 1 10 10\n3 8 7 2",
                "output": "2\n0\n4\n0\n2"
            }
        ]
    },
    {
        "problem": "\nAs a computer science student, Alex faces a hard challenge \u2014 showering. He tries to shower daily, but despite his best efforts there are always challenges. He takes $s$ minutes to shower and a day only has $m$ minutes!\n\nHe already has $n$ tasks planned for the day. Task $i$ is represented as an interval $(l_i$, $r_i)$, which means that Alex is busy and can not take a shower in that time interval (at any point in time strictly between $l_i$ and $r_i$). No two tasks overlap.\n\nGiven all $n$ time intervals, will Alex be able to shower that day? In other words, will Alex have a free time interval of length at least $s$?\n\n![](CDN_BASE_URL/5d5195053b99e5c6936ccefadc239679)\n\nIn the first test case, Alex can shower for the first $3$ minutes of the day and not miss any of the tasks.\n\nInput Format:\nThe first line contains a single integer $t$ ($1 \\leq t \\leq 10^4$) \u2014 the number of test cases.\n\nThe first line of each test case contains three integers $n$, $s$, and $m$ ($1 \\leq n \\leq 2 \\cdot 10^5$; $1 \\leq s, m \\leq 10^9$) \u2014 the number of time intervals Alex already has planned, the amount of time Alex takes to take a shower, and the amount of minutes a day has.\n\nThen $n$ lines follow, the $i$-th of which contains two integers $l_i$ and $r_i$ ($0 \\leq l_i < r_i \\leq m$) \u2014 the time interval of the $i$-th task. No two tasks overlap.\n\nAdditional constraint on the input: $l_i > r_{i-1}$ for every $i > 1$.\n\nThe sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\nOutput Format:\nFor each test case output \"YES\" (without quotes) if Alex can take a shower for that given test case, and \"NO\" (also without quotes) otherwise.\n\nYou can output \"YES\" and \"NO\" in any case (for example, strings \"yEs\", \"yes\", and \"Yes\" will be recognized as a positive response).\n\nTags:\n['greedy', 'implementation']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "4\n3 3 10\n3 5\n6 8\n9 10\n3 3 10\n1 2\n3 5\n6 7\n3 3 10\n1 2\n3 5\n6 8\n3 4 10\n1 2\n6 7\n8 9",
                "output": "YES\nYES\nNO\nYES"
            }
        ]
    },
    {
        "problem": "\nSlavic has a very tough exam and needs your help in order to pass it. Here is the question he is struggling with:\n\nThere exists a string $s$, which consists of lowercase English letters and possibly zero or more \"?\".\n\nSlavic is asked to change each \"?\" to a lowercase English letter such that string $t$ becomes a subsequence (not necessarily continuous) of the string $s$.\n\nOutput any such string, or say that it is impossible in case no string that respects the conditions exists.\n\nInput Format:\nThe first line contains a single integer $T$ ($1 \\leq T \\leq 10^4$) \u2014 the number of test cases.\n\nThe first line of each test case contains a single string $s$ ($1 \\leq |s| \\leq 2 \\cdot 10^5$, and $s$ consists only of lowercase English letters and \"?\"-s)  \u2013 the original string you have.\n\nThe second line of each test case contains a single string $t$ ($1 \\leq |t| \\leq |s|$, and $t$ consists only of lowercase English letters)  \u2013 the string that should be a subsequence of string $s$.\n\nThe sum of $|s|$ over all test cases doesn't exceed $2 \\cdot 10^5$, where $|x|$ denotes the length of the string $x$.\n\nOutput Format:\nFor each test case, if no such string exists as described in the statement, output \"NO\" (without quotes).\n\nOtherwise, output \"YES\" (without quotes). Then, output one line \u2014 the string that respects all conditions.\n\nYou can output \"YES\" and \"NO\" in any case (for example, strings \"yEs\", \"yes\", and \"Yes\" will be recognized as a positive response).\n\nIf multiple answers are possible, you can output any of them.\n\nTags:\n['greedy', 'implementation', 'strings']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "5\n?????\nxbx\nab??e\nabcde\nayy?x\na\nab??e\ndac\npaiu\nmom",
                "output": "YES\nxabax\nYES\nabcde\nYES\nayyyx\nNO\nNO"
            }
        ]
    },
    {
        "problem": "\nOn the board Ivy wrote down all integers from $l$ to $r$, inclusive.\n\nIn an operation, she does the following:\n\n  * pick two numbers $x$ and $y$ on the board, erase them, and in their place write the numbers $3x$ and $\\lfloor \\frac{y}{3} \\rfloor$. (Here $\\lfloor \\bullet \\rfloor$ denotes rounding down to the nearest integer).\n\nWhat is the minimum number of operations Ivy needs to make all numbers on the board equal $0$? We have a proof that this is always possible.\n\nInput Format:\nThe first line contains an integer $t$ ($1 \\leq t \\leq 10^4$) \u2014 the number of test cases.\n\nThe only line of each test case contains two integers $l$ and $r$ ($1 \\leq l < r \\leq 2 \\cdot 10^5$).\n\nOutput Format:\nFor each test case, output a single integer \u2014 the minimum number of operations needed to make all numbers on the board equal $0$.\n\nTags:\n['dp', 'implementation', 'math']\n\nTime Limit: 1000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "4\n1 3\n2 4\n199999 200000\n19 84",
                "output": "5\n6\n36\n263"
            }
        ]
    },
    {
        "problem": "\nArul has a binary array$^{\\text{\u2217}}$ $a$ of length $n$.\n\nHe will take all subsequences$^{\\text{\u2020}}$ of length $k$ ($k$ is odd) of this array and find their median.$^{\\text{\u2021}}$\n\nWhat is the sum of all these values?\n\nAs this sum can be very large, output it modulo $10^9 + 7$. In other words, print the remainder of this sum when divided by $10^9 + 7$.\n\n$^{\\text{\u2217}}$A binary array is an array consisting only of zeros and ones.\n\n$^{\\text{\u2020}}$An array $b$ is a subsequence of an array $a$ if $b$ can be obtained from $a$ by the deletion of several (possibly, zero or all) elements. Subsequences don't have to be contiguous.\n\n$^{\\text{\u2021}}$The median of an array of odd length $k$ is the $\\frac{k+1}{2}$-th element when sorted.\n\nInput Format:\nThe first line contains a single integer $t$ ($1 \\leq t \\leq 10^4$) \u2014 the number of test cases.\n\nThe first line of each test case contains two integers $n$ and $k$ ($1 \\leq k \\leq n \\leq 2 \\cdot 10^5$, $k$ is odd) \u2014 the length of the array and the length of the subsequence, respectively.\n\nThe second line of each test case contains $n$ integers $a_i$ ($0 \\leq a_i \\leq 1$) \u2014 the elements of the array.\n\nIt is guaranteed that sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\nOutput Format:\nFor each test case, print the sum modulo $10^9 + 7$.\n\nTags:\n['combinatorics', 'math']\n\nTime Limit: 3000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "8\n4 3\n1 0 0 1\n5 1\n1 1 1 1 1\n5 5\n0 1 0 1 0\n6 3\n1 0 1 0 1 1\n4 3\n1 0 1 1\n5 3\n1 0 1 1 0\n2 1\n0 0\n34 17\n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1",
                "output": "2\n5\n0\n16\n4\n7\n0\n333606206"
            }
        ]
    },
    {
        "problem": "\nThis is the easy version of the problem. The only difference between the two versions is that in this version, you can make at most $\\mathbf{10}$ queries.\n\nThis is an interactive problem. If you are unsure how interactive problems work, then it is recommended to read [the guide for participants](https://codeforces.com/blog/entry/45307).\n\nWe have a secret ruler that is missing one number $x$ ($2 \\leq x \\leq 999$). When you measure an object of length $y$, the ruler reports the following values:\n\n  * If $y < x$, the ruler (correctly) measures the object as having length $y$.    * If $y \\geq x$, the ruler incorrectly measures the object as having length $y+1$. \n\n![](CDN_BASE_URL/f2ba8b56cc626dab02991bcad6d908b8)\n\nThe ruler above is missing the number $4$, so it correctly measures the first segment as length $3$ but incorrectly measures the second segment as length $6$ even though it is actually $5$.\n\nYou need to find the value of $x$. To do that, you can make queries of the following form:\n\n  * $\\texttt{?}~a~b$ \u2014 in response, we will measure the side lengths of an $a \\times b$ rectangle with our ruler and multiply the results, reporting the measured area of the rectangle back to you. For example, if $x=4$ and you query a $3 \\times 5$ rectangle, we will measure its side lengths as $3 \\times 6$ and report $18$ back to you. \n\nFind the value of $x$. You can ask at most $\\mathbf{10}$ queries.\n\nInput Format:\nEach test contains multiple test cases. The first line of input contains a single integer $t$ ($1 \\leq t \\leq 1000$) \u2014 the number of test cases.\n\nOutput Format:\n\n\nTags:\n['binary search', 'interactive']\n\nTime Limit: 1000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "2\n\n18\n\n25\n\n\n9999",
                "output": "? 3 5\n\n? 4 4\n\n! 4\n? 99 100\n\n! 100"
            }
        ]
    },
    {
        "problem": "\nThis is the hard version of the problem. The only difference between the two versions is that in this version, you can make at most $\\mathbf{7}$ queries.\n\nThis is an interactive problem. If you are unsure how interactive problems work, then it is recommended to read [the guide for participants](https://codeforces.com/blog/entry/45307).\n\nWe have a secret ruler that is missing one number $x$ ($2 \\leq x \\leq 999$). When you measure an object of length $y$, the ruler reports the following values:\n\n  * If $y < x$, the ruler (correctly) measures the object as having length $y$.    * If $y \\geq x$, the ruler incorrectly measures the object as having length $y+1$. \n\n![](CDN_BASE_URL/f2ba8b56cc626dab02991bcad6d908b8)\n\nThe ruler above is missing the number $4$, so it correctly measures the first segment as length $3$ but incorrectly measures the second segment as length $6$ even though it is actually $5$.\n\nYou need to find the value of $x$. To do that, you can make queries of the following form:\n\n  * $\\texttt{?}~a~b$ \u2014 in response, we will measure the side lengths of an $a \\times b$ rectangle with our ruler and multiply the results, reporting the measured area of the rectangle back to you. For example, if $x=4$ and you query a $3 \\times 5$ rectangle, we will measure its side lengths as $3 \\times 6$ and report $18$ back to you. \n\nFind the value of $x$. You can ask at most $\\mathbf{7}$ queries.\n\nInput Format:\nEach test contains multiple test cases. The first line of input contains a single integer $t$ ($1 \\leq t \\leq 1000$) \u2014 the number of test cases.\n\nOutput Format:\n\n\nTags:\n['binary search', 'interactive', 'ternary search']\n\nTime Limit: 1000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "2\n\n18\n\n25\n\n\n9999",
                "output": "? 3 5\n\n? 4 4\n\n! 4\n? 99 100\n\n! 100"
            }
        ]
    },
    {
        "problem": "\nDmitry wrote down $t$ integers on the board, and that is good. He is sure that he lost an important integer $n$ among them, and that is bad.\n\nThe integer $n$ had the form $\\text{10^x}$ ($x \\ge 2$), where the symbol '$\\text{^}$' denotes exponentiation.. Something went wrong, and Dmitry missed the symbol '$\\text{^}$' when writing the important integer. For example, instead of the integer $10^5$, he would have written $105$, and instead of $10^{19}$, he would have written $1019$.\n\nDmitry wants to understand which of the integers on the board could have been the important integer and which could not.\n\nInput Format:\nThe first line of the input contains one integer $t$ ($1 \\le t \\le 10^4$) \u2014 the number of integers on the board.\n\nThe next $t$ lines each contain an integer $a$ ($1 \\le a \\le 10000$) \u2014 the next integer from the board.\n\nOutput Format:\nFor each integer on the board, output \"YES\" if it could have been the important integer and \"NO\" otherwise.\n\nYou may output each letter in any case (lowercase or uppercase). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be accepted as a positive answer.\n\nTags:\n['implementation', 'math', 'strings']\n\nTime Limit: 1000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "7\n100\n1010\n101\n105\n2033\n1019\n1002",
                "output": "NO\nYES\nNO\nYES\nNO\nYES\nNO"
            }
        ]
    },
    {
        "problem": "\nIn Berland, a bus consists of a row of $n$ seats numbered from $1$ to $n$. Passengers are advised to always board the bus following these rules:\n\n  * If there are no occupied seats in the bus, a passenger can sit in any free seat;   * Otherwise, a passenger should sit in any free seat that has at least one occupied neighboring seat. In other words, a passenger can sit in a seat with index $i$ ($1 \\le i \\le n$) only if at least one of the seats with indices $i-1$ or $i+1$ is occupied. \n\nToday, $n$ passengers boarded the bus. The array $a$ chronologically records the seat numbers they occupied. That is, $a_1$ contains the seat number where the first passenger sat, $a_2$ \u2014 the seat number where the second passenger sat, and so on.\n\nYou know the contents of the array $a$. Determine whether all passengers followed the recommendations.\n\nFor example, if $n = 5$, and $a$ = [$5, 4, 2, 1, 3$], then the recommendations were not followed, as the $3$-rd passenger sat in seat number $2$, while the neighboring seats with numbers $1$ and $3$ were free.\n\nInput Format:\nThe first line of input contains a single integer $t$ ($1 \\le t \\le 10^4$) \u2014 the number of test cases.\n\nThe following describes the input test cases.\n\nThe first line of each test case contains exactly one integer $n$ ($1 \\le n \\le 2 \\cdot 10^5$) \u2014 the number of seats in the bus and the number of passengers who boarded the bus.\n\nThe second line of each test case contains $n$ distinct integers $a_i$ ($1 \\le a_i \\le n$) \u2014 the seats that the passengers occupied in chronological order.\n\nIt is guaranteed that the sum of $n$ values across all test cases does not exceed $2 \\cdot 10^5$, and that no passenger sits in an already occupied seat.\n\nOutput Format:\nFor each test case, output on a separate line:\n\n  * \"YES\", if all passengers followed the recommendations;    * \"NO\" otherwise. \n\nYou may output the answer in any case (for example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as a positive answer).\n\nTags:\n['two pointers']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "4\n5\n5 4 2 1 3\n3\n2 3 1\n4\n2 3 1 4\n5\n1 2 3 5 4",
                "output": "NO\nYES\nYES\nNO"
            }
        ]
    },
    {
        "problem": "\nKristina has an array $a$, called a template, consisting of $n$ integers. She also has $m$ strings, each consisting only of lowercase Latin letters. The strings are numbered from $1$ to $m$. She wants to check which strings match the template.\n\nA string $s$ is considered to match the template if all of the following conditions are simultaneously satisfied:\n\n  * The length of the string $s$ is equal to the number of elements in the array $a$.   * The same numbers from $a$ correspond to the same symbols from $s$. So, if $a_i = a_j$, then $s_i = s_j$ for ($1 \\le i, j \\le n$).   * The same symbols from $s$ correspond to the same numbers from $a$. So, if $s_i = s_j$, then $a_i = a_j$ for ($1 \\le i, j \\le n$).\n\nIn other words, there must be a one-to-one correspondence between the characters of the string and the elements of the array.\n\nFor example, if $a$ = [$3, 5, 2, 1, 3$], then the string \"abfda\" matches the template, while the string \"afbfa\" does not, since the character \"f\" corresponds to both numbers $1$ and $5$.\n\nInput Format:\nThe first line of input contains a single integer $t$ ($1 \\le t \\le 10^4$) \u2014 the number of test cases.\n\nThe following descriptions are for the test cases.\n\nThe first line of each test case contains a single integer $n$ ($1 \\le n \\le 2 \\cdot 10^5$) \u2014 the number of elements in the array $a$.\n\nThe second line of each test case contains exactly $n$ integers $a_i$ ($-10^9 \\le a_i \\le 10^9$) \u2014 the elements of the array $a$.\n\nThe third line of each test case contains a single integer $m$ ($1 \\le m \\le 2 \\cdot 10^5$) \u2014 the number of strings to check for template matching.\n\nFollowing are $m$ strings, each containing a non-empty string $s_j$ ($1 \\le |s_j| \\le 2 \\cdot 10^5$), consisting of lowercase Latin letters.\n\nIt is guaranteed that the sum of $n$ across all test cases does not exceed $2 \\cdot 10^5$, and that the sum of the lengths of all strings does not exceed $2 \\cdot 10^5$.\n\nOutput Format:\nFor each test case, output $m$ lines. On the $i$-th line ($1 \\le i \\le m$) output:\n\n  * \"YES\", if the string with index $i$ matches the template;    * \"NO\" otherwise. \n\nYou may output the answer in any case (for example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as a positive answer).\n\nTags:\n['data structures', 'strings']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "3\n5\n3 5 2 1 3\n2\nabfda\nafbfa\n2\n1 2\n3\nab\nabc\naa\n4\n5 -3 5 -3\n4\naaaa\nbcbc\naba\ncbcb",
                "output": "YES\nNO\nYES\nNO\nNO\nNO\nYES\nNO\nYES"
            }
        ]
    },
    {
        "problem": "\nVlad found a strip of $n$ cells, numbered from left to right from $1$ to $n$. In the $i$-th cell, there is a positive integer $a_i$ and a letter $s_i$, where all $s_i$ are either 'L' or 'R'.\n\nVlad invites you to try to score the maximum possible points by performing any (possibly zero) number of operations.\n\nIn one operation, you can choose two indices $l$ and $r$ ($1 \\le l < r \\le n$) such that $s_l$ = 'L' and $s_r$ = 'R' and do the following:\n\n  * add $a_l + a_{l + 1} + \\dots + a_{r - 1} + a_r$ points to the current score;    * replace $s_i$ with '.' for all $l \\le i \\le r$, meaning you can no longer choose these indices. \n\nFor example, consider the following strip:\n\n$3$| $5$| $1$| $4$| $3$| $2$   ---|---|---|---|---|---   L| R| L| L| L| R      You can first choose $l = 1$, $r = 2$ and add $3 + 5 = 8$ to your score.\n\n$3$| $5$| $1$| $4$| $3$| $2$   ---|---|---|---|---|---   .| .| L| L| L| R      Then choose $l = 3$, $r = 6$ and add $1 + 4 + 3 + 2 = 10$ to your score.\n\n$3$| $5$| $1$| $4$| $3$| $2$   ---|---|---|---|---|---   .| .| .| .| .| .      As a result, it is impossible to perform another operation, and the final score is $18$.\n\nWhat is the maximum score that can be achieved?\n\nInput Format:\nThe first line contains one integer $t$ ($1 \\le t \\le 10^4$) \u2014 the number of test cases.\n\nThe first line of each test case contains one integer $n$ ($2 \\le n \\le 2 \\cdot 10^5$) \u2014 the length of the strip.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\dots, a_n$ ($1 \\le a_i \\le 10^5$) \u2014 the numbers written on the strip.\n\nThe third line of each test case contains a string $s$ of $n$ characters 'L' and 'R'.\n\nIt is guaranteed that the sum of the values of $n$ across all test cases does not exceed $2 \\cdot 10^5$.\n\nOutput Format:\nFor each test case, output one integer \u2014 the maximum possible number of points that can be scored.\n\nTags:\n['greedy', 'implementation', 'two pointers']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "4\n6\n3 5 1 4 3 2\nLRLLLR\n2\n2 8\nLR\n2\n3 9\nRL\n5\n1 2 3 4 5\nLRLRR",
                "output": "18\n10\n0\n22"
            }
        ]
    },
    {
        "problem": "\nYou really love gorillas, so you decided to organize a photoshoot for them. Gorillas live in the jungle. The jungle is represented as a grid of $n$ rows and $m$ columns. $w$ gorillas agreed to participate in the photoshoot, and the gorilla with index $i$ ($1 \\le i \\le w$) has a height of $a_i$. You want to place all the gorillas in the cells of the grid such that there is no more than one gorilla in each cell.\n\nThe spectacle of the arrangement is equal to the sum of the spectacles of all sub-squares of the grid with a side length of $k$.\n\nThe spectacle of a sub-square is equal to the sum of the heights of the gorillas in it.\n\nFrom all suitable arrangements, choose the arrangement with the maximum spectacle.\n\nInput Format:\nThe first line contains an integer $t$ ($1 \\le t \\le 10^3$) \u2014 the number of test cases.\n\nThe descriptions of the test cases follow.\n\nThe first line contains integers $n$, $m$, $k$ ($1 \\le n, m \\le 2 \\cdot 10^5$, $1 \\le n \\cdot m \\le 2 \\cdot 10^5$, $1 \\le k \\le \\min(n, m)$) \u2014 the dimensions of the grid and the side length of the square.\n\nThe second line contains an integer $w$ ($1 \\le w \\le n \\cdot m$) \u2014 the number of gorillas.\n\nThe third line contains $w$ integers $a_1, a_2, \\ldots, a_w$ ($1 \\le a_i \\le 10^9$) \u2014 the heights of the gorillas.\n\nIt is guaranteed that the sum of $n \\cdot m$ across all test cases does not exceed $2 \\cdot 10^5$. The same guarantee applies to $w$.\n\nOutput Format:\nFor each test case, output a single integer \u2014 the maximum spectacle of a suitable arrangement.\n\nTags:\n['combinatorics', 'data structures', 'greedy', 'math']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "5\n3 4 2\n9\n1 1 1 1 1 1 1 1 1\n2 1 1\n2\n5 7\n20 15 7\n9\n4 1 4 5 6 1 1000000000 898 777\n1984 1 1\n4\n5 4 1499 2004\n9 5 5\n6\n6 7 14 16 16 6",
                "output": "21\n12\n49000083104\n3512\n319"
            }
        ]
    },
    {
        "problem": "\nYou have $n$ rectangles, the $i$-th of which has a width of $a_i$ and a height of $b_i$.\n\nYou can perform the following operation an unlimited number of times: choose a rectangle and a cell in it, and then color it.\n\nEach time you completely color any row or column, you earn $1$ point. Your task is to score at least $k$ points with as few operations as possible.\n\nSuppose you have a rectangle with a width of $6$ and a height of $3$. You can score $4$ points by coloring all the cells in any $4$ columns, thus performing $12$ operations.\n\nInput Format:\nThe first line contains an integer $t$ ($1 \\le t \\le 100$) \u2014 the number of test cases. The following are the descriptions of the test cases.\n\nThe first line of each test case description contains two integers $n$ and $k$ ($1 \\le n \\le 1000, 1 \\le k \\le 100$) \u2014 the number of rectangles in the case and the required number of points.\n\nThe next $n$ lines contain the descriptions of the rectangles. The $i$-th line contains two integers $a_i$ and $b_i$ ($1 \\le a_i, b_i \\le 100$) \u2014 the width and height of the $i$-th rectangle.\n\nIt is guaranteed that the sum of the values of $n$ across all test cases does not exceed $1000$.\n\nOutput Format:\nFor each test case, output a single integer \u2014 the minimum number of operations required to score at least $k$ points. If it is impossible to score at least $k$ points, output -1.\n\nTags:\n['dp', 'greedy', 'implementation', 'math']\n\nTime Limit: 3000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "7\n1 4\n6 3\n1 5\n4 4\n5 10\n1 1\n1 1\n1 1\n1 1\n1 1\n2 100\n1 2\n5 6\n3 11\n2 2\n3 3\n4 4\n3 25\n9 2\n4 3\n8 10\n4 18\n5 4\n8 5\n8 3\n6 2",
                "output": "12\n14\n5\n-1\n17\n80\n35"
            }
        ]
    },
    {
        "problem": "\nYou live in a city consisting of $n$ intersections and $m$ streets connecting some pairs of intersections. You can travel in either direction on each street. No two streets connect the same pair of intersections, and no street connects an intersection to itself. You can reach any intersection from any other, possibly passing through some other intersections.\n\nEvery minute, you can board a bus at intersection $u_i$ and travel for $l_{i1}$ minutes to intersection $v_i$. Conversely, you can travel from intersection $v_i$ to intersection $u_i$ in $l_{i1}$ minutes. You can only board and exit the bus at intersections. You can only board the bus at an intersection if you are currently there.\n\nYou can also walk along each street, which takes $l_{i2} > l_{i1}$ minutes.\n\nYou can make stops at intersections.\n\nYou live at intersection number $1$. Today you woke up at time $0$, and you have an important event scheduled at intersection number $n$, which you must reach no later than time $t_0$. You also have a phone call planned that will last from $t_1$ to $t_2$ minutes ($t_1 < t_2 < t_0$).\n\nDuring the phone call, you cannot ride the bus, but you can walk along any streets, make stops, or stay at home. You can exit the bus at minute $t_1$ and board the bus again at minute $t_2$.\n\nSince you want to get enough sleep, you became curious \u2014 how late can you leave home to have time to talk on the phone and still not be late for the event?\n\nInput Format:\nThe first line contains an integer $t$ ($1 \\le t \\le 10^4$) \u2014 the number of test cases. The following are the descriptions of the test cases.\n\nThe first line of each test case contains two integers $n$, $m$ ($2 \\le n \\le 10^5, 1 \\le m \\le 10^5$) \u2014 the number of intersections and streets in the city.\n\nThe second line of each test case contains three integers $t_0$, $t_1$, $t_2$ ($1 \\le t_1 < t_2 < t_0 \\le 10^9$) \u2014 the start time of the event, the start time of the phone call, and its end time, respectively.\n\nThe next $m$ lines of each test case contain descriptions of the streets.\n\nThe $i$-th line contains four integers $u_i$, $v_i$, $l_{i1}$, $l_{i2}$ ($1 \\le u_i, v_i \\le n$, $u_i \\neq v_i$, $1 \\le l_{i1} < l_{i2} \\le 10^9$) \u2014 the numbers of the intersections connected by the $i$-th street, as well as the travel time along the street by bus and on foot. It is guaranteed that no two streets connect the same pair of intersections and that it is possible to reach any intersection from any other.\n\nIt is guaranteed that the sum of the values of $n$ across all test cases does not exceed $10^5$. It is also guaranteed that the sum of the values of $m$ across all test cases does not exceed $10^5$.\n\nOutput Format:\nFor each test case, output a single integer \u2014 the latest time you can leave home to have time to talk on the phone and not be late for the event. If you cannot reach the event on time, output -1.\n\nTags:\n['binary search', 'brute force', 'graphs', 'greedy', 'shortest paths']\n\nTime Limit: 4000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "7\n5 5\n100 20 80\n1 5 30 100\n1 2 20 50\n2 3 20 50\n3 4 20 50\n4 5 20 50\n2 1\n100 50 60\n1 2 55 110\n4 4\n100 40 60\n1 2 30 100\n2 4 30 100\n1 3 20 50\n3 4 20 50\n3 3\n100 80 90\n1 2 1 10\n2 3 10 50\n1 3 20 21\n3 2\n58 55 57\n2 1 1 3\n2 3 3 4\n2 1\n12 9 10\n2 1 6 10\n5 5\n8 5 6\n2 1 1 8\n2 3 4 8\n4 2 2 4\n5 3 3 4\n4 5 2 6",
                "output": "0\n-1\n60\n80\n53\n3\n2"
            }
        ]
    },
    {
        "problem": "\nKsyusha decided to start a game development company. To stand out among competitors and achieve success, she decided to write her own game engine. The engine must support a set initially consisting of $n$ distinct integers $a_1, a_2, \\ldots, a_n$.\n\nThe set will undergo $m$ operations sequentially. The operations can be of the following types:\n\n  * Insert element $x$ into the set;    * Remove element $x$ from the set;    * Report the $k$-load of the set. \n\nThe $k$-load of the set is defined as the minimum positive integer $d$ such that the integers $d, d + 1, \\ldots, d + (k - 1)$ do not appear in this set. For example, the $3$-load of the set $\\\\{3, 4, 6, 11\\\\}$ is $7$, since the integers $7, 8, 9$ are absent from the set, and no smaller value fits.\n\nKsyusha is busy with management tasks, so you will have to write the engine. Implement efficient support for the described operations.\n\nInput Format:\nThe first line contains an integer $t$ ($1 \\le t \\le 10^4$) \u2014 the number of test cases.\n\nThe following lines describe the test cases.\n\nThe first line contains an integer $n$ ($1 \\le n \\le 2 \\cdot 10^5$) \u2014 the initial size of the set.\n\nThe second line contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\le a_1 < a_2 < \\ldots < a_n \\le 2 \\cdot 10^6$) \u2014 the initial state of the set.\n\nThe third line contains an integer $m$ ($1 \\le m \\le 2 \\cdot 10^5$) \u2014 the number of operations.\n\nThe next $m$ lines contain the operations. The operations are given in the following format:\n\n  * + $x$ ($1 \\le x \\le 2 \\cdot 10^6$) \u2014 insert element $x$ into the set (it is guaranteed that $x$ is not in the set);    * - $x$ ($1 \\le x \\le 2 \\cdot 10^6$) \u2014 remove element $x$ from the set (it is guaranteed that $x$ is in the set);    * ? $k$ ($1 \\le k \\le 2 \\cdot 10^6$) \u2014 output the value of the $k$-load of the set. \n\nIt is guaranteed that the sum of $n$ across all test cases does not exceed $2 \\cdot 10^5$, and the same holds for $m$.\n\nOutput Format:\nFor each test case, output the answers to the operations of type \"?\".\n\nTags:\n['binary search', 'brute force', 'data structures', 'implementation']\n\nTime Limit: 3000 ms\nMemory Limit: 512 MB\n",
        "tests": [
            {
                "input": "3\n5\n1 2 5 905 2000000\n15\n- 2\n? 2\n? 1\n- 1\n? 1\n+ 4\n+ 2\n? 2\n+ 6\n- 4\n+ 7\n? 2\n? 3\n? 4\n? 2000000\n5\n3 4 5 6 8\n9\n? 5\n- 5\n? 5\n+ 1\n? 2\n- 6\n- 8\n+ 6\n? 5\n5\n6 7 8 9 10\n10\n? 5\n- 6\n? 4\n- 10\n+ 5\n- 8\n+ 3\n+ 2\n- 3\n+ 10",
                "output": "2 2 1 6 3 8 8 2000001 \n9 9 9 7 \n1 1"
            }
        ]
    },
    {
        "problem": "\nYou are given a cyclic array $a_1, a_2, \\ldots, a_n$.\n\nYou can perform the following operation on $a$ at most $n - 1$ times:\n\n  * Let $m$ be the current size of $a$, you can choose any two adjacent elements where the previous one is no greater than the latter one (In particular, $a_m$ and $a_1$ are adjacent and $a_m$ is the previous one), and delete exactly one of them. In other words, choose an integer $i$ ($1 \\leq i \\leq m$) where $a_i \\leq a_{(i \\bmod m) + 1}$ holds, and delete exactly one of $a_i$ or $a_{(i \\bmod m) + 1}$ from $a$. \n\nYour goal is to find the minimum number of operations needed to make all elements in $a$ equal.\n\nInput Format:\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 500$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($1 \\le n \\le 100$) \u2014 the length of the array $a$.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\le a_i \\le n$) \u2014 the elements of array $a$.\n\nOutput Format:\nFor each test case, output a single line containing an integer: the minimum number of operations needed to make all elements in $a$ equal.\n\nTags:\n['greedy', 'implementation']\n\nTime Limit: 1000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "7\n1\n1\n3\n1 2 3\n3\n1 2 2\n5\n5 4 3 2 1\n6\n1 1 2 2 3 3\n8\n8 7 6 3 8 7 6 3\n6\n1 1 4 5 1 4",
                "output": "0\n2\n1\n4\n4\n6\n3"
            }
        ]
    },
    {
        "problem": "\nThere is an integer sequence $a$ of length $n$, where each element is initially $-1$.\n\nMisuki has two typewriters where the first one writes letters from left to right, with a pointer initially pointing to $1$, and another writes letters from right to left with a pointer initially pointing to $n$.\n\nMisuki would choose one of the typewriters and use it to perform the following operations until $a$ becomes a permutation of $[1, 2, \\ldots, n]$\n\n  * write number: write the minimum positive integer that isn't present in the array $a$ to the element $a_i$, $i$ is the position where the pointer points at. Such operation can be performed only when $a_i = -1$.    * carriage return: return the pointer to its initial position (i.e. $1$ for the first typewriter, $n$ for the second)    * move pointer: move the pointer to the next position, let $i$ be the position the pointer points at before this operation, if Misuki is using the first typewriter, $i := i + 1$ would happen, and $i := i - 1$ otherwise. Such operation can be performed only if after the operation, $1 \\le i \\le n$ holds. \n\nYour task is to construct any permutation $p$ of length $n$, such that the minimum number of carriage return operations needed to make $a = p$ is the same no matter which typewriter Misuki is using.\n\nInput Format:\nEach test contains multiple test cases. The first line of input contains a single integer $t$ ($1 \\le t \\le 500$) \u2014 the number of test cases. The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($1 \\le n \\le 2 \\cdot 10^5$) \u2014 the length of the permutation.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\nOutput Format:\nFor each test case, output a line of $n$ integers, representing the permutation $p$ of length $n$ such that the minimum number of carriage return operations needed to make $a = p$ is the same no matter which typewriter Misuki is using, or $-1$ if it is impossible to do so.\n\nIf there are multiple valid permutations, you can output any of them.\n\nTags:\n['constructive algorithms']\n\nTime Limit: 1500 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "3\n1\n2\n3",
                "output": "1\n-1\n3 1 2"
            }
        ]
    },
    {
        "problem": "\nThis is an interactive problem.\n\nMisuki has chosen a secret tree with $n$ nodes, indexed from $1$ to $n$, and asked you to guess it by using queries of the following type:\n\n  * \"? a b\" \u2014 Misuki will tell you which node $x$ minimizes $|d(a,x) - d(b,x)|$, where $d(x,y)$ is the distance between nodes $x$ and $y$. If more than one such node exists, Misuki will tell you the one which minimizes $d(a,x)$. \n\nFind out the structure of Misuki's secret tree using at most $15n$ queries!\n\nInput Format:\nEach test consists of multiple test cases. The first line contains a single integer $t$ ($1 \\le t \\le 200$) \u2014 the number of test cases.\n\nEach test case consists of a single line with an integer $n$ ($2 \\le n \\le 1000$), the number of nodes in the tree.\n\nIt is guaranteed that the sum of $n$ across all test cases does not exceed $1000$.\n\nOutput Format:\n\n\nTags:\n['binary search', 'brute force', 'dfs and similar', 'divide and conquer', 'dsu', 'greedy', 'interactive', 'trees']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "1\n4\n1\n1\n3",
                "output": "? 1 2\n\n? 1 3\n\n? 1 4\n\n! 1 2 1 3 3 4"
            }
        ]
    },
    {
        "problem": "\nYou are given an integer sequence $a_1, a_2, \\ldots, a_n$. Let $S$ be the set of all possible non-empty subsequences of $a$ without duplicate elements. Your goal is to find the longest sequence in $S$. If there are multiple of them, find the one that minimizes lexicographical order after multiplying terms at odd positions by $-1$.\n\nFor example, given $a = [3, 2, 3, 1]$, $S = \\\\{[1], [2], [3], [2, 1], [2, 3], [3, 1], [3, 2], [2, 3, 1], [3, 2, 1]\\\\}$. Then $[2, 3, 1]$ and $[3, 2, 1]$ would be the longest, and $[3, 2, 1]$ would be the answer since $[-3, 2, -1]$ is lexicographically smaller than $[-2, 3, -1]$.\n\nA sequence $c$ is a subsequence of a sequence $d$ if $c$ can be obtained from $d$ by the deletion of several (possibly, zero or all) elements.\n\nA sequence $c$ is lexicographically smaller than a sequence $d$ if and only if one of the following holds:\n\n  * $c$ is a prefix of $d$, but $c \\ne d$;   * in the first position where $c$ and $d$ differ, the sequence $c$ has a smaller element than the corresponding element in $d$.\n\nInput Format:\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 5 \\cdot 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains an integer $n$ ($1 \\le n \\le 3 \\cdot 10^5$) \u2014 the length of $a$.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\le a_i \\le n$) \u2014 the sequence $a$.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $3 \\cdot 10^5$.\n\nOutput Format:\nFor each test case, output the answer in the following format:\n\nOutput an integer $m$ in the first line \u2014 the length of $b$.\n\nThen output $m$ integers $b_1, b_2, \\ldots, b_m$ in the second line \u2014 the sequence $b$.\n\nTags:\n['brute force', 'constructive algorithms', 'data structures', 'greedy', 'implementation']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "4\n4\n3 2 1 3\n4\n1 1 1 1\n9\n3 2 1 3 2 1 3 2 1\n1\n1",
                "output": "3\n3 2 1\n1\n1\n3\n3 1 2\n1\n1"
            },
            {
                "input": "10\n2\n1 2\n10\n5 2 1 7 9 7 2 5 5 2\n2\n1 2\n10\n2 2 8 7 7 9 8 1 9 6\n9\n9 1 7 5 8 5 6 4 1\n3\n3 3 3\n6\n1 6 4 4 6 5\n6\n3 4 4 5 3 3\n10\n4 1 4 5 4 5 10 1 5 1\n7\n1 2 1 3 2 4 6",
                "output": "2\n1 2\n5\n5 1 9 7 2\n2\n1 2\n6\n2 7 9 8 1 6\n7\n9 1 7 5 8 6 4\n1\n3\n4\n1 4 6 5\n3\n4 5 3\n4\n5 4 10 1\n5\n2 1 3 4 6"
            }
        ]
    },
    {
        "problem": "\nThis is the easy version of the problem. The difference between the two versions is the definition of deterministic max-heap, time limit, and constraints on $n$ and $t$. You can make hacks only if both versions of the problem are solved.\n\nConsider a perfect binary tree with size $2^n - 1$, with nodes numbered from $1$ to $2^n-1$ and rooted at $1$. For each vertex $v$ ($1 \\le v \\le 2^{n - 1} - 1$), vertex $2v$ is its left child and vertex $2v + 1$ is its right child. Each node $v$ also has a value $a_v$ assigned to it.\n\nDefine the operation $\\mathrm{pop}$ as follows:\n\n  1. initialize variable $v$ as $1$;    2. repeat the following process until vertex $v$ is a leaf (i.e. until $2^{n - 1} \\le v \\le 2^n - 1$);      1. among the children of $v$, choose the one with the larger value on it and denote such vertex as $x$; if the values on them are equal (i.e. $a_{2v} = a_{2v + 1}$), you can choose any of them;      2. assign $a_x$ to $a_v$ (i.e. $a_v := a_x$);      3. assign $x$ to $v$ (i.e. $v := x$);    3. assign $-1$ to $a_v$ (i.e. $a_v := -1$). \n\nThen we say the $\\mathrm{pop}$ operation is deterministic if there is a unique way to do such operation. In other words, $a_{2v} \\neq a_{2v + 1}$ would hold whenever choosing between them.\n\nA binary tree is called a max-heap if for every vertex $v$ ($1 \\le v \\le 2^{n - 1} - 1$), both $a_v \\ge a_{2v}$ and $a_v \\ge a_{2v + 1}$ hold.\n\nA max-heap is deterministic if the $\\mathrm{pop}$ operation is deterministic to the heap when we do it for the first time.\n\nInitially, $a_v := 0$ for every vertex $v$ ($1 \\le v \\le 2^n - 1$), and your goal is to count the number of different deterministic max- heaps produced by applying the following operation $\\mathrm{add}$ exactly $k$ times:\n\n  * Choose an integer $v$ ($1 \\le v \\le 2^n - 1$) and, for every vertex $x$ on the path between $1$ and $v$, add $1$ to $a_x$. \n\nTwo heaps are considered different if there is a node which has different values in the heaps.\n\nSince the answer might be large, print it modulo $p$.\n\nInput Format:\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 500$). The description of the test cases follows.\n\nThe first line of each test case contains three integers $n, k, p$ ($1 \\le n, k \\le 500$, $10^8 \\le p \\le 10^9$, $p$ is a prime).\n\nIt is guaranteed that the sum of $n$ and the sum of $k$ over all test cases does not exceed $500$.\n\nOutput Format:\nFor each test case, output a single line containing an integer: the number of different deterministic max-heaps produced by applying the aforementioned operation $\\mathrm{add}$ exactly $k$ times, modulo $p$.\n\nTags:\n['combinatorics', 'dp', 'math', 'trees']\n\nTime Limit: 3000 ms\nMemory Limit: 512 MB\n",
        "tests": [
            {
                "input": "7\n1 13 998244353\n2 1 998244353\n3 2 998244853\n3 3 998244353\n3 4 100000037\n4 2 100000039\n4 3 100000037",
                "output": "1\n2\n12\n52\n124\n32\n304"
            },
            {
                "input": "1\n500 500 100000007",
                "output": "76297230"
            },
            {
                "input": "6\n87 63 100000037\n77 77 100000039\n100 200 998244353\n200 100 998244353\n32 59 998244853\n1 1 998244353",
                "output": "26831232\n94573603\n37147649\n847564946\n727060898\n1"
            }
        ]
    },
    {
        "problem": "\nThis is the hard version of the problem. The difference between the two versions is the definition of deterministic max-heap, time limit, and constraints on $n$ and $t$. You can make hacks only if both versions of the problem are solved.\n\nConsider a perfect binary tree with size $2^n - 1$, with nodes numbered from $1$ to $2^n-1$ and rooted at $1$. For each vertex $v$ ($1 \\le v \\le 2^{n - 1} - 1$), vertex $2v$ is its left child and vertex $2v + 1$ is its right child. Each node $v$ also has a value $a_v$ assigned to it.\n\nDefine the operation $\\mathrm{pop}$ as follows:\n\n  1. initialize variable $v$ as $1$;    2. repeat the following process until vertex $v$ is a leaf (i.e. until $2^{n - 1} \\le v \\le 2^n - 1$);      1. among the children of $v$, choose the one with the larger value on it and denote such vertex as $x$; if the values on them are equal (i.e. $a_{2v} = a_{2v + 1}$), you can choose any of them;      2. assign $a_x$ to $a_v$ (i.e. $a_v := a_x$);      3. assign $x$ to $v$ (i.e. $v := x$);    3. assign $-1$ to $a_v$ (i.e. $a_v := -1$). \n\nThen we say the $\\mathrm{pop}$ operation is deterministic if there is a unique way to do such operation. In other words, $a_{2v} \\neq a_{2v + 1}$ would hold whenever choosing between them.\n\nA binary tree is called a max-heap if for every vertex $v$ ($1 \\le v \\le 2^{n - 1} - 1$), both $a_v \\ge a_{2v}$ and $a_v \\ge a_{2v + 1}$ hold.\n\nA max-heap is deterministic if the $\\mathrm{pop}$ operation is deterministic to the heap when we do it for the first and the second time.\n\nInitially, $a_v := 0$ for every vertex $v$ ($1 \\le v \\le 2^n - 1$), and your goal is to count the number of different deterministic max- heaps produced by applying the following operation $\\mathrm{add}$ exactly $k$ times:\n\n  * Choose an integer $v$ ($1 \\le v \\le 2^n - 1$) and, for every vertex $x$ on the path between $1$ and $v$, add $1$ to $a_x$. \n\nTwo heaps are considered different if there is a node which has different values in the heaps.\n\nSince the answer might be large, print it modulo $p$.\n\nInput Format:\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 50$). The description of the test cases follows.\n\nThe first line of each test case contains three integers $n, k, p$ ($2 \\le n \\le 100$, $1 \\le k \\le 500$, $10^8 \\le p \\le 10^9$, $p$ is a prime).\n\nIt is guaranteed that the sum of $n$ does not exceed $100$ and the sum of $k$ over all test cases does not exceed $500$.\n\nOutput Format:\nFor each test case, output a single line containing an integer: the number of different deterministic max-heaps produced by applying the aforementioned operation $\\mathrm{add}$ exactly $k$ times, modulo $p$.\n\nTags:\n['combinatorics', 'dp', 'trees']\n\nTime Limit: 4000 ms\nMemory Limit: 512 MB\n",
        "tests": [
            {
                "input": "6\n2 1 998244353\n3 2 998244853\n3 3 998244353\n3 4 100000037\n4 2 100000039\n4 3 100000037",
                "output": "2\n12\n40\n100\n32\n224"
            },
            {
                "input": "1\n100 500 100000037",
                "output": "66681128"
            },
            {
                "input": "2\n87 63 100000037\n13 437 100000039",
                "output": "83566569\n54517140"
            }
        ]
    },
    {
        "problem": "\nYou received an $n\\times m$ grid from a mysterious source. The source also gave you a magic positive integer constant $k$.\n\nThe source told you to color the grid with some colors, satisfying the following condition:\n\n  * If $(x_1,y_1)$, $(x_2,y_2)$ are two distinct cells with the same color, then $\\max(|x_1-x_2|,|y_1-y_2|)\\ge k$. \n\nYou don't like using too many colors. Please find the minimum number of colors needed to color the grid.\n\nInput Format:\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1\\le t\\le1000$). The description of the test cases follows.\n\nThe only line of each test case consists of three positive integers $n$, $m$, $k$ ($1\\le n,m,k\\le10^4$) \u2014 the dimensions of the grid and the magic constant.\n\nOutput Format:\nFor each test case, print a single integer \u2014 the minimum number of colors needed to color the grid.\n\nTags:\n['constructive algorithms', 'implementation', 'math']\n\nTime Limit: 1000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "6\n3 3 2\n5 1 10000\n7 3 4\n3 2 7\n8 9 6\n2 5 4",
                "output": "4\n5\n12\n6\n36\n8"
            }
        ]
    },
    {
        "problem": "\nAlice got a permutation $a_1, a_2, \\ldots, a_n$ of $[1,2,\\ldots,n]$, and Bob got another permutation $b_1, b_2, \\ldots, b_n$ of $[1,2,\\ldots,n]$. They are going to play a game with these arrays.\n\nIn each turn, the following events happen in order:\n\n  * Alice chooses either the first or the last element of her array and removes it from the array;    * Bob chooses either the first or the last element of his array and removes it from the array. \n\nThe game continues for $n-1$ turns, after which both arrays will have exactly one remaining element: $x$ in the array $a$ and $y$ in the array $b$.\n\nIf $x=y$, Bob wins; otherwise, Alice wins. Find which player will win if both players play optimally.\n\nInput Format:\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1\\le t\\le10^4$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($1\\le n\\le 3\\cdot 10^5$).\n\nThe next line contains $n$ integers $a_1,a_2,\\ldots,a_n$ ($1\\le a_i\\le n$, all $a_i$ are distinct) \u2014 the permutation of Alice.\n\nThe next line contains $n$ integers $b_1,b_2,\\ldots,b_n$ ($1\\le b_i\\le n$, all $b_i$ are distinct) \u2014 the permutation of Bob.\n\nIt is guaranteed that the sum of all $n$ does not exceed $3\\cdot 10^5$.\n\nOutput Format:\nFor each test case, print a single line with the name of the winner, assuming both players play optimally. If Alice wins, print $\\texttt{Alice}$; otherwise, print $\\texttt{Bob}$.\n\nTags:\n['constructive algorithms', 'games']\n\nTime Limit: 1000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "2\n2\n1 2\n1 2\n3\n1 2 3\n2 3 1",
                "output": "Bob\nAlice"
            }
        ]
    },
    {
        "problem": "\nThere are $n$ circles on a two-dimensional plane. The $i$-th circle is centered at $(x_i,y_i)$. Initially, all circles have a radius of $0$.\n\nThe circles' radii increase at a rate of $1$ unit per second.\n\nYou are currently at $(x_s,y_s)$; your goal is to reach $(x_t,y_t)$ without touching the circumference of any circle (including the moment you reach $(x_t,y_t)$). You can move in any direction you want. However, your speed is limited to $1$ unit per second.\n\nPlease determine whether this is possible.\n\nInput Format:\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1\\le t\\le10^4$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($1\\le n\\le10^5$) \u2014 the number of circles.\n\nThe next $n$ lines each contain two integers $x_i$, $y_i$ ($1\\le x_i,y_i\\le10^9$) \u2014 the center of each circle.\n\nThe final line contains four integers $x_s$, $y_s$, $x_t$, $y_t$ ($1\\le x_s,y_s,x_t,y_t\\le10^9$) \u2014 the coordinates of the starting point and the goal, respectively.\n\nIt is guaranteed that these $n+2$ points are distinct.\n\nIt is guaranteed that the sum of $n$ over all testcases does not exceed $10^5$.\n\nOutput Format:\nFor each test case, output $\\texttt{YES}$ if it is possible to reach the goal without touching the circle boundaries, and output $\\texttt{NO}$ otherwise.\n\nYou can output $\\texttt{Yes}$ and $\\texttt{No}$ in any case (for example, strings $\\texttt{yEs}$, $\\texttt{yes}$, $\\texttt{Yes}$, and $\\texttt{YES}$ will be recognized as a positive response).\n\nTags:\n['brute force', 'geometry', 'greedy', 'math']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "7\n3\n2 5\n2 14\n10 13\n4 9 9 7\n3\n10 11\n6 9\n12 12\n14 13 4 8\n1\n5 7\n12 6 11 13\n2\n1000000000 2\n2 1000000000\n1 1 2 2\n1\n999999998 1000000000\n999999999 999999999 1 1\n1\n1000000000 1\n1 1000000000 1 1\n10\n989237121 2397081\n206669655 527238537\n522705783 380636165\n532545346 320061691\n207818728 199485303\n884520552 315781807\n992311437 802563521\n205138355 324818663\n223575704 395073023\n281560523 236279118\n216941610 572010615 323956540 794523071",
                "output": "YES\nNO\nYES\nYES\nYES\nNO\nYES"
            }
        ]
    },
    {
        "problem": "\nThis is the easy version of the problem. In this version, the given tree is a perfect binary tree and the constraints on $n$ and $q$ are lower. You can make hacks only if both versions of the problem are solved.\n\nYou are given a perfect binary tree$^\\dagger$ consisting of $n$ vertices. The vertices are numbered from $1$ to $n$, and the root is the vertex $1$. You are also given a permutation $p_1, p_2, \\ldots, p_n$ of $[1,2,\\ldots,n]$.\n\nYou need to answer $q$ queries. For each query, you are given two integers $x$, $y$; you need to swap $p_x$ and $p_y$ and determine if $p_1, p_2, \\ldots, p_n$ is a valid DFS order$^\\ddagger$ of the given tree.\n\nPlease note that the swaps are persistent through queries.\n\n$^\\dagger$ A perfect binary tree is a tree with vertex $1$ as its root, with size $n=2^k-1$ for a positive integer $k$, and where the parent of each vertex $i$ ($1<i\\le n$) is $\\left\\lfloor\\frac{i}{2}\\right\\rfloor$. Thus, all leaves of this tree are at a distance $k - 1$ from the root.\n\n$^\\ddagger$ A DFS order is found by calling the following $\\texttt{dfs}$ function on the given tree.\n\n              dfs_order = []          function dfs(v):         append v to the back of dfs_order         pick an arbitrary permutation s of children of v         for child in s:             dfs(child)     dfs(1)     \n\nNote that the DFS order is not unique.\n\nInput Format:\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1\\le t\\le10^4$). The description of the test cases follows.\n\nThe first line of each test case contains two integers $n$, $q$ ($3\\le n\\le 65\\,535$, $2\\le q\\le 5 \\cdot 10^4$) \u2014 the number of vertices in the tree and the number of queries. It is guaranteed that $n=2^k-1$ for a positive integer $k$.\n\nThe next line contains $n-1$ integers $a_2,a_3,\\ldots,a_n$ ($1\\le a_i<i$) \u2014 the parent of each vertex in the given tree. It is guaranteed that $a_i=\\left\\lfloor\\frac{i}{2}\\right\\rfloor$.\n\nThe next line contains $n$ integers $p_1,p_2,\\ldots,p_n$ ($1\\le p_i\\le n$, all $p_i$ are distinct) \u2014 the initial permutation $p$.\n\nThe next $q$ lines each contain two integers $x$, $y$ ($1\\le x,y\\le n,x\\neq y$) \u2014 the positions of the elements to swap in the permutation.\n\nIt is guaranteed that the sum of all $n$ does not exceed $65\\,535$, and the sum of all $q$ does not exceed $5 \\cdot 10^4$.\n\nOutput Format:\nFor each test case, print $q$ lines corresponding to the $q$ queries. For each query, output $\\texttt{YES}$ if there is a DFS order that exactly equals the current permutation, and output $\\texttt{NO}$ otherwise.\n\nYou can output $\\texttt{Yes}$ and $\\texttt{No}$ in any case (for example, strings $\\texttt{yEs}$, $\\texttt{yes}$, $\\texttt{Yes}$ and $\\texttt{YES}$ will be recognized as a positive response).\n\nTags:\n['brute force', 'data structures', 'dfs and similar', 'graphs', 'hashing', 'trees']\n\nTime Limit: 2000 ms\nMemory Limit: 512 MB\n",
        "tests": [
            {
                "input": "2\n3 3\n1 1\n1 2 3\n2 3\n3 2\n1 3\n7 4\n1 1 2 2 3 3\n1 2 3 4 5 6 7\n3 5\n2 5\n3 7\n4 6",
                "output": "YES\nYES\nNO\nYES\nNO\nNO\nYES"
            }
        ]
    },
    {
        "problem": "\nThis is the hard version of the problem. In this version, you are given a generic tree and the constraints on $n$ and $q$ are higher. You can make hacks only if both versions of the problem are solved.\n\nYou are given a rooted tree consisting of $n$ vertices. The vertices are numbered from $1$ to $n$, and the root is the vertex $1$. You are also given a permutation $p_1, p_2, \\ldots, p_n$ of $[1,2,\\ldots,n]$.\n\nYou need to answer $q$ queries. For each query, you are given two integers $x$, $y$; you need to swap $p_x$ and $p_y$ and determine if $p_1, p_2, \\ldots, p_n$ is a valid DFS order$^\\dagger$ of the given tree.\n\nPlease note that the swaps are persistent through queries.\n\n$^\\dagger$ A DFS order is found by calling the following $\\texttt{dfs}$ function on the given tree.\n\n              dfs_order = []          function dfs(v):         append v to the back of dfs_order         pick an arbitrary permutation s of children of v         for child in s:             dfs(child)     dfs(1)     \n\nNote that the DFS order is not unique.\n\nInput Format:\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1\\le t\\le10^4$). The description of the test cases follows.\n\nThe first line of each test case contains two integers $n$, $q$ ($2\\le n\\le 3\\cdot 10^5$, $2\\le q\\le 10^5$) \u2014 the number of vertices in the tree and the number of queries.\n\nThe next line contains $n-1$ integers $a_2,a_3,\\ldots,a_n$ ($1\\le a_i<i$) \u2014 the parent of each vertex in the given tree.\n\nThe next line contains $n$ integers $p_1,p_2,\\ldots,p_n$ ($1\\le p_i\\le n$, all $p_i$ are distinct) \u2014 the initial permutation $p$.\n\nThe next $q$ lines each contain two integers $x$, $y$ ($1\\le x,y\\le n,x\\neq y$) \u2014 the positions of the elements to swap in the permutation.\n\nIt is guaranteed that the sum of all $n$ does not exceed $3\\cdot 10^5$, and the sum of all $q$ does not exceed $10^5$.\n\nOutput Format:\nFor each test case, print $q$ lines corresponding to the $q$ queries. For each query, output $\\texttt{YES}$ if there is a DFS order that exactly equals the current permutation, and output $\\texttt{NO}$ otherwise.\n\nYou can output $\\texttt{Yes}$ and $\\texttt{No}$ in any case (for example, strings $\\texttt{yEs}$, $\\texttt{yes}$, $\\texttt{Yes}$, and $\\texttt{YES}$ will be recognized as a positive response).\n\nTags:\n['binary search', 'data structures', 'dfs and similar', 'graphs', 'hashing', 'trees']\n\nTime Limit: 2000 ms\nMemory Limit: 512 MB\n",
        "tests": [
            {
                "input": "3\n3 3\n1 1\n1 2 3\n2 3\n3 2\n1 3\n7 4\n1 1 2 2 3 3\n1 2 3 4 5 6 7\n3 5\n2 5\n3 7\n4 6\n5 4\n1 1 3 4\n2 3 4 5 1\n5 1\n4 5\n3 4\n2 3",
                "output": "YES\nYES\nNO\nYES\nNO\nNO\nYES\nYES\nNO\nNO\nYES"
            }
        ]
    },
    {
        "problem": "\nGiven an array of integers $s_1, s_2, \\ldots, s_l$, every second, cosmic rays will cause all $s_i$ such that $i=1$ or $s_i\\neq s_{i-1}$ to be deleted simultaneously, and the remaining parts will be concatenated together in order to form the new array $s_1, s_2, \\ldots, s_{l'}$.\n\nDefine the strength of an array as the number of seconds it takes to become empty.\n\nYou are given an array of integers compressed in the form of $n$ pairs that describe the array left to right. Each pair $(a_i,b_i)$ represents $a_i$ copies of $b_i$, i.e. $\\underbrace{b_i,b_i,\\cdots,b_i}_{a_i\\textrm{ times}}$.\n\nFor each $i=1,2,\\dots,n$, please find the strength of the sequence described by the first $i$ pairs.\n\nInput Format:\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1\\le t\\le10^4$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($1\\le n\\le3\\cdot10^5$) \u2014 the length of sequence $a$.\n\nThe next $n$ lines contain two integers each $a_i$, $b_i$ ($1\\le a_i\\le10^9,0\\le b_i\\le n$) \u2014 the pairs which describe the sequence.\n\nIt is guaranteed that the sum of all $n$ does not exceed $3\\cdot10^5$.\n\nIt is guaranteed that for all $1\\le i<n$, $b_i\\neq b_{i+1}$ holds.\n\nOutput Format:\nFor each test case, print one line containing $n$ integers \u2014 the answer for each prefix of pairs.\n\nTags:\n['brute force', 'data structures', 'dp']\n\nTime Limit: 2000 ms\nMemory Limit: 512 MB\n",
        "tests": [
            {
                "input": "4\n4\n2 0\n1 1\n3 0\n5 1\n6\n4 6\n1 3\n4 6\n4 0\n7 6\n6 3\n7\n9 0\n7 1\n5 0\n7 1\n9 0\n1 1\n2 0\n10\n10 7\n4 9\n2 2\n7 9\n2 8\n8 5\n11 7\n15 5\n12 7\n4 0",
                "output": "2 2 4 5 \n4 4 7 7 10 10 \n9 9 9 9 9 9 10 \n10 10 10 10 10 10 12 15 15 15"
            }
        ]
    },
    {
        "problem": "\nThis is the easy version of the problem. In this version, $n=m$ and the time limit is lower. You can make hacks only if both versions of the problem are solved.\n\nIn the court of the Blue King, Lelle and Flamm are having a performance match. The match consists of several rounds. In each round, either Lelle or Flamm wins.\n\nLet $W_L$ and $W_F$ denote the number of wins of Lelle and Flamm, respectively. The Blue King considers a match to be successful if and only if:\n\n  * after every round, $\\gcd(W_L,W_F)\\le 1$;    * at the end of the match, $W_L\\le n, W_F\\le m$. \n\nNote that $\\gcd(0,x)=\\gcd(x,0)=x$ for every non-negative integer $x$.\n\nLelle and Flamm can decide to stop the match whenever they want, and the final score of the performance is $l \\cdot W_L + f \\cdot W_F$.\n\nPlease help Lelle and Flamm coordinate their wins and losses such that the performance is successful, and the total score of the performance is maximized.\n\nInput Format:\nThe first line contains an integer $t$ ($1\\leq t \\leq 10^3$) \u2014 the number of test cases.\n\nThe only line of each test case contains four integers $n$, $m$, $l$, $f$ ($2\\leq n\\leq m \\leq 2\\cdot 10^7$, $1\\leq l,f \\leq 10^9$, $\\bf{n=m}$): $n$, $m$ gives the upper bound on the number of Lelle and Flamm's wins, $l$ and $f$ determine the final score of the performance.\n\nUnusual additional constraint: it is guaranteed that, for each test, there are no pairs of test cases with the same pair of $n$, $m$.\n\nOutput Format:\nFor each test case, output a single integer \u2014 the maximum total score of a successful performance.\n\nTags:\n['brute force', 'dfs and similar', 'dp', 'math', 'number theory']\n\nTime Limit: 3000 ms\nMemory Limit: 512 MB\n",
        "tests": [
            {
                "input": "8\n3 3 2 5\n4 4 1 4\n6 6 2 2\n7 7 2 3\n9 9 9 1\n2 2 1 4\n5 5 1 4\n8 8 6 7",
                "output": "19\n17\n18\n33\n86\n9\n24\n86"
            },
            {
                "input": "1\n20000000 20000000 1341 331",
                "output": "33439999007"
            },
            {
                "input": "2\n1984 1984 19 84\n9982 9982 44 35",
                "output": "204143\n788403"
            }
        ]
    },
    {
        "problem": "\nThis is the hard version of the problem. In this version, it is not guaranteed that $n=m$, and the time limit is higher. You can make hacks only if both versions of the problem are solved.\n\nIn the court of the Blue King, Lelle and Flamm are having a performance match. The match consists of several rounds. In each round, either Lelle or Flamm wins.\n\nLet $W_L$ and $W_F$ denote the number of wins of Lelle and Flamm, respectively. The Blue King considers a match to be successful if and only if:\n\n  * after every round, $\\gcd(W_L,W_F)\\le 1$;    * at the end of the match, $W_L\\le n, W_F\\le m$. \n\nNote that $\\gcd(0,x)=\\gcd(x,0)=x$ for every non-negative integer $x$.\n\nLelle and Flamm can decide to stop the match whenever they want, and the final score of the performance is $l \\cdot W_L + f \\cdot W_F$.\n\nPlease help Lelle and Flamm coordinate their wins and losses such that the performance is successful, and the total score of the performance is maximized.\n\nInput Format:\nThe first line contains an integer $t$ ($1\\leq t \\leq 10^3$) \u2014 the number of test cases.\n\nThe only line of each test case contains four integers $n$, $m$, $l$, $f$ ($2\\leq n\\leq m \\leq 2\\cdot 10^7$, $1\\leq l,f \\leq 10^9$): $n$, $m$ give the upper bound on the number of Lelle and Flamm's wins, $l$ and $f$ determine the final score of the performance.\n\nUnusual additional constraint: it is guaranteed that, for each test, there are no pairs of test cases with the same pair of $n$, $m$.\n\nOutput Format:\nFor each test case, output a single integer \u2014 the maximum total score of a successful performance.\n\nTags:\n['brute force', 'dp', 'math', 'number theory']\n\nTime Limit: 4000 ms\nMemory Limit: 512 MB\n",
        "tests": [
            {
                "input": "8\n3 4 2 5\n4 4 1 4\n6 6 2 2\n7 9 2 3\n8 9 9 1\n2 7 1 4\n5 9 1 4\n5 6 6 7",
                "output": "22\n17\n18\n37\n77\n30\n41\n59"
            },
            {
                "input": "2\n3082823 20000000 1341 331\n20000000 20000000 3 5",
                "output": "10754065643\n159999991"
            },
            {
                "input": "1\n139 1293 193 412",
                "output": "559543"
            }
        ]
    },
    {
        "problem": "\nConsider a grid graph with $n$ rows and $n$ columns. Let the cell in row $x$ and column $y$ be $(x,y)$. There exists a directed edge from $(x,y)$ to $(x+1,y)$, with non-negative integer value $d_{x,y}$, for all $1\\le x < n, 1\\le y \\le n$, and there also exists a directed edge from $(x,y)$ to $(x,y+1)$, with non-negative integer value $r_{x,y}$, for all $1\\le x \\le n, 1\\le y < n$.\n\nInitially, you are at $(1,1)$, with an empty set $S$. You need to walk along the edges and eventually reach $(n,n)$. Whenever you pass an edge, its value will be inserted into $S$. Please maximize the MEX$^{\\text{\u2217}}$ of $S$ when you reach $(n,n)$.\n\n$^{\\text{\u2217}}$The MEX (minimum excluded) of an array is the smallest non- negative integer that does not belong to the array. For instance:\n\n  * The MEX of $[2,2,1]$ is $0$, because $0$ does not belong to the array.    * The MEX of $[3,1,0,1]$ is $2$, because $0$ and $1$ belong to the array, but $2$ does not.    * The MEX of $[0,3,1,2]$ is $4$, because $0, 1, 2$, and $3$ belong to the array, but $4$ does not.\n\nInput Format:\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1\\le t\\le100$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($2\\le n\\le20$) \u2014 the number of rows and columns.\n\nEach of the next $n-1$ lines contains $n$ integers separated by single spaces \u2014 the matrix $d$ ($0\\le d_{x,y}\\le 2n-2$).\n\nEach of the next $n$ lines contains $n-1$ integers separated by single spaces \u2014 the matrix $r$ ($0\\le r_{x,y}\\le 2n-2$).\n\nIt is guaranteed that the sum of all $n^3$ does not exceed $8000$.\n\nOutput Format:\nFor each test case, print a single integer \u2014 the maximum MEX of $S$ when you reach $(n,n)$.\n\nTags:\n['bitmasks', 'brute force', 'hashing', 'meet-in-the-middle']\n\nTime Limit: 7000 ms\nMemory Limit: 1024 MB\n",
        "tests": [
            {
                "input": "2\n3\n1 0 2\n0 1 3\n2 1\n0 3\n3 0\n3\n1 2 0\n0 1 2\n2 0\n1 2\n0 1",
                "output": "3\n2"
            },
            {
                "input": "1\n10\n16 7 3 15 9 17 1 15 9 0\n4 3 1 12 13 10 10 14 6 12\n3 1 3 9 5 16 0 12 7 12\n11 4 8 7 13 7 15 13 9 2\n2 3 9 9 4 12 17 7 10 15\n10 6 15 17 13 6 15 9 4 9\n13 3 3 14 1 2 10 10 12 16\n8 2 9 13 18 7 1 6 2 6\n15 12 2 6 0 0 13 3 7 17\n7 3 17 17 10 15 12 14 15\n4 3 3 17 3 13 11 16 6\n16 17 7 7 12 5 2 4 10\n18 9 9 3 5 9 1 16 7\n1 0 4 2 10 10 12 2 1\n4 14 15 16 15 5 8 4 18\n7 18 10 11 2 0 14 8 18\n2 17 6 0 9 6 13 5 11\n5 15 7 11 6 3 17 14 5\n1 3 16 16 13 1 0 13 11",
                "output": "14"
            }
        ]
    },
    {
        "problem": "\nIt's been a long summer's day, with the constant chirping of cicadas and the heat which never seemed to end. Finally, it has drawn to a close. The showdown has passed, the gates are open, and only a gentle breeze is left behind.\n\nYour predecessors had taken their final bow; it's your turn to take the stage.\n\nSorting through some notes that were left behind, you found a curious statement named Problem 101:\n\n  * Given a positive integer sequence $a_1,a_2,\\ldots,a_n$, you can operate on it any number of times. In an operation, you choose three consecutive elements $a_i,a_{i+1},a_{i+2}$, and merge them into one element $\\max(a_i+1,a_{i+1},a_{i+2}+1)$. Please calculate the maximum number of operations you can do without creating an element greater than $m$. \n\nAfter some thought, you decided to propose the following problem, named Counting 101:\n\n  * Given $n$ and $m$. For each $k=0,1,\\ldots,\\left\\lfloor\\frac{n-1}{2}\\right\\rfloor$, please find the number of integer sequences $a_1,a_2,\\ldots,a_n$ with elements in $[1, m]$, such that when used as input for Problem 101, the answer is $k$. As the answer can be very large, please print it modulo $10^9+7$.\n\nInput Format:\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1\\le t\\le10^3$). The description of the test cases follows.\n\nThe only line of each test case contains two integers $n$, $m$ ($1\\le n\\le 130$, $1\\le m\\le 30$).\n\nOutput Format:\nFor each test case, output $\\left\\lfloor\\frac{n+1}{2}\\right\\rfloor$ numbers. The $i$-th number is the number of valid sequences such that when used as input for Problem 101, the answer is $i-1$, modulo $10^9+7$.\n\nTags:\n['greedy']\n\nTime Limit: 10100 ms\nMemory Limit: 1010 MB\n",
        "tests": [
            {
                "input": "2\n3 2\n10 10",
                "output": "6 2 \n1590121 23399118 382293180 213020758 379696760"
            }
        ]
    },
    {
        "problem": "\nTurtle thinks a string $s$ is a good string if there exists a sequence of strings $t_1, t_2, \\ldots, t_k$ ($k$ is an arbitrary integer) such that:\n\n  * $k \\ge 2$.    * $s = t_1 + t_2 + \\ldots + t_k$, where $+$ represents the concatenation operation. For example, $\\texttt{abc} = \\texttt{a} + \\texttt{bc}$.    * For all $1 \\le i < j \\le k$, the first character of $t_i$ isn't equal to the last character of $t_j$. \n\nTurtle is given a string $s$ consisting of lowercase Latin letters. Please tell him whether the string $s$ is a good string!\n\nInput Format:\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 500$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($2 \\le n \\le 100$) \u2014 the length of the string.\n\nThe second line of each test case contains a string $s$ of length $n$, consisting of lowercase Latin letters.\n\nOutput Format:\nFor each test case, output \"YES\" if the string $s$ is a good string, and \"NO\" otherwise.\n\nYou can output the answer in any case (upper or lower). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as positive responses.\n\nTags:\n['greedy', 'strings']\n\nTime Limit: 1000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "4\n2\naa\n3\naba\n4\nabcb\n12\nabcabcabcabc",
                "output": "No\nnO\nYes\nYES"
            }
        ]
    },
    {
        "problem": "\nTurtle and Piggy are playing a game on a sequence. They are given a sequence $a_1, a_2, \\ldots, a_n$, and Turtle goes first. Turtle and Piggy alternate in turns (so, Turtle does the first turn, Piggy does the second, Turtle does the third, etc.).\n\nThe game goes as follows:\n\n  * Let the current length of the sequence be $m$. If $m = 1$, the game ends.    * If the game does not end and it's Turtle's turn, then Turtle must choose an integer $i$ such that $1 \\le i \\le m - 1$, set $a_i$ to $\\max(a_i, a_{i + 1})$, and remove $a_{i + 1}$.    * If the game does not end and it's Piggy's turn, then Piggy must choose an integer $i$ such that $1 \\le i \\le m - 1$, set $a_i$ to $\\min(a_i, a_{i + 1})$, and remove $a_{i + 1}$. \n\nTurtle wants to maximize the value of $a_1$ in the end, while Piggy wants to minimize the value of $a_1$ in the end. Find the value of $a_1$ in the end if both players play optimally.\n\nYou can refer to notes for further clarification.\n\nInput Format:\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($2 \\le n \\le 10^5$) \u2014 the length of the sequence.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\le a_i \\le 10^5$) \u2014 the elements of the sequence $a$.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $10^5$.\n\nOutput Format:\nFor each test case, output a single integer \u2014 the value of $a_1$ in the end if both players play optimally.\n\nTags:\n['games', 'greedy', 'sortings']\n\nTime Limit: 1000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "5\n2\n1 2\n3\n1 1 2\n3\n1 2 3\n5\n3 1 2 2 3\n10\n10 2 5 2 7 9 2 5 10 7",
                "output": "2\n1\n2\n2\n7"
            }
        ]
    },
    {
        "problem": "\nTurtle gives you a string $s$, consisting of lowercase Latin letters.\n\nTurtle considers a pair of integers $(i, j)$ ($1 \\le i < j \\le n$) to be a pleasant pair if and only if there exists an integer $k$ such that $i \\le k < j$ and both of the following two conditions hold:\n\n  * $s_k \\ne s_{k + 1}$;    * $s_k \\ne s_i$ or $s_{k + 1} \\ne s_j$. \n\nBesides, Turtle considers a pair of integers $(i, j)$ ($1 \\le i < j \\le n$) to be a good pair if and only if $s_i = s_j$ or $(i, j)$ is a pleasant pair.\n\nTurtle wants to reorder the string $s$ so that the number of good pairs is maximized. Please help him!\n\nInput Format:\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($2 \\le n \\le 2 \\cdot 10^5$) \u2014 the length of the string.\n\nThe second line of each test case contains a string $s$ of length $n$, consisting of lowercase Latin letters.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\nOutput Format:\nFor each test case, output the string $s$ after reordering so that the number of good pairs is maximized. If there are multiple answers, print any of them.\n\nTags:\n['constructive algorithms', 'greedy', 'sortings', 'strings']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "5\n3\nabc\n5\nedddf\n6\nturtle\n8\npppppppp\n10\ncodeforces",
                "output": "acb\nddedf\nurtlet\npppppppp\ncodeforces"
            }
        ]
    },
    {
        "problem": "\nThe two versions are different problems. In this version of the problem, you can choose the same integer twice or more. You can make hacks only if both versions are solved.\n\nOne day, Turtle was playing with $n$ sequences. Let the length of the $i$-th sequence be $l_i$. Then the $i$-th sequence was $a_{i, 1}, a_{i, 2}, \\ldots, a_{i, l_i}$.\n\nPiggy gave Turtle a problem to solve when Turtle was playing. The statement of the problem was:\n\n  * There was a non-negative integer $x$ at first. Turtle would perform an arbitrary number (possibly zero) of operations on the integer.    * In each operation, Turtle could choose an integer $i$ such that $1 \\le i \\le n$, and set $x$ to $\\text{mex}^{\\dagger}(x, a_{i, 1}, a_{i, 2}, \\ldots, a_{i, l_i})$.    * Turtle was asked to find the answer, which was the maximum value of $x$ after performing an arbitrary number of operations. \n\nTurtle solved the above problem without difficulty. He defined $f(k)$ as the answer to the above problem when the initial value of $x$ was $k$.\n\nThen Piggy gave Turtle a non-negative integer $m$ and asked Turtle to find the value of $\\sum\\limits_{i = 0}^m f(i)$ (i.e., the value of $f(0) + f(1) + \\ldots + f(m)$). Unfortunately, he couldn't solve this problem. Please help him!\n\n$^{\\dagger}\\text{mex}(c_1, c_2, \\ldots, c_k)$ is defined as the smallest non-negative integer $x$ which does not occur in the sequence $c$. For example, $\\text{mex}(2, 2, 0, 3)$ is $1$, $\\text{mex}(1, 2)$ is $0$.\n\nInput Format:\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains two integers $n, m$ ($1 \\le n \\le 2 \\cdot 10^5, 0 \\le m \\le 10^9$).\n\nEach of the following $n$ lines contains several integers. The first integer $l_i$ ($1 \\le l_i \\le 2 \\cdot 10^5$) represents the length of the $i$-th sequence, and the following $l_i$ integers $a_{i, 1}, a_{i, 2}, \\ldots, a_{i, l_i}$ ($0 \\le a_{i, j} \\le 10^9$) represent the elements of the $i$-th sequence.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$, and the sum of $\\sum l_i$ over all test cases does not exceed $2 \\cdot 10^5$.\n\nOutput Format:\nFor each test case, output a single integer \u2014 the value of $\\sum\\limits_{i = 0}^m f(i)$.\n\nTags:\n['greedy', 'math']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "6\n3 4\n2 0 2\n3 2 3 3\n4 7 0 1 5\n3 4\n5 0 2 0 4 11\n1 1\n5 1 3 0 3 3\n2 50\n2 1 2\n2 1 2\n1 1\n7 1 2 4 1 4 9 5\n4 114514\n2 2 2\n5 7 3 6 0 3\n3 0 1 1\n5 0 9 2 1 5\n5 1919810\n1 2\n2 324003 0\n3 1416324 2 1460728\n4 1312631 2 0 1415195\n5 1223554 192248 2 1492515 725556",
                "output": "16\n20\n1281\n6\n6556785365\n1842836177961"
            }
        ]
    },
    {
        "problem": "\nThe two versions are different problems. In this version of the problem, you can't choose the same integer twice or more. You can make hacks only if both versions are solved.\n\nOne day, Turtle was playing with $n$ sequences. Let the length of the $i$-th sequence be $l_i$. Then the $i$-th sequence was $a_{i, 1}, a_{i, 2}, \\ldots, a_{i, l_i}$.\n\nPiggy gave Turtle a problem to solve when Turtle was playing. The statement of the problem was:\n\n  * There was a non-negative integer $x$ at first. Turtle would perform an arbitrary number (possibly zero) of operations on the integer.    * In each operation, Turtle could choose an integer $i$ such that $1 \\le i \\le n$ and $i$ wasn't chosen before, and set $x$ to $\\text{mex}^{\\dagger}(x, a_{i, 1}, a_{i, 2}, \\ldots, a_{i, l_i})$.    * Turtle was asked to find the answer, which was the maximum value of $x$ after performing an arbitrary number of operations. \n\nTurtle solved the above problem without difficulty. He defined $f(k)$ as the answer to the above problem when the initial value of $x$ was $k$.\n\nThen Piggy gave Turtle a non-negative integer $m$ and asked Turtle to find the value of $\\sum\\limits_{i = 0}^m f(i)$ (i.e., the value of $f(0) + f(1) + \\ldots + f(m)$). Unfortunately, he couldn't solve this problem. Please help him!\n\n$^{\\dagger}\\text{mex}(c_1, c_2, \\ldots, c_k)$ is defined as the smallest non-negative integer $x$ which does not occur in the sequence $c$. For example, $\\text{mex}(2, 2, 0, 3)$ is $1$, $\\text{mex}(1, 2)$ is $0$.\n\nInput Format:\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains two integers $n, m$ ($1 \\le n \\le 2 \\cdot 10^5, 0 \\le m \\le 10^9$).\n\nEach of the following $n$ lines contains several integers. The first integer $l_i$ ($1 \\le l_i \\le 2 \\cdot 10^5$) represents the length of the $i$-th sequence, and the following $l_i$ integers $a_{i, 1}, a_{i, 2}, \\ldots, a_{i, l_i}$ ($0 \\le a_{i, j} \\le 10^9$) represent the elements of the $i$-th sequence.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$ and the sum of $\\sum l_i$ over all test cases does not exceed $2 \\cdot 10^5$.\n\nOutput Format:\nFor each test case, output a single integer \u2014 the value of $\\sum\\limits_{i = 0}^m f(i)$.\n\nTags:\n['dfs and similar', 'dp', 'graphs', 'greedy', 'implementation', 'math']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "6\n3 4\n2 0 2\n3 2 3 3\n4 7 0 1 5\n3 4\n5 0 2 0 4 11\n1 1\n5 1 3 0 3 3\n2 50\n2 1 2\n2 1 2\n1 1\n7 1 2 4 1 4 9 5\n4 114514\n2 2 2\n5 7 3 6 0 3\n3 0 1 1\n5 0 9 2 1 5\n5 1919810\n1 2\n2 324003 0\n3 1416324 2 1460728\n4 1312631 2 0 1415195\n5 1223554 192248 2 1492515 725556",
                "output": "16\n18\n1281\n4\n6556785365\n1842836177961"
            }
        ]
    },
    {
        "problem": "\nThis is an easy version of this problem. The differences between the versions are the constraint on $m$ and $r_i < l_{i + 1}$ holds for each $i$ from $1$ to $m - 1$ in the easy version. You can make hacks only if both versions of the problem are solved.\n\nTurtle gives you $m$ intervals $[l_1, r_1], [l_2, r_2], \\ldots, [l_m, r_m]$. He thinks that a permutation $p$ is interesting if there exists an integer $k_i$ for every interval ($l_i \\le k_i < r_i$), and if he lets $a_i = \\max\\limits_{j = l_i}^{k_i} p_j, b_i = \\min\\limits_{j = k_i + 1}^{r_i} p_j$ for every integer $i$ from $1$ to $m$, the following condition holds:\n\n$$\\max\\limits_{i = 1}^m a_i < \\min\\limits_{i = 1}^m b_i$$\n\nTurtle wants you to calculate the maximum number of inversions of all interesting permutations of length $n$, or tell him if there is no interesting permutation.\n\nAn inversion of a permutation $p$ is a pair of integers $(i, j)$ ($1 \\le i < j \\le n$) such that $p_i > p_j$.\n\nInput Format:\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^3$). The description of the test cases follows.\n\nThe first line of each test case contains two integers $n, m$ ($2 \\le n \\le 5 \\cdot 10^3, 0 \\le m \\le \\frac{n}{2}$) \u2014 the length of the permutation and the number of intervals.\n\nThe $i$-th of the following $m$ lines contains two integers $l_i, r_i$ ($1 \\le l_i < r_i \\le n$) \u2014 the $i$-th interval.\n\nAdditional constraint on the input in this version: $r_i < l_{i + 1}$ holds for each $i$ from $1$ to $m - 1$.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $5 \\cdot 10^3$.\n\nOutput Format:\nFor each test case, if there is no interesting permutation, output a single integer $-1$.\n\nOtherwise, output a single integer \u2014 the maximum number of inversions.\n\nTags:\n['brute force', 'divide and conquer', 'dp', 'greedy', 'math']\n\nTime Limit: 2000 ms\nMemory Limit: 512 MB\n",
        "tests": [
            {
                "input": "6\n2 0\n2 1\n1 2\n5 1\n2 4\n8 2\n1 4\n6 8\n7 2\n1 3\n4 7\n7 3\n1 2\n3 4\n5 6",
                "output": "1\n0\n8\n21\n15\n15"
            }
        ]
    },
    {
        "problem": "\nThis is a hard version of this problem. The differences between the versions are the constraint on $m$ and $r_i < l_{i + 1}$ holds for each $i$ from $1$ to $m - 1$ in the easy version. You can make hacks only if both versions of the problem are solved.\n\nTurtle gives you $m$ intervals $[l_1, r_1], [l_2, r_2], \\ldots, [l_m, r_m]$. He thinks that a permutation $p$ is interesting if there exists an integer $k_i$ for every interval ($l_i \\le k_i < r_i$), and if he lets $a_i = \\max\\limits_{j = l_i}^{k_i} p_j, b_i = \\min\\limits_{j = k_i + 1}^{r_i} p_j$ for every integer $i$ from $1$ to $m$, the following condition holds:\n\n$$\\max\\limits_{i = 1}^m a_i < \\min\\limits_{i = 1}^m b_i$$\n\nTurtle wants you to calculate the maximum number of inversions of all interesting permutations of length $n$, or tell him if there is no interesting permutation.\n\nAn inversion of a permutation $p$ is a pair of integers $(i, j)$ ($1 \\le i < j \\le n$) such that $p_i > p_j$.\n\nInput Format:\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^3$). The description of the test cases follows.\n\nThe first line of each test case contains two integers $n, m$ ($2 \\le n \\le 5 \\cdot 10^3, 0 \\le m \\le 5 \\cdot 10^3$) \u2014 the length of the permutation and the number of intervals.\n\nThe $i$-th of the following $m$ lines contains two integers $l_i, r_i$ ($1 \\le l_i < r_i \\le n$) \u2014 the $i$-th interval. Note that there may exist identical intervals (i.e., there may exist two different indices $i, j$ such that $l_i = l_j$ and $r_i = r_j$).\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $5 \\cdot 10^3$ and the sum of $m$ over all test cases does not exceed $5 \\cdot 10^3$.\n\nOutput Format:\nFor each test case, if there is no interesting permutation, output a single integer $-1$.\n\nOtherwise, output a single integer \u2014 the maximum number of inversions.\n\nTags:\n['brute force', 'data structures', 'divide and conquer', 'dp', 'greedy', 'math', 'two pointers']\n\nTime Limit: 2000 ms\nMemory Limit: 512 MB\n",
        "tests": [
            {
                "input": "8\n2 0\n2 1\n1 2\n5 1\n2 4\n8 3\n1 4\n2 5\n7 8\n7 2\n1 4\n4 7\n7 3\n1 2\n1 7\n3 7\n7 4\n1 3\n4 7\n1 3\n4 7\n7 3\n1 2\n3 4\n5 6",
                "output": "1\n0\n8\n18\n-1\n-1\n15\n15"
            }
        ]
    },
    {
        "problem": "\nPiggy gives Turtle three sequences $a_1, a_2, \\ldots, a_n$, $b_1, b_2, \\ldots, b_n$, and $c_1, c_2, \\ldots, c_n$.\n\nTurtle will choose a subsequence of $1, 2, \\ldots, n$ of length $m$, let it be $p_1, p_2, \\ldots, p_m$. The subsequence should satisfy the following conditions:\n\n  * $a_{p_1} \\le a_{p_2} \\le \\cdots \\le a_{p_m}$;    * All $b_{p_i}$ for all indices $i$ are pairwise distinct, i.e., there don't exist two different indices $i$, $j$ such that $b_{p_i} = b_{p_j}$. \n\nHelp him find the maximum value of $\\sum\\limits_{i = 1}^m c_{p_i}$, or tell him that it is impossible to choose a subsequence of length $m$ that satisfies the conditions above.\n\nRecall that a sequence $a$ is a subsequence of a sequence $b$ if $a$ can be obtained from $b$ by the deletion of several (possibly, zero or all) elements.\n\nInput Format:\nThe first line contains two integers $n$ and $m$ ($1 \\le n \\le 3000$, $1 \\le m \\le 5$) \u2014 the lengths of the three sequences and the required length of the subsequence.\n\nThe second line contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\le a_i \\le n$) \u2014 the elements of the sequence $a$.\n\nThe third line contains $n$ integers $b_1, b_2, \\ldots, b_n$ ($1 \\le b_i \\le n$) \u2014 the elements of the sequence $b$.\n\nThe fourth line contains $n$ integers $c_1, c_2, \\ldots, c_n$ ($1 \\le c_i \\le 10^4$) \u2014 the elements of the sequence $c$.\n\nOutput Format:\nOutput a single integer \u2014 the maximum value of $\\sum\\limits_{i = 1}^m c_{p_i}$. If it is impossible to choose a subsequence of length $m$ that satisfies the conditions above, output $-1$.\n\nTags:\n['brute force', 'data structures', 'dp', 'greedy', 'math', 'probabilities', 'two pointers']\n\nTime Limit: 3000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "4 2\n2 3 4 2\n1 3 3 2\n1 4 2 3",
                "output": "5"
            },
            {
                "input": "7 3\n1 4 5 2 3 6 7\n1 2 2 1 1 3 2\n1 5 6 7 3 2 4",
                "output": "13"
            },
            {
                "input": "5 3\n1 2 3 4 5\n1 1 2 1 2\n5 4 3 2 1",
                "output": "-1"
            }
        ]
    },
    {
        "problem": "\nConsider a set of points on a line. The distance between two points $i$ and $j$ is $|i - j|$.\n\nThe point $i$ from the set is the closest to the point $j$ from the set, if there is no other point $k$ in the set such that the distance from $j$ to $k$ is strictly less than the distance from $j$ to $i$. In other words, all other points from the set have distance to $j$ greater or equal to $|i - j|$.\n\nFor example, consider a set of points $\\\\{1, 3, 5, 8\\\\}$:\n\n  * for the point $1$, the closest point is $3$ (other points have distance greater than $|1-3| = 2$);    * for the point $3$, there are two closest points: $1$ and $5$;    * for the point $5$, the closest point is $3$ (but not $8$, since its distance is greater than $|3-5|$);    * for the point $8$, the closest point is $5$. \n\nYou are given a set of points. You have to add an integer point into this set in such a way that it is different from every existing point in the set, and it becomes the closest point to every point in the set. Is it possible?\n\nInput Format:\nThe first line contains one integer $t$ ($1 \\le t \\le 1000$) \u2014 the number of test cases.\n\nEach test case consists of two lines:\n\n  * the first line contains one integer $n$ ($2 \\le n \\le 40$) \u2014 the number of points in the set;    * the second line contains $n$ integers $x_1, x_2, \\dots, x_n$ ($1 \\le x_1 < x_2 < \\dots < x_n \\le 100$) \u2014 the points from the set.\n\nOutput Format:\nFor each test case, print YES if it is possible to add a new point according to the conditions from the statement. Otherwise, print NO.\n\nTags:\n['implementation', 'math']\n\nTime Limit: 2000 ms\nMemory Limit: 512 MB\n",
        "tests": [
            {
                "input": "3\n2\n3 8\n2\n5 6\n6\n1 2 3 4 5 10",
                "output": "YES\nNO\nNO"
            }
        ]
    },
    {
        "problem": "\nThere are $100$ rooms arranged in a row and $99$ doors between them; the $i$-th door connects rooms $i$ and $i+1$. Each door can be either locked or unlocked. Initially, all doors are unlocked.\n\nWe say that room $x$ is reachable from room $y$ if all doors between them are unlocked.\n\nYou know that:\n\n  * Alice is in some room from the segment $[l, r]$;    * Bob is in some room from the segment $[L, R]$;    * Alice and Bob are in different rooms. \n\nHowever, you don't know the exact rooms they are in.\n\nYou don't want Alice and Bob to be able to reach each other, so you are going to lock some doors to prevent that. What's the smallest number of doors you have to lock so that Alice and Bob cannot meet, regardless of their starting positions inside the given segments?\n\nInput Format:\nThe first line contains a single integer $t$ ($1 \\le t \\le 10^4$) \u2014 the number of test cases.\n\nThe first line of each test case contains two integers $l$ and $r$ ($1 \\le l < r \\le 100$) \u2014 the bounds of the segment of rooms where Alice is located.\n\nThe second line of each test case contains two integers $L$ and $R$ ($1 \\le L < R \\le 100$) \u2014 the bounds of the segment of rooms where Bob is located.\n\nOutput Format:\nFor each test case, print a single integer \u2014 the smallest number of doors you have to lock so that Alice and Bob cannot meet, regardless of their starting positions inside the given segments.\n\nTags:\n['brute force', 'greedy']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "4\n1 2\n3 4\n2 5\n2 5\n3 7\n6 7\n4 5\n2 8",
                "output": "1\n3\n2\n3"
            }
        ]
    },
    {
        "problem": "\nAlice and Bob have $n$ items they'd like to split between them, so they decided to play a game. All items have a cost, and the $i$-th item costs $a_i$. Players move in turns starting from Alice.\n\nIn each turn, the player chooses one of the remaining items and takes it. The game goes on until no items are left.\n\nLet's say that $A$ is the total cost of items taken by Alice and $B$ is the total cost of Bob's items. The resulting score of the game then will be equal to $A - B$.\n\nAlice wants to maximize the score, while Bob wants to minimize it. Both Alice and Bob will play optimally.\n\nBut the game will take place tomorrow, so today Bob can modify the costs a little. He can increase the costs $a_i$ of several (possibly none or all) items by an integer value (possibly, by the same value or by different values for each item). However, the total increase must be less than or equal to $k$. Otherwise, Alice may suspect something. Note that Bob can't decrease costs, only increase.\n\nWhat is the minimum possible score Bob can achieve?\n\nInput Format:\nThe first line contains a single integer $t$ ($1 \\le t \\le 5000$) \u2014 the number of test cases. Then $t$ cases follow.\n\nThe first line of each test case contains two integers $n$ and $k$ ($2 \\le n \\le 2 \\cdot 10^5$; $0 \\le k \\le 10^9$) \u2014 the number of items and the maximum total increase Bob can make.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\dots, a_n$ ($1 \\le a_i \\le 10^9$) \u2014 the initial costs of the items.\n\nIt's guaranteed that the sum of $n$ over all test cases doesn't exceed $2 \\cdot 10^5$.\n\nOutput Format:\nFor each test case, print a single integer \u2014 the minimum possible score $A - B$ after Bob increases the costs of several (possibly none or all) items.\n\nTags:\n['games', 'greedy', 'sortings']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "4\n2 5\n1 10\n3 0\n10 15 12\n4 6\n3 1 2 4\n2 4\n6 9",
                "output": "4\n13\n0\n0"
            }
        ]
    },
    {
        "problem": "\nThere are $n$ cities located on a straight line. The cities are numbered from $1$ to $n$.\n\nPortals are used to move between cities. There are $4$ colors of portals: blue, green, red, and yellow. Each city has portals of two different colors. You can move from city $i$ to city $j$ if they have portals of the same color (for example, you can move between a \"blue-red\" city and a \"blue- green\" city). This movement costs $|i-j|$ coins.\n\nYour task is to answer $q$ independent queries: calculate the minimum cost to move from city $x$ to city $y$.\n\nInput Format:\nThe first line contains a single integer $t$ ($1 \\le t \\le 10^4$) \u2014 the number of test cases.\n\nThe first line of each test case contains two integers $n$ and $q$ ($1 \\le n, q \\le 2 \\cdot 10^5$) \u2014 the number of cities and the number of queries, respectively.\n\nThe second line contains $n$ strings of the following types: BG, BR, BY, GR, GY, or RY; the $i$-th of them describes the portals located in the $i$-th city; the symbol B indicates that there is a blue portal in the city, G \u2014 green, R \u2014 red, and Y \u2014 yellow.\n\nThe $j$-th of the next $q$ lines contains two integers $x_j$ and $y_j$ ($1 \\le x_j, y_j \\le n$) \u2014 the description of the $j$-th query.\n\nAdditional constraints on the input:\n\n  * the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$;    * the sum of $q$ over all test cases does not exceed $2 \\cdot 10^5$.\n\nOutput Format:\nFor each query, print a single integer \u2014 the minimum cost to move from city $x$ to city $y$ (or $-1$ if it is impossible).\n\nTags:\n['binary search', 'brute force', 'data structures', 'graphs', 'greedy', 'implementation', 'shortest paths']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "2\n4 5\nBR BR GY GR\n1 2\n3 1\n4 4\n1 4\n4 2\n2 1\nBG RY\n1 2",
                "output": "1\n4\n0\n3\n2\n-1"
            }
        ]
    },
    {
        "problem": "\nTwo players, Alice and Bob, are playing a game. They have $n$ piles of stones, with the $i$-th pile initially containing $a_i$ stones.\n\nOn their turn, a player can choose any pile of stones and take any positive number of stones from it, with one condition:\n\n  * let the current number of stones in the pile be $x$. It is not allowed to take from the pile a number of stones $y$ such that the greatest common divisor of $x$ and $y$ is not equal to $1$. \n\nThe player who cannot make a move loses. Both players play optimally (that is, if a player has a strategy that allows them to win, no matter how the opponent responds, they will win). Alice goes first.\n\nDetermine who will win.\n\nInput Format:\nThe first line contains a single integer $t$ ($1 \\le t \\le 10^4$) \u2014 the number of test cases.\n\nEach test case consists of two lines:\n\n  * the first line contains a single integer $n$ ($1 \\le n \\le 3 \\cdot 10^5$);    * the second line contains $n$ integers $a_1, a_2, \\dots, a_n$ ($1 \\le a_i \\le 10^7$). \n\nAdditional constraint on the input: the sum of $n$ across all test cases does not exceed $3 \\cdot 10^5$.\n\nOutput Format:\nFor each test case, output Alice if Alice wins, or Bob if Bob wins.\n\nTags:\n['brute force', 'games', 'math', 'number theory']\n\nTime Limit: 2000 ms\nMemory Limit: 512 MB\n",
        "tests": [
            {
                "input": "3\n3\n3 2 9\n4\n3 3 6 1\n5\n1 2 3 4 5",
                "output": "Bob\nAlice\nBob"
            }
        ]
    },
    {
        "problem": "\nYou are given an array $a$ consisting of $n$ integers.\n\nLet the function $f(b)$ return the minimum number of operations needed to make an array $b$ a palindrome. The operations you can make are:\n\n  * choose two adjacent elements $b_i$ and $b_{i+1}$, remove them, and replace them with a single element equal to $(b_i + b_{i + 1})$;    * or choose an element $b_i > 1$, remove it, and replace it with two positive integers $x$ and $y$ ($x > 0$ and $y > 0$) such that $x + y = b_i$. \n\nFor example, from an array $b=[2, 1, 3]$, you can obtain the following arrays in one operation: $[1, 1, 1, 3]$, $[2, 1, 1, 2]$, $[3, 3]$, $[2, 4]$, or $[2, 1, 2, 1]$.\n\nCalculate $\\displaystyle \\left(\\sum_{1 \\le l \\le r \\le n}{f(a[l..r])}\\right)$, where $a[l..r]$ is the subarray of $a$ from index $l$ to index $r$, inclusive. In other words, find the sum of the values of the function $f$ for all subarrays of the array $a$.\n\nInput Format:\nThe first line contains a single integer $t$ ($1 \\le t \\le 1000$) \u2014 the number of test cases.\n\nThe first line of each test case contains a single integer $n$ ($1 \\le n \\le 2000$).\n\nThe second line contains $n$ integers $a_1, a_2, \\dots, a_n$ ($1 \\le a_i \\le 10^5$).\n\nAdditional constraint on the input: the sum of $n$ over all test cases does not exceed $2000$.\n\nOutput Format:\nFor each test case, print a single integer \u2014 the sum of the values of the function $f$ for all subarrays of the array $a$.\n\nTags:\n['binary search', 'brute force', 'data structures', 'greedy', 'math']\n\nTime Limit: 5000 ms\nMemory Limit: 512 MB\n",
        "tests": [
            {
                "input": "4\n3\n2 1 3\n4\n1 1 1 1\n5\n4 2 3 1 5\n4\n1 2 1 2",
                "output": "3\n0\n14\n5"
            }
        ]
    },
    {
        "problem": "\nLet's define the operation of compressing a string $t$, consisting of at least $2$ digits from $1$ to $9$, as follows:\n\n  * split it into an even number of non-empty substrings \u2014 let these substrings be $t_1, t_2, \\dots, t_m$ (so, $t = t_1 + t_2 + \\dots + t_m$, where $+$ is the concatenation operation);    * write the string $t_2$ $t_1$ times, then the string $t_4$ $t_3$ times, and so on. \n\nFor example, for a string \"12345\", one could do the following: split it into (\"1\", \"23\", \"4\", \"5\"), and write \"235555\".\n\nLet the function $f(t)$ for a string $t$ return the minimum length of the string that can be obtained as a result of that process.\n\nYou are given a string $s$, consisting of $n$ digits from $1$ to $9$, and an integer $k$. Calculate the value of the function $f$ for all contiguous substrings of $s$ of length exactly $k$.\n\nInput Format:\nThe first line contains two integers $n$ and $k$ ($2 \\le k \\le n \\le 2 \\cdot 10^5$).\n\nThe second line contains the string $s$ ($|s| = n$), consisting only of digits from $1$ to $9$.\n\nOutput Format:\nOutput $n - k + 1$ integers \u2014 $f(s_{1,k}), f(s_{2,k+1}), \\dots, f(s_{n - k + 1, n})$.\n\nTags:\n['data structures', 'dp', 'matrices']\n\nTime Limit: 2000 ms\nMemory Limit: 1024 MB\n",
        "tests": [
            {
                "input": "4 4\n5999",
                "output": "14"
            },
            {
                "input": "10 3\n1111111111",
                "output": "2 2 2 2 2 2 2 2"
            },
            {
                "input": "11 4\n49998641312",
                "output": "12 18 17 15 12 7 7 2"
            }
        ]
    },
    {
        "problem": "\nNarek has to spend 2 hours with some 2-year-old kids at the kindergarten. He wants to teach them competitive programming, and their first lesson is about palindromes.\n\nNarek found out that the kids only know the vowels of the English alphabet (the letters $\\mathtt{a}$, $\\mathtt{e}$, $\\mathtt{i}$, $\\mathtt{o}$, and $\\mathtt{u}$), so Narek needs to make a string that consists of vowels only. After making the string, he'll ask the kids to count the number of subsequences that are palindromes. Narek wants to keep it simple, so he's looking for a string such that the amount of palindrome subsequences is minimal.\n\nHelp Narek find a string of length $n$, consisting of lowercase English vowels only (letters $\\mathtt{a}$, $\\mathtt{e}$, $\\mathtt{i}$, $\\mathtt{o}$, and $\\mathtt{u}$), which minimizes the amount of palindrome$^{\\dagger}$ subsequences$^{\\ddagger}$ in it.\n\n$^{\\dagger}$ A string is called a palindrome if it reads the same from left to right and from right to left.\n\n$^{\\ddagger}$ String $t$ is a subsequence of string $s$ if $t$ can be obtained from $s$ by removing several (possibly, zero or all) characters from $s$ and concatenating the remaining ones, without changing their order. For example, $\\mathtt{odocs}$ is a subsequence of $\\texttt{c}{\\color{red}{\\texttt{od}}}\\texttt{ef}{\\color{red}{\\texttt{o}}}\\texttt{r}{\\color{red}{\\texttt{c}}}\\texttt{e}{\\color{red}{\\texttt{s}}}$.\n\nInput Format:\nThe first line of the input contains a single integer $t$ ($1 \\le t \\le 100$) \u2014 the number of test cases. Subsequently, the description of each test case follows.\n\nThe only line of each test case contains a single integer $n$ ($1 \\le n \\le 100$) \u2014 the size of the string.\n\nOutput Format:\nFor each test case, output any string of length $n$ that satisfies the above conditions.\n\nTags:\n['combinatorics', 'constructive algorithms', 'greedy', 'math']\n\nTime Limit: 1000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "3\n2\n3\n6",
                "output": "uo\niae\noeiiua"
            }
        ]
    },
    {
        "problem": "\nThis is the easy version of the problem. The only differences between the two versions are the constraints on $m$ and $q$. In this version, $m=2$ and $q=1$. You can make hacks only if both versions of the problem are solved.\n\nNarek and Tsovak were busy preparing this round, so they have not managed to do their homework and decided to steal David's homework. Their strict teacher noticed that David has no homework and now wants to punish him. She hires other teachers to help her catch David. And now $m$ teachers together are chasing him. Luckily, the classroom is big, so David has many places to hide.\n\nThe classroom can be represented as a one-dimensional line with cells from $1$ to $n$, inclusive.\n\nAt the start, all $m$ teachers and David are in distinct cells. Then they make moves. During each move\n\n  * David goes to an adjacent cell or stays at the current one.    * Then, each of the $m$ teachers simultaneously goes to an adjacent cell or stays at the current one. \n\nThis continues until David is caught. David is caught if any of the teachers (possibly more than one) is located in the same cell as David. Everyone sees others' moves, so they all act optimally.\n\nYour task is to find how many moves it will take for the teachers to catch David if they all act optimally.\n\nActing optimally means the student makes his moves in a way that maximizes the number of moves the teachers need to catch him; and the teachers coordinate with each other to make their moves in a way that minimizes the number of moves they need to catch the student.\n\nAlso, as Narek and Tsovak think this task is easy, they decided to give you $q$ queries on David's position. Note: this is the easy version, and you are given only one query.\n\nInput Format:\nIn the first line of the input, you are given a single integer $t$ ($1 \\le t \\le 10^5$) \u2014 the number of test cases. The description of each test case follows.\n\nIn the first line of each test case, you are given three integers $n$, $m$, and $q$ ($3 \\le n \\le 10^9$, $m=2$, $q=1$) \u2014 the number of cells on the line, the number of teachers, and the number of queries.\n\nIn the second line of each test case, you are given $m$ distinct integers $b_1, b_2, \\ldots, b_m$ ($1 \\le b_i \\le n$) \u2014 the cell numbers of the teachers.\n\nIn the third line of each test case, you are given $q$ integers $a_1, a_2, \\ldots, a_q$ ($1 \\le a_i \\le n$) \u2014 David's cell number for every query.\n\nIt is guaranteed that for any $i$, $j$ such that $1 \\le i \\le m$ and $1 \\le j \\le q$, $b_i \\neq a_j$.\n\nOutput Format:\nFor each test case, output $q$ lines, the $i$-th of them containing the answer of the $i$-th query.\n\nTags:\n['greedy', 'math', 'sortings']\n\nTime Limit: 1500 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "3\n10 2 1\n1 4\n2\n8 2 1\n3 6\n1\n8 2 1\n3 6\n8",
                "output": "1\n2\n2"
            }
        ]
    },
    {
        "problem": "\nThis is the hard version of the problem. The only differences between the two versions are the constraints on $m$ and $q$. In this version, $m, q \\le 10^5$. You can make hacks only if both versions of the problem are solved.\n\nNarek and Tsovak were busy preparing this round, so they have not managed to do their homework and decided to steal David's homework. Their strict teacher noticed that David has no homework and now wants to punish him. She hires other teachers to help her catch David. And now $m$ teachers together are chasing him. Luckily, the classroom is big, so David has many places to hide.\n\nThe classroom can be represented as a one-dimensional line with cells from $1$ to $n$, inclusive.\n\nAt the start, all $m$ teachers and David are in distinct cells. Then they make moves. During each move\n\n  * David goes to an adjacent cell or stays at the current one.    * Then, each of the $m$ teachers simultaneously goes to an adjacent cell or stays at the current one. \n\nThis continues until David is caught. David is caught if any of the teachers (possibly more than one) is located in the same cell as David. Everyone sees others' moves, so they all act optimally.\n\nYour task is to find how many moves it will take for the teachers to catch David if they all act optimally.\n\nActing optimally means the student makes his moves in a way that maximizes the number of moves the teachers need to catch him; and the teachers coordinate with each other to make their moves in a way that minimizes the number of moves they need to catch the student.\n\nAlso, as Narek and Tsovak think this task is easy, they decided to give you $q$ queries on David's position.\n\nInput Format:\nIn the first line of the input, you are given a single integer $t$ ($1 \\le t \\le 10^5$) \u2014 the number of test cases. The description of each test case follows.\n\nIn the first line of each test case, you are given three integers $n$, $m$, and $q$ ($3 \\le n \\le 10^9$, $1 \\le m, q \\le 10^5$) \u2014 the number of cells on the line, the number of teachers, and the number of queries.\n\nIn the second line of each test case, you are given $m$ distinct integers $b_1, b_2, \\ldots, b_m$ ($1 \\le b_i \\le n$) \u2014 the cell numbers of the teachers.\n\nIn the third line of each test case, you are given $q$ integers $a_1, a_2, \\ldots, a_q$ ($1 \\le a_i \\le n$) \u2014 David's cell number for every query.\n\nIt is guaranteed that for any $i$, $j$ such that $1 \\le i \\le m$ and $1 \\le j \\le q$, $b_i \\neq a_j$.\n\nIt is guaranteed that the sum of values of $m$ over all test cases does not exceed $2 \\cdot 10^5$.\n\nIt is guaranteed that the sum of values of $q$ over all test cases does not exceed $2 \\cdot 10^5$.\n\nOutput Format:\nFor each test case, output $q$ lines, the $i$-th of them containing the answer of the $i$-th query.\n\nTags:\n['binary search', 'greedy', 'math', 'sortings']\n\nTime Limit: 1500 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "2\n8 1 1\n6\n3\n10 3 3\n1 4 8\n2 3 10",
                "output": "5\n1\n1\n2"
            }
        ]
    },
    {
        "problem": "\nNarek is too lazy to create the third problem of this contest. His friend Artur suggests that he should use ChatGPT. ChatGPT creates $n$ problems, each consisting of $m$ letters, so Narek has $n$ strings. To make the problem harder, he combines the problems by selecting some of the $n$ strings possibly none and concatenating them without altering their order. His chance of solving the problem is defined as $score_n - score_c$, where $score_n$ is Narek's score and $score_c$ is ChatGPT's score.\n\nNarek calculates $score_n$ by examining the selected string (he moves from left to right). He initially searches for the letter $\\texttt{\"n\"}$, followed by $\\texttt{\"a\"}$, $\\texttt{\"r\"}$, $\\texttt{\"e\"}$, and $\\texttt{\"k\"}$. Upon finding all occurrences of these letters, he increments $score_n$ by $5$ and resumes searching for $\\texttt{\"n\"}$ again (he doesn't go back, and he just continues from where he left off).\n\nAfter Narek finishes, ChatGPT scans through the array and increments $score_c$ by $1$ for each letter $\\texttt{\"n\"}$, $\\texttt{\"a\"}$, $\\texttt{\"r\"}$, $\\texttt{\"e\"}$, or $\\texttt{\"k\"}$ that Narek fails to utilize (note that if Narek fails to complete the last occurrence by finding all of the $5$ letters, then all of the letters he used are counted in ChatGPT's score $score_c$, and Narek doesn't get any points if he doesn't finish finding all the 5 letters).\n\nNarek aims to maximize the value of $score_n - score_c$ by selecting the most optimal subset of the initial strings.\n\nInput Format:\nIn the first line of the input, you're given a single integer $t$ ($1 \\le t \\le 10^5$), the number of test cases. Then the description of each test case follows.\n\nIn the first line of each test case, you're given two integers $n, m$ ($1 \\le n, m \\le 10^3$), the number of strings and the length of each string.\n\nIn the next $n$ lines, you're given $n$ strings, each having a length of $m$. The strings only contain lowercase letters of the English alphabet.\n\nThe sum of values of $n \\cdot m$ over all test cases does not exceed $10^6$.\n\nOutput Format:\nFor each test case, output a single integer: the maximal possible value of $score_n - score_c$.\n\nTags:\n['dp', 'implementation', 'strings']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "4\n5 2\nnn\naa\nrr\nee\nkk\n1 5\nnarek\n1 4\nnare\n5 7\nnrrarek\nnrnekan\nuuuuuuu\nppppppp\nnkarekz",
                "output": "0\n5\n0\n7"
            }
        ]
    },
    {
        "problem": "\nYou are given two arrays $a_1, a_2, \\ldots, a_n$ and $b_1, b_2, \\ldots, b_n$.\n\nYou must perform the following operation exactly once:\n\n  * choose any indices $l$ and $r$ such that $1 \\le l \\le r \\le n$;    * swap $a_i$ and $b_i$ for all $i$ such that $l \\leq i \\leq r$. \n\nFind the maximum possible value of $\\text{gcd}(a_1, a_2, \\ldots, a_n) + \\text{gcd}(b_1, b_2, \\ldots, b_n)$ after performing the operation exactly once. Also find the number of distinct pairs $(l, r)$ which achieve the maximum value.\n\nInput Format:\nIn the first line of the input, you are given a single integer $t$ ($1 \\le t \\le 10^5$), the number of test cases. Then the description of each test case follows.\n\nIn the first line of each test case, you are given a single integer $n$ ($1 \\le n \\le 2 \\cdot 10^5$), representing the number of integers in each array.\n\nIn the next line, you are given $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\le a_i \\le 10^9$) \u2014 the elements of the array $a$.\n\nIn the last line, you are given $n$ integers $b_1, b_2, \\ldots, b_n$ ($1 \\le b_i \\le 10^9$) \u2014 the elements of the array $b$.\n\nThe sum of values of $n$ over all test cases does not exceed $5 \\cdot 10^5$.\n\nOutput Format:\nFor each test case, output a line with two integers: the maximum value of $\\text{gcd}(a_1, a_2, \\ldots, a_n) + \\text{gcd}(b_1, b_2, \\ldots, b_n)$ after performing the operation exactly once, and the number of ways.\n\nTags:\n['binary search', 'brute force', 'data structures', 'divide and conquer', 'implementation', 'number theory']\n\nTime Limit: 4000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "5\n8\n11 4 16 17 3 24 25 8\n8 10 4 21 17 18 25 21\n4\n6 4 24 13\n15 3 1 14\n2\n13 14\n5 8\n8\n20 17 15 11 21 10 3 7\n9 9 4 20 14 9 13 1\n2\n18 13\n15 20",
                "output": "2 36\n3 2\n2 3\n2 36\n6 1"
            }
        ]
    },
    {
        "problem": "\nThis is the easy version of the problem. The differences between the two versions are the constraints on all the variables. You can make hacks only if both versions of the problem are solved.\n\nTsovak and Narek are playing a game. They have an array $a$ and a matrix $b$ of integers with $n$ rows and $m$ columns, numbered from $1$. The cell in the $i$-th row and the $j$-th column is $(i, j)$.\n\nThey are looking for the elements of $a$ in turns; Tsovak starts first. Each time a player looks for a cell in the matrix containing the current element of $a$ (Tsovak looks for the first, then Narek looks for the second, etc.). Let's say a player has chosen the cell $(r, c)$. The next player has to choose his cell in the submatrix starting at $(r + 1, c + 1)$ and ending in $(n, m)$ (the submatrix can be empty if $r=n$ or $c=m$). If a player cannot find such a cell (or the remaining submatrix is empty) or the array ends (the previous player has chosen the last element), then he loses.\n\nYour task is to determine the winner if the players play optimally.\n\nInput Format:\nThe first line of the input contains $t$ ($1 \\le t \\le 300$) \u2013 the number of test cases.\n\nThe first line of each test case contains three integers $l$, $n$, and $m$ ($1 \\le l, n, m \\le 300$) \u2013 the size of the array and the sizes of the matrix.\n\nThe second line contains $l$ integers $a_1, a_2, a_3, \\ldots a_l$ ($1 \\le a_i \\le \\min(7, n \\cdot m)$) \u2013 the elements of the array $a$.\n\nThe $i$-th of the last $n$ lines contains $m$ integers $b_{i,1}, b_{i,2}, b_{i,3}, \\ldots b_{i,m}$ ($1 \\le b_{i,j} \\le \\min(7, n \\cdot m)$) \u2013 representing the $i$-th row of the matrix.\n\nIt is guaranteed that the sum of $n \\cdot m$ over all test cases does not exceed $10^5$.\n\nIt is guaranteed that the sum of $l$ over all test cases does not exceed $300$.\n\nOutput Format:\nYou should output $t$ lines, the $i$-th of them containing a character representing the answer of the $i$-th test case: \"T\" if Tsovak wins or \"N\", otherwise (without quotes).\n\nTags:\n['dp', 'games', 'greedy', 'implementation']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "3\n2 2 3\n1 2\n1 3 5\n4 5 2\n2 2 4\n1 2\n1 1 3 2\n4 2 5 1\n2 4 2\n1 2\n3 4\n5 5\n5 5\n5 5",
                "output": "N\nT\nN"
            }
        ]
    },
    {
        "problem": "\nThis is the hard version of the problem. The differences between the two versions are the constraints on all the variables. You can make hacks only if both versions of the problem are solved.\n\nTsovak and Narek are playing a game. They have an array $a$ and a matrix $b$ of integers with $n$ rows and $m$ columns, numbered from $1$. The cell in the $i$-th row and the $j$-th column is $(i, j)$.\n\nThey are looking for the elements of $a$ in turns; Tsovak starts first. Each time a player looks for a cell in the matrix containing the current element of $a$ (Tsovak looks for the first, then Narek looks for the second, etc.). Let's say a player has chosen the cell $(r, c)$. The next player has to choose his cell in the submatrix starting at $(r + 1, c + 1)$ and ending in $(n, m)$ (the submatrix can be empty if $r=n$ or $c=m$). If a player cannot find such a cell (or the remaining submatrix is empty) or the array ends (the previous player has chosen the last element), then he loses.\n\nYour task is to determine the winner if the players play optimally.\n\nNote: since the input is large, you may need to optimize input/output for this problem.\n\nFor example, in C++, it is enough to use the following lines at the start of the main() function:\n\n              int main() {         ios_base::sync_with_stdio(false);         cin.tie(NULL); cout.tie(NULL);     }\n\nInput Format:\nThe first line of the input contains $t$ ($1 \\le t \\le 1500$) \u2013 the number of test cases.\n\nThe first line of each test case contains three integers $l$, $n$, and $m$ ($1 \\le l, n, m \\le 1500$) \u2013 the size of the array and the sizes of the matrix.\n\nThe second line contains $l$ integers $a_1, a_2, a_3, \\ldots a_l$ ($1 \\le a_i \\le n \\cdot m$) \u2013 the elements of the array $a$.\n\nThe $i$-th of the last $n$ lines contains $m$ integers $b_{i,1}, b_{i,2}, b_{i,3}, \\ldots b_{i,m}$ ($1 \\le b_{i,j} \\le n \\cdot m$) \u2013 representing the $i$-th row of the matrix.\n\nIt is guaranteed that the sum of $n \\cdot m$ over all test cases does not exceed $3 \\cdot 10^6$.\n\nIt is guaranteed that the sum of $l$ over all test cases does not exceed $1500$.\n\nOutput Format:\nYou should output $t$ lines, the $i$-th of them containing a character representing the answer of the $i$-th test case: \"T\" if Tsovak wins or \"N\", otherwise (without quotes).\n\nTags:\n['data structures', 'dp', 'games', 'greedy', 'implementation']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "3\n2 2 3\n1 2\n1 3 6\n4 6 2\n2 2 4\n1 2\n1 1 3 2\n4 2 5 1\n2 4 2\n1 2\n3 4\n5 6\n7 8\n8 8",
                "output": "N\nT\nN"
            }
        ]
    },
    {
        "problem": "\nIris has a tree rooted at vertex $1$. Each vertex has a value of $\\mathtt 0$ or $\\mathtt 1$.\n\nLet's consider a leaf of the tree (the vertex $1$ is never considered a leaf) and define its weight. Construct a string formed by the values of the vertices on the path starting at the root and ending in this leaf. Then the weight of the leaf is the difference between the number of occurrences of $\\mathtt{10}$ and $\\mathtt{01}$ substrings in it.\n\nTake the following tree as an example. Green vertices have a value of $\\mathtt 1$ while white vertices have a value of $\\mathtt 0$.\n\n![](CDN_BASE_URL/712e8f1acc71d0401cf5eb23441e53a5)\n\n  * Let's calculate the weight of the leaf $5$: the formed string is $\\mathtt{10110}$. The number of occurrences of substring $\\mathtt{10}$ is $2$, the number of occurrences of substring $\\mathtt{01}$ is $1$, so the difference is $2 - 1 = 1$.   * Let's calculate the weight of the leaf $6$: the formed string is $\\mathtt{101}$. The number of occurrences of substring $\\mathtt{10}$ is $1$, the number of occurrences of substring $\\mathtt{01}$ is $1$, so the difference is $1 - 1 = 0$.\n\nThe score of a tree is defined as the number of leaves with non-zero weight in the tree.\n\nBut the values of some vertices haven't been decided and will be given to you as $\\texttt{?}$. Filling the blanks would be so boring, so Iris is going to invite Dora to play a game. On each turn, one of the girls chooses any of the remaining vertices with value $\\texttt{?}$ and changes its value to $\\mathtt{0}$ or $\\mathtt{1}$, with Iris going first. The game continues until there are no vertices with value $\\mathtt{?}$ left in the tree. Iris aims to maximize the score of the tree, while Dora aims to minimize that.\n\nAssuming that both girls play optimally, please determine the final score of the tree.\n\nInput Format:\nEach test consists of multiple test cases. The first line contains a single integer $t$ ($1 \\leq t \\leq 5\\cdot 10^4$) \u2014 the number of test cases. The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($2 \\leq n \\leq 10^5$) \u2014 the number of vertices in the tree.\n\nThe following $n - 1$ lines each contain two integers $u$ and $v$ ($1 \\leq u, v \\leq n$) \u2014 denoting an edge between vertices $u$ and $v$.\n\nIt's guaranteed that the given edges form a tree.\n\nThe last line contains a string $s$ of length $n$. The $i$-th character of $s$ represents the value of vertex $i$. It's guaranteed that $s$ only contains characters $\\mathtt{0}$, $\\mathtt{1}$ and $\\mathtt{?}$.\n\nIt is guaranteed that the sum of $n$ over all test cases doesn't exceed $2\\cdot 10^5$.\n\nOutput Format:\nFor each test case, output a single integer \u2014 the final score of the tree.\n\nTags:\n['constructive algorithms', 'dfs and similar', 'games', 'graphs', 'greedy', 'trees']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "6\n4\n1 2\n1 3\n4 1\n0101\n4\n1 2\n3 2\n2 4\n???0\n5\n1 2\n1 3\n2 4\n2 5\n?1?01\n6\n1 2\n2 3\n3 4\n5 3\n3 6\n?0????\n5\n1 2\n1 3\n1 4\n1 5\n11?1?\n2\n2 1\n??",
                "output": "2\n1\n1\n2\n1\n0"
            }
        ]
    },
    {
        "problem": "\nGiven a rooted tree with the root at vertex $1$. For any vertex $i$ ($1 < i \\leq n$) in the tree, there is an edge connecting vertices $i$ and $p_i$ ($1 \\leq p_i < i$), with a weight equal to $t_i$.\n\nIris does not know the values of $t_i$, but she knows that $\\displaystyle\\sum_{i=2}^n t_i = w$ and each of the $t_i$ is a non- negative integer.\n\nThe vertices of the tree are numbered in a special way: the numbers of the vertices in each subtree are consecutive integers. In other words, the vertices of the tree are numbered in the order of a depth-first search.\n\n![](CDN_BASE_URL/274244c032854fe172d47861e2eb9c02) The tree in this picture satisfies the condition. For example, in the subtree of vertex $2$, the vertex numbers are $2, 3, 4, 5$, which are consecutive integers. ![](CDN_BASE_URL/83174231191d329be697a6e3f67b5eb3) The tree in this picture does not satisfy the condition, as in the subtree of vertex $2$, the vertex numbers $2$ and $4$ are not consecutive integers.\n\nWe define $\\operatorname{dist}(u, v)$ as the length of the simple path between vertices $u$ and $v$ in the tree.\n\nNext, there will be $n - 1$ events:\n\n  * Iris is given integers $x$ and $y$, indicating that $t_x = y$. \n\nAfter each event, Iris wants to know the maximum possible value of $\\operatorname{dist}(i, i \\bmod n + 1)$ independently for each $i$ ($1\\le i\\le n$). She only needs to know the sum of these $n$ values. Please help Iris quickly get the answers.\n\nNote that when calculating the maximum possible values of $\\operatorname{dist}(i, i \\bmod n + 1)$ and $\\operatorname{dist}(j, j \\bmod n + 1)$ for $i \\ne j$, the unknown edge weights may be different.\n\nInput Format:\nEach test consists of multiple test cases. The first line contains a single integer $t$ ($1 \\leq t \\leq 10^4$) \u2014 the number of test cases. The description of the test cases follows.\n\nThe first line of each test case contains two integers $n$ and $w$ ($2 \\le n \\le 2 \\cdot 10^5$, $0 \\leq w \\leq 10^{12}$) \u2014 the number of vertices in the tree and the sum of the edge weights.\n\nThe second line of each test case contains $n - 1$ integers $p_2, p_3, \\ldots, p_n$ ($1 \\leq p_i < i$) \u2014 the description of the edges of the tree.\n\nThen follow $n-1$ lines indicating the events. Each line contains two integers $x$ and $y$ ($2 \\leq x \\leq n$, $0 \\leq y \\leq w$), indicating that $t_x = y$.\n\nIt is guaranteed that all $x$ in the events are distinct. It is also guaranteed that the sum of all $y$ equals $w$.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\nOutput Format:\nFor each test case, output one line containing $n-1$ integers, each representing the answer after each event.\n\nTags:\n['brute force', 'data structures', 'dfs and similar', 'dsu', 'math', 'trees']\n\nTime Limit: 3000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "4\n2 1000000000000\n1\n2 1000000000000\n4 9\n1 1 1\n2 2\n4 4\n3 3\n6 100\n1 2 3 2 1\n6 17\n3 32\n2 4\n4 26\n5 21\n10 511\n1 2 2 4 2 1 1 8 8\n3 2\n6 16\n10 256\n9 128\n2 1\n5 8\n8 64\n4 4\n7 32",
                "output": "2000000000000\n25 18 18\n449 302 247 200 200\n4585 4473 2681 1567 1454 1322 1094 1022 1022"
            }
        ]
    },
    {
        "problem": "\nLet there be a set that contains distinct positive integers. To expand the set to contain as many integers as possible, Eri can choose two integers $x\\neq y$ from the set such that their average $\\frac{x+y}2$ is still a positive integer and isn't contained in the set, and add it to the set. The integers $x$ and $y$ remain in the set.\n\nLet's call the set of integers consecutive if, after the elements are sorted, the difference between any pair of adjacent elements is $1$. For example, sets $\\\\{2\\\\}$, $\\\\{2, 5, 4, 3\\\\}$, $\\\\{5, 6, 8, 7\\\\}$ are consecutive, while $\\\\{2, 4, 5, 6\\\\}$, $\\\\{9, 7\\\\}$ are not.\n\nEri likes consecutive sets. Suppose there is an array $b$, then Eri puts all elements in $b$ into the set. If after a finite number of operations described above, the set can become consecutive, the array $b$ will be called brilliant.\n\nNote that if the same integer appears in the array multiple times, we only put it into the set once, as a set always contains distinct positive integers.\n\nEri has an array $a$ of $n$ positive integers. Please help him to count the number of pairs of integers $(l,r)$ such that $1 \\leq l \\leq r \\leq n$ and the subarray $a_l, a_{l+1}, \\ldots, a_r$ is brilliant.\n\nInput Format:\nEach test consists of multiple test cases. The first line contains a single integer $t$ ($1 \\leq t \\leq 10^4$) \u2014 the number of test cases. The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($1 \\leq n \\leq 4 \\cdot 10^5$) \u2014 length of the array $a$.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots a_n$ ($1 \\leq a_i \\leq 10^9$) \u2014 the elements of the array $a$.\n\nIt is guaranteed that the sum of $n$ over all test cases doesn't exceed $4 \\cdot 10^5$.\n\nOutput Format:\nFor each test case, output a single integer \u2014 the number of brilliant subarrays.\n\nTags:\n['data structures', 'divide and conquer', 'math', 'number theory', 'two pointers']\n\nTime Limit: 3000 ms\nMemory Limit: 512 MB\n",
        "tests": [
            {
                "input": "6\n2\n2 2\n6\n1 3 6 10 15 21\n5\n6 30 18 36 9\n1\n1000000000\n6\n1 1 4 5 1 4\n12\n70 130 90 90 90 108 612 500 451 171 193 193",
                "output": "3\n18\n5\n1\n18\n53"
            }
        ]
    },
    {
        "problem": "\nIris has just learned multiplication in her Maths lessons. However, since her brain is unable to withstand too complex calculations, she could not multiply two integers with the product greater than $k$ together. Otherwise, her brain may explode!\n\nHer teacher sets a difficult task every day as her daily summer holiday homework. Now she is given an array $a$ consisting of $n$ elements, and she needs to calculate the product of each two adjacent elements (that is, $a_1 \\cdot a_2$, $a_2 \\cdot a_3$, and so on). Iris wants her brain to work safely, and in order to do that, she would like to modify the array $a$ in such a way that $a_i \\cdot a_{i + 1} \\leq k$ holds for every $1 \\leq i < n$. There are two types of operations she can perform:\n\n  1. She can rearrange the elements of the array $a$ in an arbitrary way.   2. She can select an arbitrary element of the array $a$ and change its value to an arbitrary integer from $1$ to $k$. \n\nIris wants to minimize the number of operations of type $2$ that she uses.\n\nHowever, that's completely not the end of the summer holiday! Summer holiday lasts for $q$ days, and on the $i$-th day, Iris is asked to solve the Math homework for the subarray $b_{l_i}, b_{l_i + 1}, \\ldots, b_{r_i}$. Help Iris and tell her the minimum number of type $2$ operations she needs to perform for each day. Note that the operations are independent for each day, i.e. the array $b$ is not changed.\n\nInput Format:\nEach test consists of multiple test cases. The first line contains a single integer $t$ ($1 \\leq t \\leq 5\\cdot 10^4$) \u2014 the number of test cases. The description of the test cases follows.\n\nThe first line of each test case contains three integers $n$, $q$ and $k$ ($2 \\leq n \\leq 10^5$, $1 \\leq q \\leq 10^5$, $1 \\leq k \\leq 10^6$) \u2014 the length of array $b$, the number of days, and the upper bound for the multiplication calculation.\n\nThe second line of each test case contains $n$ integers $b_1, b_2, \\ldots, b_n$ ($1 \\leq b_i \\leq k$) \u2014 the elements of the array $b$.\n\nThen $q$ lines follow, the $i$-th of them contains two integers $l_i$ and $r_i$ ($1 \\leq l_i < r_i \\leq n$) \u2014 the boundaries of the subarray on the $i$-th day.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $10^5$, and the sum of $q$ over all test cases does not exceed $10^5$.\n\nOutput Format:\nFor each test, output a single line containing $q$ integers \u2014 the minimum number of operations of type $2$ needed for each day.\n\nTags:\n['data structures', 'greedy', 'implementation', 'math']\n\nTime Limit: 3000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "5\n3 1 1\n1 1 1\n1 3\n3 2 10\n1 10 9\n1 3\n2 3\n5 4 2\n2 2 2 2 2\n1 2\n2 4\n2 5\n1 5\n6 5 10\n3 2 5 10 10 1\n1 4\n3 6\n1 6\n2 5\n5 6\n10 10 10\n10 9 8 7 6 5 4 3 2 1\n1 10\n1 9\n1 8\n1 7\n2 10\n3 10\n4 10\n5 10\n3 9\n6 8",
                "output": "0 \n0 1 \n1 1 2 2 \n1 1 1 1 0 \n3 3 4 3 2 2 1 1 2 1"
            }
        ]
    },
    {
        "problem": "\nIris likes full binary trees.\n\nLet's define the depth of a rooted tree as the maximum number of vertices on the simple paths from some vertex to the root. A full binary tree of depth $d$ is a binary tree of depth $d$ with exactly $2^d - 1$ vertices.\n\nIris calls a tree a $d$-binary tree if some vertices and edges can be added to it to make it a full binary tree of depth $d$. Note that any vertex can be chosen as the root of a full binary tree.\n\nSince performing operations on large trees is difficult, she defines the binary depth of a tree as the minimum $d$ satisfying that the tree is $d$-binary. Specifically, if there is no integer $d \\ge 1$ such that the tree is $d$-binary, the binary depth of the tree is $-1$.\n\nIris now has a tree consisting of only vertex $1$. She wants to add $n - 1$ more vertices to form a larger tree. She will add the vertices one by one. When she adds vertex $i$ ($2 \\leq i \\leq n$), she'll give you an integer $p_i$ ($1 \\leq p_i < i$), and add a new edge connecting vertices $i$ and $p_i$.\n\nIris wants to ask you the binary depth of the tree formed by the first $i$ vertices for each $1 \\le i \\le n$. Can you tell her the answer?\n\nInput Format:\nEach test consists of multiple test cases. The first line contains a single integer $t$ ($1 \\leq t \\leq 10^4$) \u2014 the number of test cases. The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($2 \\leq n \\leq 5 \\cdot 10^5$) \u2014 the final size of the tree.\n\nThe second line of each test case contains $n - 1$ integers $p_2, p_3, \\ldots, p_n$ ($1 \\leq p_i < i$) \u2014 descriptions of all edges of the tree.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $5 \\cdot 10^5$.\n\nOutput Format:\nFor each test case output $n$ integers, $i$-th of them representing the binary depth of the tree formed by the first $i$ vertices.\n\nTags:\n['brute force', 'data structures', 'dfs and similar', 'trees']\n\nTime Limit: 4000 ms\nMemory Limit: 1024 MB\n",
        "tests": [
            {
                "input": "7\n3\n1 1\n6\n1 2 3 4 5\n7\n1 1 3 2 5 1\n10\n1 1 2 1 4 2 4 5 8\n10\n1 1 3 1 3 2 2 2 6\n20\n1 1 2 2 4 4 5 5 7 6 8 6 11 14 11 8 13 13 12\n25\n1 1 3 3 1 5 4 4 6 8 11 12 8 7 11 13 7 13 15 6 19 14 10 23",
                "output": "1 2 2 \n1 2 2 3 3 4 \n1 2 2 3 3 4 4 \n1 2 2 3 3 3 4 4 5 5 \n1 2 2 3 3 4 4 4 -1 -1 \n1 2 2 3 3 4 4 4 4 5 5 5 5 6 6 6 6 6 6 7 \n1 2 2 3 3 4 4 4 4 5 5 6 6 6 6 6 7 7 7 7 7 8 8 8 8"
            }
        ]
    },
    {
        "problem": "\nSadly, Dora poured the paint when painting the class mural. Dora considers the mural as the matrix $b$ of size $n \\times n$. Initially, $b_{i,j} = 0$ for all $1 \\le i, j \\le n$.\n\nDora has only two brushes which have two different colors. In one operation, she can paint the matrix with one of two brushes:\n\n  * The first brush has color $1$ on it and can paint one column of the matrix. That is, Dora chooses $1 \\leq j \\leq n$ and makes $b_{i,j} := 1$ for all $1 \\leq i \\leq n$;    * The second brush has color $2$ on it and can paint one row of the matrix. That is, Dora chooses $1 \\leq i \\leq n$ and makes $b_{i,j} := 2$ for all $1 \\leq j \\leq n$. \n\nDora paints the matrix so that the resulting matrix $b$ contains only $1$ and $2$.\n\nFor a matrix $b$, let $f(b)$ denote the minimum number of operations needed to turn the initial matrix (containing only $0$) into $b$. The beauty of a matrix $b$ is the number of ways to paint the initial matrix in exactly $f(b)$ operations to turn it into $b$. If there's no way to turn the initial matrix into $b$, the beauty of $b$ is $0$.\n\nHowever, Dora made a uniformly random mistake; there's exactly one element different in the matrix $a$ given to you from the real matrix $b$. That is, there is exactly one pair $(i, j)$ such that $a_{i, j} = 3 - b_{i, j}$.\n\nPlease help Dora compute the expected beauty of the real matrix $b$ modulo $998\\,244\\,353$ (all possible $n^2$ mistakes have equal probability).\n\nSince the size of the matrix is too large, Dora will only tell you the positions of $m$ elements of color $1$, and the remaining $n^2-m$ elements have color $2$.\n\nInput Format:\nEach test consists of multiple test cases. The first line contains a single integer $t$ ($1 \\leq t \\leq 10^4$) \u2014 the number of test cases. The description of the test cases follows.\n\nThe first line of each test case contains two integers $n$ and $m$ ($2 \\leq n \\leq 2 \\cdot 10^5$, $0 \\leq m \\leq \\min(10^6, n^2)$) \u2014 the size of the matrix and the number of elements of color $1$.\n\nThen $m$ lines follow, each containing two positive integers $x_i$ and $y_i$ ($1 \\leq x_i, y_i \\leq n$) \u2014 denoting that $a_{x_i, y_i} = 1$.\n\nIt is guaranteed that if $i \\neq j$, then $(x_i, y_i) \\neq (x_j, y_j)$.\n\nIt is also guaranteed that the sum of $n$ over all test cases does not exceed $4\\cdot10^5$, and the sum of $m$ over all test cases does not exceed $10^6$.\n\nOutput Format:\nFor each test case, output a single integer \u2014 the expected beauty of the real matrix $b$, modulo $998\\,244\\,353$.\n\nTags:\n['brute force', 'combinatorics', 'constructive algorithms', 'graphs', 'implementation']\n\nTime Limit: 3000 ms\nMemory Limit: 512 MB\n",
        "tests": [
            {
                "input": "7\n2 2\n1 1\n1 2\n2 1\n1 1\n3 2\n1 1\n3 3\n6 0\n5 10\n1 1\n1 2\n1 3\n2 1\n2 3\n5 1\n5 2\n5 3\n5 4\n5 5\n3 5\n1 1\n1 3\n2 2\n3 1\n3 3\n4 3\n1 1\n2 3\n2 4",
                "output": "1\n499122178\n665496236\n120\n79859554\n776412275\n1"
            }
        ]
    },
    {
        "problem": "\nDora has a set $s$ containing integers. In the beginning, she will put all integers in $[l, r]$ into the set $s$. That is, an integer $x$ is initially contained in the set if and only if $l \\leq x \\leq r$. Then she allows you to perform the following operations:\n\n  * Select three distinct integers $a$, $b$, and $c$ from the set $s$, such that $\\gcd(a, b) = \\gcd(b, c) = \\gcd(a, c) = 1^\\dagger$.    * Then, remove these three integers from the set $s$. \n\nWhat is the maximum number of operations you can perform?\n\n$^\\dagger$Recall that $\\gcd(x, y)$ means the [greatest common divisor](https://en.wikipedia.org/wiki/Greatest_common_divisor) of integers $x$ and $y$.\n\nInput Format:\nEach test consists of multiple test cases. The first line contains a single integer $t$ ($1 \\leq t \\leq 500$) \u2014 the number of test cases. The description of the test cases follows.\n\nThe only line of each test case contains two integers $l$ and $r$ ($1 \\leq l \\leq r \\leq 1000$) \u2014 the range of integers in the initial set.\n\nOutput Format:\nFor each test case, output a single integer \u2014 the maximum number of operations you can perform.\n\nTags:\n['greedy', 'math', 'number theory']\n\nTime Limit: 1000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "8\n1 3\n3 7\n10 21\n2 8\n51 60\n2 15\n10 26\n1 1000",
                "output": "1\n1\n3\n1\n2\n3\n4\n250"
            }
        ]
    },
    {
        "problem": "\nAfter receiving yet another integer array $a_1, a_2, \\ldots, a_n$ at her birthday party, Index decides to perform some operations on it.\n\nFormally, there are $m$ operations that she is going to perform in order. Each of them belongs to one of the two types:\n\n  * $\\texttt{+ l r}$. Given two integers $l$ and $r$, for all $1 \\leq i \\leq n$ such that $l \\leq a_i \\leq r$, set $a_i := a_i + 1$.    * $\\texttt{- l r}$. Given two integers $l$ and $r$, for all $1 \\leq i \\leq n$ such that $l \\leq a_i \\leq r$, set $a_i := a_i - 1$. \n\nFor example, if the initial array $a = [7, 1, 3, 4, 3]$, after performing the operation $\\texttt{+} \\space 2 \\space 4$, the array $a = [7, 1, 4, 5, 4]$. Then, after performing the operation $\\texttt{-} \\space 1 \\space 10$, the array $a = [6, 0, 3, 4, 3]$.\n\nIndex is curious about the maximum value in the array $a$. Please help her find it after each of the $m$ operations.\n\nInput Format:\nEach test consists of multiple test cases. The first line contains a single integer $t$ ($1 \\leq t \\leq 2 \\cdot 10^4$) \u2014 the number of test cases. The description of the test cases follows.\n\nThe first line of each test case contains two integers $n$ and $m$ ($1 \\leq n \\leq 10^5$, $1 \\leq m \\leq 10^5$) \u2014 the length of the array and the number of operations.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\leq a_i \\leq 10^9$) \u2014 the initial array $a$.\n\nThen $m$ lines follow, each line corresponds to the operation, in the following format: $\\texttt{c l r}$ ($c \\in \\\\{\\texttt +, \\texttt -\\\\}$, $l$ and $r$ are integers, $1 \\leq l \\leq r \\leq 10^9$) \u2014 the description of the operation.\n\nNote that the elements $a_i$ may not satisfy $1\\le a_i\\le 10^9$ after some operations, as it is shown in the example.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $10^5$, and the sum of $m$ over all test cases does not exceed $10^5$.\n\nOutput Format:\nFor each test case, output one single line containing $m$ integers, with the $i$-th of them describing the maximum value of the array after the $i$-th operation.\n\nTags:\n['data structures', 'greedy']\n\nTime Limit: 1000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "5\n5 5\n1 2 3 2 1\n+ 1 3\n- 2 3\n+ 1 2\n+ 2 4\n- 6 8\n5 5\n1 3 3 4 5\n+ 1 4\n+ 2 3\n- 4 5\n- 3 3\n- 2 6\n5 5\n1 1 1 1 1\n+ 2 3\n- 4 5\n+ 1 6\n- 2 5\n+ 1 8\n1 1\n1\n- 1 1\n1 1\n1000000000\n+ 1000000000 1000000000",
                "output": "4 4 4 5 5\n5 5 4 4 3\n1 1 2 1 2\n0\n1000000001"
            }
        ]
    },
    {
        "problem": "\nDora has just learned the programming language C++!\n\nHowever, she has completely misunderstood the meaning of C++. She considers it as two kinds of adding operations on the array $c$ with $n$ elements. Dora has two integers $a$ and $b$. In one operation, she can choose one of the following things to do.\n\n  * Choose an integer $i$ such that $1 \\leq i \\leq n$, and increase $c_i$ by $a$.    * Choose an integer $i$ such that $1 \\leq i \\leq n$, and increase $c_i$ by $b$. \n\nNote that $a$ and $b$ are constants, and they can be the same.\n\nLet's define a range of array $d$ as $\\max(d_i) - \\min(d_i)$. For instance, the range of the array $[1, 2, 3, 4]$ is $4 - 1 = 3$, the range of the array $[5, 2, 8, 2, 2, 1]$ is $8 - 1 = 7$, and the range of the array $[3, 3, 3]$ is $3 - 3 = 0$.\n\nAfter any number of operations (possibly, $0$), Dora calculates the range of the new array. You need to help Dora minimize this value, but since Dora loves exploring all by herself, you only need to tell her the minimized value.\n\nInput Format:\nEach test consists of multiple test cases. The first line contains a single integer $t$ ($1 \\leq t \\leq 10^4$) \u2014 the number of test cases. The description of test cases follows.\n\nThe first line of each test case contains three integers $n$, $a$, and $b$ ($1 \\leq n \\leq 10^5$, $1 \\leq a, b \\leq 10^9$) \u2014 the length of the array $c$ and the constant values, respectively.\n\nThe second line of each test case contains $n$ integers $c_1, c_2, \\ldots, c_n$ ($1 \\leq c_i \\leq 10^9$) \u2014 the initial elements of the array $c$.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $10^5$.\n\nOutput Format:\nFor each test case, output a single integer \u2014 the minimum possible range of the array after any number of operations.\n\nTags:\n['math', 'number theory']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "10\n4 5 5\n1 3 4 4\n4 2 3\n1 3 4 6\n4 7 7\n1 1 2 6\n3 15 9\n1 9 5\n3 18 12\n1 4 5\n7 27 36\n33 13 23 12 35 24 41\n10 6 9\n15 5 6 9 8 2 12 15 3 8\n2 1 1000000000\n1 1000000000\n6 336718728 709848696\n552806726 474775724 15129785 371139304 178408298 13106071\n6 335734893 671469786\n138885253 70095920 456876775 9345665 214704906 375508929",
                "output": "3\n0\n3\n2\n3\n5\n1\n0\n17\n205359241"
            }
        ]
    },
    {
        "problem": "\nIris has a tree rooted at vertex $1$. Each vertex has a value of $\\mathtt 0$ or $\\mathtt 1$.\n\nLet's consider a leaf of the tree (the vertex $1$ is never considered a leaf) and define its weight. Construct a string formed by the values of the vertices on the path starting at the root and ending in this leaf. Then the weight of the leaf is the difference between the number of occurrences of $\\mathtt{10}$ and $\\mathtt{01}$ substrings in it.\n\nTake the following tree as an example. Green vertices have a value of $\\mathtt 1$ while white vertices have a value of $\\mathtt 0$.\n\n![](CDN_BASE_URL/712e8f1acc71d0401cf5eb23441e53a5)\n\n  * Let's calculate the weight of the leaf $5$: the formed string is $\\mathtt{10110}$. The number of occurrences of substring $\\mathtt{10}$ is $2$, the number of occurrences of substring $\\mathtt{01}$ is $1$, so the difference is $2 - 1 = 1$.   * Let's calculate the weight of the leaf $6$: the formed string is $\\mathtt{101}$. The number of occurrences of substring $\\mathtt{10}$ is $1$, the number of occurrences of substring $\\mathtt{01}$ is $1$, so the difference is $1 - 1 = 0$.\n\nThe score of a tree is defined as the number of leaves with non-zero weight in the tree.\n\nBut the values of some vertices haven't been decided and will be given to you as $\\texttt{?}$. Filling the blanks would be so boring, so Iris is going to invite Dora to play a game. On each turn, one of the girls chooses any of the remaining vertices with value $\\texttt{?}$ and changes its value to $\\mathtt{0}$ or $\\mathtt{1}$, with Iris going first. The game continues until there are no vertices with value $\\mathtt{?}$ left in the tree. Iris aims to maximize the score of the tree, while Dora aims to minimize that.\n\nAssuming that both girls play optimally, please determine the final score of the tree.\n\nInput Format:\nEach test consists of multiple test cases. The first line contains a single integer $t$ ($1 \\leq t \\leq 5\\cdot 10^4$) \u2014 the number of test cases. The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($2 \\leq n \\leq 10^5$) \u2014 the number of vertices in the tree.\n\nThe following $n - 1$ lines each contain two integers $u$ and $v$ ($1 \\leq u, v \\leq n$) \u2014 denoting an edge between vertices $u$ and $v$.\n\nIt's guaranteed that the given edges form a tree.\n\nThe last line contains a string $s$ of length $n$. The $i$-th character of $s$ represents the value of vertex $i$. It's guaranteed that $s$ only contains characters $\\mathtt{0}$, $\\mathtt{1}$ and $\\mathtt{?}$.\n\nIt is guaranteed that the sum of $n$ over all test cases doesn't exceed $2\\cdot 10^5$.\n\nOutput Format:\nFor each test case, output a single integer \u2014 the final score of the tree.\n\nTags:\n['games', 'graphs', 'greedy', 'trees']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "6\n4\n1 2\n1 3\n4 1\n0101\n4\n1 2\n3 2\n2 4\n???0\n5\n1 2\n1 3\n2 4\n2 5\n?1?01\n6\n1 2\n2 3\n3 4\n5 3\n3 6\n?0????\n5\n1 2\n1 3\n1 4\n1 5\n11?1?\n2\n2 1\n??",
                "output": "2\n1\n1\n2\n1\n0"
            }
        ]
    },
    {
        "problem": "\nGiven a rooted tree with the root at vertex $1$. For any vertex $i$ ($1 < i \\leq n$) in the tree, there is an edge connecting vertices $i$ and $p_i$ ($1 \\leq p_i < i$), with a weight equal to $t_i$.\n\nIris does not know the values of $t_i$, but she knows that $\\displaystyle\\sum_{i=2}^n t_i = w$ and each of the $t_i$ is a non- negative integer.\n\nThe vertices of the tree are numbered in a special way: the numbers of the vertices in each subtree are consecutive integers. In other words, the vertices of the tree are numbered in the order of a depth-first search.\n\n![](CDN_BASE_URL/274244c032854fe172d47861e2eb9c02) The tree in this picture satisfies the condition. For example, in the subtree of vertex $2$, the vertex numbers are $2, 3, 4, 5$, which are consecutive integers. ![](CDN_BASE_URL/83174231191d329be697a6e3f67b5eb3) The tree in this picture does not satisfy the condition, as in the subtree of vertex $2$, the vertex numbers $2$ and $4$ are not consecutive integers.\n\nWe define $\\operatorname{dist}(u, v)$ as the length of the simple path between vertices $u$ and $v$ in the tree.\n\nNext, there will be $n - 1$ events:\n\n  * Iris is given integers $x$ and $y$, indicating that $t_x = y$. \n\nAfter each event, Iris wants to know the maximum possible value of $\\operatorname{dist}(i, i \\bmod n + 1)$ independently for each $i$ ($1\\le i\\le n$). She only needs to know the sum of these $n$ values. Please help Iris quickly get the answers.\n\nNote that when calculating the maximum possible values of $\\operatorname{dist}(i, i \\bmod n + 1)$ and $\\operatorname{dist}(j, j \\bmod n + 1)$ for $i \\ne j$, the unknown edge weights may be different.\n\nInput Format:\nEach test consists of multiple test cases. The first line contains a single integer $t$ ($1 \\leq t \\leq 10^4$) \u2014 the number of test cases. The description of the test cases follows.\n\nThe first line of each test case contains two integers $n$ and $w$ ($2 \\le n \\le 2 \\cdot 10^5$, $0 \\leq w \\leq 10^{12}$) \u2014 the number of vertices in the tree and the sum of the edge weights.\n\nThe second line of each test case contains $n - 1$ integers $p_2, p_3, \\ldots, p_n$ ($1 \\leq p_i < i$) \u2014 the description of the edges of the tree.\n\nThen follow $n-1$ lines indicating the events. Each line contains two integers $x$ and $y$ ($2 \\leq x \\leq n$, $0 \\leq y \\leq w$), indicating that $t_x = y$.\n\nIt is guaranteed that all $x$ in the events are distinct. It is also guaranteed that the sum of all $y$ equals $w$.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\nOutput Format:\nFor each test case, output one line containing $n-1$ integers, each representing the answer after each event.\n\nTags:\n['brute force', 'data structures', 'dfs and similar', 'math', 'trees']\n\nTime Limit: 3000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "4\n2 1000000000000\n1\n2 1000000000000\n4 9\n1 1 1\n2 2\n4 4\n3 3\n6 100\n1 2 3 2 1\n6 17\n3 32\n2 4\n4 26\n5 21\n10 511\n1 2 2 4 2 1 1 8 8\n3 2\n6 16\n10 256\n9 128\n2 1\n5 8\n8 64\n4 4\n7 32",
                "output": "2000000000000\n25 18 18\n449 302 247 200 200\n4585 4473 2681 1567 1454 1322 1094 1022 1022"
            }
        ]
    },
    {
        "problem": "\nLet there be a set that contains distinct positive integers. To expand the set to contain as many integers as possible, Eri can choose two integers $x\\neq y$ from the set such that their average $\\frac{x+y}2$ is still a positive integer and isn't contained in the set, and add it to the set. The integers $x$ and $y$ remain in the set.\n\nLet's call the set of integers consecutive if, after the elements are sorted, the difference between any pair of adjacent elements is $1$. For example, sets $\\\\{2\\\\}$, $\\\\{2, 5, 4, 3\\\\}$, $\\\\{5, 6, 8, 7\\\\}$ are consecutive, while $\\\\{2, 4, 5, 6\\\\}$, $\\\\{9, 7\\\\}$ are not.\n\nEri likes consecutive sets. Suppose there is an array $b$, then Eri puts all elements in $b$ into the set. If after a finite number of operations described above, the set can become consecutive, the array $b$ will be called brilliant.\n\nNote that if the same integer appears in the array multiple times, we only put it into the set once, as a set always contains distinct positive integers.\n\nEri has an array $a$ of $n$ positive integers. Please help him to count the number of pairs of integers $(l,r)$ such that $1 \\leq l \\leq r \\leq n$ and the subarray $a_l, a_{l+1}, \\ldots, a_r$ is brilliant.\n\nInput Format:\nEach test consists of multiple test cases. The first line contains a single integer $t$ ($1 \\leq t \\leq 10^4$) \u2014 the number of test cases. The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($1 \\leq n \\leq 4 \\cdot 10^5$) \u2014 length of the array $a$.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots a_n$ ($1 \\leq a_i \\leq 10^9$) \u2014 the elements of the array $a$.\n\nIt is guaranteed that the sum of $n$ over all test cases doesn't exceed $4 \\cdot 10^5$.\n\nOutput Format:\nFor each test case, output a single integer \u2014 the number of brilliant subarrays.\n\nTags:\n['binary search', 'data structures', 'number theory', 'two pointers']\n\nTime Limit: 3000 ms\nMemory Limit: 512 MB\n",
        "tests": [
            {
                "input": "6\n2\n2 2\n6\n1 3 6 10 15 21\n5\n6 30 18 36 9\n1\n1000000000\n6\n1 1 4 5 1 4\n12\n70 130 90 90 90 108 612 500 451 171 193 193",
                "output": "3\n18\n5\n1\n18\n53"
            }
        ]
    },
    {
        "problem": "\nToday, Sakurako has a math exam. The teacher gave the array, consisting of $a$ ones and $b$ twos.\n\nIn an array, Sakurako must place either a '+' or a '-' in front of each element so that the sum of all elements in the array equals $0$.\n\nSakurako is not sure if it is possible to solve this problem, so determine whether there is a way to assign signs such that the sum of all elements in the array equals $0$.\n\nInput Format:\nThe first line contains a single integer $t$ ($1\\le t\\le 100$)  \u2014 the number of test cases.\n\nThe only line of each test case contains two integers $a$ and $b$ ($0\\le a,b<10$)  \u2014 the number of '1's and the number of '2's in the array.\n\nOutput Format:\nFor each test case, output \"Yes\" if you can make the sum of the entire array equal to $0$, and \"No\" otherwise.\n\nYou can output each letter in any case (lowercase or uppercase). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be accepted as a positive answer.\n\nTags:\n['brute force', 'constructive algorithms', 'greedy', 'math']\n\nTime Limit: 1000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "5\n0 1\n0 3\n2 0\n2 3\n3 1",
                "output": "NO\nNO\nYES\nYES\nNO"
            }
        ]
    },
    {
        "problem": "\nA beautiful binary matrix is a matrix that has ones on its edges and zeros inside.\n\n![](CDN_BASE_URL/5df31946486165887b31c82158ed558d) Examples of four beautiful binary matrices.\n\nToday, Sakurako was playing with a beautiful binary matrix of size $r \\times c$ and created a binary string $s$ by writing down all the rows of the matrix, starting from the first and ending with the $r$-th. More formally, the element from the matrix in the $i$-th row and $j$-th column corresponds to the $((i-1)*c+j)$-th element of the string.\n\nYou need to check whether the beautiful matrix from which the string $s$ was obtained could be squared. In other words, you need to check whether the string $s$ could have been build from a square beautiful binary matrix (i.e., one where $r=c$).\n\nInput Format:\nThe first line contains a single integer $t$ ($1 \\le t \\le 10^4$) \u2014 the number of test cases.\n\nThe first line of each test case contains a single integer $n$ ($2 \\le n \\le 2 \\cdot 10^5$) \u2014 the length of the string.\n\nThe second line of each test case contains the string $s$ of length $n$. The string is always the result of writing out the strings of a beautiful matrix.\n\nIt is guaranteed that the sum of $n$ across all test cases does not exceed $2 \\cdot 10^5$.\n\nOutput Format:\nPrint \"Yes\", if the original matrix could have been square, and \"No\" otherwise.\n\nTags:\n['brute force', 'math', 'strings']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "5\n2\n11\n4\n1111\n9\n111101111\n9\n111111111\n12\n111110011111",
                "output": "No\nYes\nYes\nNo\nNo"
            }
        ]
    },
    {
        "problem": "\nToday, Sakurako was studying arrays. An array $a$ of length $n$ is considered good if and only if:\n\n  * the array $a$ is increasing, meaning $a_{i - 1} < a_i$ for all $2 \\le i \\le n$;    * the differences between adjacent elements are increasing, meaning $a_i - a_{i-1} < a_{i+1} - a_i$ for all $2 \\le i < n$. \n\nSakurako has come up with boundaries $l$ and $r$ and wants to construct a good array of maximum length, where $l \\le a_i \\le r$ for all $a_i$.\n\nHelp Sakurako find the maximum length of a good array for the given $l$ and $r$.\n\nInput Format:\nThe first line contains a single integer $t$ ($1\\le t\\le 10^4$)  \u2014 the number of test cases.\n\nThe only line of each test case contains two integers $l$ and $r$ ($1\\le l\\le r\\le 10^9$).\n\nOutput Format:\nFor each test case, output a single integer  \u2014 the length of the longest good array Sakurako can form given $l$ and $r$.\n\nTags:\n['binary search', 'brute force', 'math']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "5\n1 2\n1 5\n2 2\n10 20\n1 1000000000",
                "output": "2\n3\n1\n5\n44721"
            }
        ]
    },
    {
        "problem": "\nFor a certain permutation $p$$^{\\text{\u2217}}$ Sakurako calls an integer $j$ reachable from an integer $i$ if it is possible to make $i$ equal to $j$ by assigning $i=p_i$ a certain number of times.\n\nIf $p=[3,5,6,1,2,4]$, then, for example, $4$ is reachable from $1$, because: $i=1$ $\\rightarrow$ $i=p_1=3$ $\\rightarrow$ $i=p_3=6$ $\\rightarrow$ $i=p_6=4$. Now $i=4$, so $4$ is reachable from $1$.\n\nEach number in the permutation is colored either black or white.\n\nSakurako defines the function $F(i)$ as the number of black integers that are reachable from $i$.\n\nSakurako is interested in $F(i)$ for each $1\\le i\\le n$, but calculating all values becomes very difficult, so she asks you, as her good friend, to compute this.\n\n$^{\\text{\u2217}}$A permutation of length $n$ is an array consisting of $n$ distinct integers from $1$ to $n$ in arbitrary order. For example, $[2,3,1,5,4]$ is a permutation, but $[1,2,2]$ is not a permutation (the number $2$ appears twice in the array), and $[1,3,4]$ is also not a permutation ($n=3$, but the array contains $4$).\n\nInput Format:\nThe first line contains a single integer $t$ ($1\\le t\\le 10^4$)  \u2014 the number of test cases.\n\nThe first line of each test case contains a single integer $n$ ($1\\le n\\le 2\\cdot 10^5$)  \u2014 the number of elements in the array.\n\nThe second line of each test case contains $n$ integers $p_1, p_2, \\dots, p_n$ ($1\\le p_i\\le n$)  \u2014 the elements of the permutation.\n\nThe third line of each test case contains a string $s$ of length $n$, consisting of '0' and '1'. If $s_i=0$, then the number $p_i$ is colored black; if $s_i=1$, then the number $p_i$ is colored white.\n\nIt is guaranteed that the sum of $n$ across all test cases does not exceed $2\\cdot 10^5$.\n\nOutput Format:\nFor each test case, output $n$ integers $F(1), F(2), \\dots, F(n)$.\n\nTags:\n['dp', 'dsu', 'graphs', 'math']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "5\n1\n1\n0\n5\n1 2 4 5 3\n10101\n5\n5 4 1 3 2\n10011\n6\n3 5 6 1 2 4\n010000\n6\n1 2 3 4 5 6\n100110",
                "output": "1 \n0 1 1 1 1 \n2 2 2 2 2 \n4 1 4 4 1 4 \n0 1 1 0 0 1"
            }
        ]
    },
    {
        "problem": "\nSakurako really loves alternating strings. She calls a string $s$ of lowercase Latin letters an alternating string if characters in the even positions are the same, if characters in the odd positions are the same, and the length of the string is even.\n\nFor example, the strings 'abab' and 'gg' are alternating, while the strings 'aba' and 'ggwp' are not.\n\nAs a good friend, you decided to gift such a string, but you couldn't find one. Luckily, you can perform two types of operations on the string:\n\n  1. Choose an index $i$ and delete the $i$-th character from the string, which will reduce the length of the string by $1$. This type of operation can be performed no more than $1$ time;    2. Choose an index $i$ and replace $s_i$ with any other letter. \n\nSince you are in a hurry, you need to determine the minimum number of operations required to make the string an alternating one.\n\nInput Format:\nThe first line contains a single integer $t$ ($1 \\le t \\le 10^4$)  \u2014 the number of test cases.\n\nThe first line of each test case contains a single number $n$ ($1 \\le n\\le 2\\cdot 10^5$)  \u2014 the length of the string.\n\nThe second line of each test case contains a string $s$, consisting of lowercase Latin letters.\n\nIt is guaranteed that the sum of $n$ across all test cases does not exceed $2 \\cdot 10^5$.\n\nOutput Format:\nFor each test case, output a single integer \u2014 the minimum number of operations required to turn the string $s$ into an alternating one.\n\nTags:\n['brute force', 'data structures', 'dp', 'greedy', 'implementation', 'strings']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "10\n1\na\n2\nca\n3\naab\n5\nababa\n6\nacdada\n9\nejibmyyju\n6\nbbccbc\n6\nabacba\n5\nbcbca\n5\ndcbdb",
                "output": "1\n0\n1\n1\n2\n6\n2\n3\n1\n1"
            }
        ]
    },
    {
        "problem": "\nSakurako has a box with $n$ balls. Each ball has it's value. She wants to bet with her friend that if the friend randomly picks two balls from the box (it could be two distinct balls, but they may have the same value), the product of their values will be the same as the number that Sakurako guessed.\n\nSince Sakurako has a PhD in probability, she knows that the best number to pick is [the expected value](http://tiny.cc/matozh_en), but she forgot how to calculate it. Help Sakurako and find the expected value of the product of two elements from the array.\n\nIt can be shown that the expected value has the form $\\frac{P}{Q}$, where $P$ and $Q$ are non-negative integers, and $Q \\ne 0$. Report the value of $P \\cdot Q^{-1}(\\bmod 10^9+7)$.\n\nInput Format:\nThe first line contains a single integer $t$ ($1\\le t\\le 10^4$)  \u2014 the number of test cases.\n\nThe first line of each test case contains a single integer $n$ ($2\\le n\\le 2\\cdot 10^5$)  \u2014 the number of elements in the array.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\dots, a_n$ ($0\\le a_i\\le 10^9$)  \u2014 the elements of the array.\n\nIt is guaranteed that the sum of $n$ across all test cases does not exceed $2\\cdot 10^5$.\n\nOutput Format:\nFor each test case, output the value of $P \\cdot Q^{-1}(\\bmod 10^9+7)$.\n\nTags:\n['combinatorics', 'math', 'number theory']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "3\n3\n3 2 3\n4\n2 2 2 4\n5\n1 2 3 4 5",
                "output": "7\n6\n500000012"
            }
        ]
    },
    {
        "problem": "\nSakurako has prepared a task for you:\n\nShe gives you an array of $n$ integers and allows you to choose $i$ and $j$ such that $i \\neq j$ and $a_i \\ge a_j$, and then assign $a_i = a_i - a_j$ or $a_i = a_i + a_j$. You can perform this operation any number of times for any $i$ and $j$, as long as they satisfy the conditions.\n\nSakurako asks you what is the maximum possible value of $mex_k$$^{\\text{\u2217}}$ of the array after any number of operations.\n\n$^{\\text{\u2217}}$$mex_k$ is the $k$-th non-negative integer that is absent in the array. For example, $mex_1(\\\\{1,2,3 \\\\})=0$, since $0$ is the first element that is not in the array, and $mex_2(\\\\{0,2,4 \\\\})=3$, since $3$ is the second element that is not in the array.\n\nInput Format:\nThe first line contains a single integer $t$ ($1\\le t\\le 10^4$)  \u2014 the number of test cases.\n\nThe first line of each test case contains two integers $n$ and $k$ ($1\\le n\\le 2\\cdot 10^5,1\\le k\\le 10^9$)  \u2014 the number of elements in the array and the value $k$ for $mex_k$.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\dots,a_n$ ($1\\le a_i\\le 10^9$)  \u2014 the elements of the array.\n\nIt is guaranteed that the sum of $n$ across all test cases does not exceed $2\\cdot 10^5$.\n\nOutput Format:\nFor each test case, output the maximum $mex_k$ that can be achieved through the operations.\n\nTags:\n['binary search', 'greedy', 'math', 'number theory']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "6\n1 3\n3\n2 10\n1 1\n3 1\n1 2 3\n3 2\n1 2 4\n4 5\n2 2 2 16\n4 5\n2 2 2 3",
                "output": "2\n11\n3\n4\n8\n8"
            }
        ]
    },
    {
        "problem": "\nSakurako will soon take a test. The test can be described as an array of integers $n$ and a task on it:\n\nGiven an integer $x$, Sakurako can perform the following operation any number of times:\n\n  * Choose an integer $i$ ($1\\le i\\le n$) such that $a_i\\ge x$;    * Change the value of $a_i$ to $a_i-x$. \n\nUsing this operation any number of times, she must find the minimum possible median$^{\\text{\u2217}}$ of the array $a$.\n\nSakurako knows the array but does not know the integer $x$. Someone let it slip that one of the $q$ values of $x$ will be in the next test, so Sakurako is asking you what the answer is for each such $x$.\n\n$^{\\text{\u2217}}$The median of an array of length $n$ is the element that stands in the middle of the sorted array (at the $\\frac{n+2}{2}$-th position for even $n$, and at the $\\frac{n+1}{2}$-th for odd)\n\nInput Format:\nThe first line contains one integer $t$ ($1\\le t\\le 10^4$)  \u2014 the number of test cases.\n\nThe first line of each test case contains two integers $n$ and $q$ ($1\\le n,q\\le 10^5$)  \u2014 the number of elements in the array and the number of queries.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\dots, a_n$ ($1\\le a_i\\le n$)  \u2014 the elements of the array.\n\nThe following $q$ lines each contain one integer $x$ ($1\\le x\\le n$).\n\nIt is guaranteed that the sum of $n$ across all test cases does not exceed $10^5$. The same guarantee applies to the sum of $q$ across all test cases.\n\nOutput Format:\nFor each test case, output $q$ integers  \u2014 the answer for each query.\n\nTags:\n['binary search', 'brute force', 'greedy', 'math', 'number theory']\n\nTime Limit: 1000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "2\n5 5\n1 2 3 4 5\n1\n2\n3\n4\n5\n6 3\n1 2 6 4 1 3\n2\n1\n5",
                "output": "0 1 1 1 2 \n1 0 2"
            }
        ]
    },
    {
        "problem": "\nToday, a club fair was held at \"NSPhM\". In order to advertise his pastry club, Zhan decided to demonstrate the power of his blender.\n\nTo demonstrate the power of his blender, Zhan has $n$ fruits.\n\nThe blender can mix up to $x$ fruits per second.\n\nIn each second, Zhan can put up to $y$ fruits into the blender. After that, the blender will blend $\\min(x, c)$ fruits, where $c$ is the number of fruits inside the blender. After blending, blended fruits are removed from the blender.\n\nHelp Zhan determine the minimum amount of time required for Zhan to blend all fruits.\n\nInput Format:\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 1000$). The description of the test cases follows.\n\nThe first line of each test case contains one integer $n$ ($0 \\le n \\le 10^9$) \u2014 the number of fruits Zhan has.\n\nThe second line of each test case contains two integers $x$ and $y$ ($1 \\le x, y \\le 10^9$) \u2014 the number of fruits the blender can blend per second and the number of fruits Zhan can put into the blender per second.\n\nOutput Format:\nFor each testcase, output a single integer \u2014 the minimum number of seconds to blend all fruits.\n\nTags:\n['constructive algorithms', 'math']\n\nTime Limit: 1000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "5\n5\n3 4\n3\n1 2\n6\n4 3\n100\n4 3\n9\n3 3",
                "output": "2\n3\n2\n34\n3"
            }
        ]
    },
    {
        "problem": "\nEralim, being the mafia boss, manages a group of $n$ fighters. Fighter $i$ has a rating of $a_i$.\n\nEralim arranges a tournament of $n - 1$ battles, in each of which two not yet eliminated fighters $i$ and $j$ ($1 \\le i < j \\le n$) are chosen, and as a result of the battle, fighter $i$ is eliminated from the tournament, and the rating of fighter $j$ is reduced by the rating of fighter $i$. That is, $a_j$ is decreased by $a_i$. Note that fighter $j$'s rating can become negative. The fighters indexes do not change.\n\nEralim wants to know what maximum rating the last remaining fighter can preserve if he chooses the battles optimally.\n\nInput Format:\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($2 \\le n \\le 2 \\cdot 10^5$) \u2014 the number of fighters.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots a_n$ ($1 \\le a_i \\le 10^9$) \u2014 the ratings of the fighters.\n\nThe sum of $n$ over all testcases does not exceed $2 \\cdot 10^5$.\n\nOutput Format:\nFor each testcase, output a single integer \u2014 the maximum rating that the last remaining fighter can preserve.\n\nTags:\n['constructive algorithms', 'greedy', 'math']\n\nTime Limit: 1000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "5\n2\n2 1\n3\n2 2 8\n4\n1 2 4 3\n5\n1 2 3 4 5\n5\n3 2 4 5 4",
                "output": "-1\n8\n2\n7\n8"
            }
        ]
    },
    {
        "problem": "\nDimash learned that Mansur wrote something very unpleasant about him to a friend, so he decided to find out his password at all costs and discover what exactly he wrote.\n\nBelieving in the strength of his password, Mansur stated that his password \u2014 is a binary string of length $n$. He is also ready to answer Dimash's questions of the following type:\n\nDimash says a binary string $t$, and Mansur replies whether it is true that $t$ is a substring of his password.\n\nHelp Dimash find out the password in no more than $2n$ operations; otherwise, Mansur will understand the trick and stop communicating with him.\n\nInput Format:\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 100$). The description of the test cases follows.\n\nOutput Format:\n\n\nTags:\n['constructive algorithms', 'interactive', 'strings']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "4\n3\n\n0\n\n0\n\n1\n\n4\n\n4\n\n2",
                "output": "? 00\n\n? 000\n\n? 010\n\n! 010\n\n! 1100\n\n! 0110\n\n! 10"
            }
        ]
    },
    {
        "problem": "\nZhan, tired after the contest, gave the only task that he did not solve during the contest to his friend, Sungat. However, he could not solve it either, so we ask you to try to solve this problem.\n\nYou are given an array $a_1, a_2, \\ldots, a_n$ of length $n$. We can perform any number (possibly, zero) of operations on the array.\n\nIn one operation, we choose a position $i$ ($1 \\leq i \\leq n - 1$) and perform the following action:\n\n  * $a_i := a_i - 1$, and $a_{i+1} := a_{i+1} + 1$. \n\nFind the minimum possible value of $\\max(a_1, a_2, \\ldots, a_n) - \\min(a_1, a_2, \\ldots, a_n)$.\n\nInput Format:\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^5$). The description of the test cases follows.\n\nThe first line of each test case contains an integer $n$ ($1 \\leq n \\leq 2 \\cdot 10^5$).\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\leq a_i \\leq 10^{12}$).\n\nThe sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\nOutput Format:\nFor each test case, output a single integer: the minimum possible value of $\\max(a_1, a_2, \\ldots, a_n) - \\min(a_1, a_2, \\ldots, a_n)$.\n\nTags:\n['binary search', 'greedy']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "5\n1\n1\n3\n1 2 3\n4\n4 1 2 3\n4\n4 2 3 1\n5\n5 14 4 10 2",
                "output": "0\n2\n1\n1\n3"
            }
        ]
    },
    {
        "problem": "\nSince Mansur is tired of making legends, there will be no legends for this task.\n\nYou are given an array of positive integer numbers $a_1, a_2, \\ldots, a_n$. The elements of the array can be rearranged in any order. You need to find the smallest possible value of the expression $$\\gcd(a_1) + \\gcd(a_1, a_2) + \\ldots + \\gcd(a_1, a_2, \\ldots, a_n),$$ where $\\gcd(a_1, a_2, \\ldots, a_n)$ denotes the [greatest common divisor (GCD)](https://en.wikipedia.org/wiki/Greatest_common_divisor) of $a_1, a_2, \\ldots, a_n$.\n\nInput Format:\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains a single number $n$ ($1 \\le n \\le 10^5$) \u2014 the size of the array.\n\nThe second line of each test case contains $n$ numbers $a_1, a_2, \\ldots, a_n$ ($1 \\le a_i \\le 10^5$) \u2014 the initial array.\n\nThe sum of $n$ over all test cases does not exceed $10^5$.\n\nThe sum of $\\max(a_1, a_2, \\ldots, a_n)$ over all test cases does not exceed $10^5$.\n\nOutput Format:\nFor each test case, output a single number on a separate line \u2014 the answer to the problem.\n\nTags:\n['brute force', 'dp', 'greedy', 'math', 'number theory']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "5\n3\n4 2 2\n2\n6 3\n3\n10 15 6\n5\n6 42 12 52 20\n4\n42 154 231 66",
                "output": "6\n6\n9\n14\n51"
            }
        ]
    },
    {
        "problem": "\nThis is the easy version of the problem. In this version, $\\mathbf{u = v}$. You can make hacks only if both versions of the problem are solved.\n\nAlice and Bob are playing a fun game on a tree. This game is played on a tree with $n$ vertices, numbered from $1$ to $n$. Recall that a tree with $n$ vertices is an undirected connected graph with $n - 1$ edges.\n\nAlice and Bob take turns, with Alice going first. Each player starts at some vertex.\n\nOn their turn, a player must move from the current vertex to a neighboring vertex that has not yet been visited by anyone. The first player who cannot make a move loses.\n\nYou are given two vertices $u$ and $v$. Represent the simple path from vertex $u$ to $v$ as an array $p_1, p_2, p_3, \\ldots, p_m$, where $p_1 = u$, $p_m = v$, and there is an edge between $p_i$ and $p_{i + 1}$ for all $i$ ($1 \\le i < m$).\n\nYou need to determine the winner of the game if Alice starts at vertex $1$ and Bob starts at vertex $p_j$ for each $j$ (where $1 \\le j \\le m$).\n\nInput Format:\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($2 \\le n \\le 2 \\cdot 10^5$) \u2014 the number of vertices in the tree.\n\nEach of the following $n - 1$ lines contains two integers $a$ and $b$ ($1 \\le a, b \\le n$), denoting an undirected edge between vertices $a$ and $b$. It is guaranteed that these edges form a tree.\n\nThe last line of each test case contains two integers $u$ and $v$ ($2 \\le u, v \\le n$, $\\mathbf{u = v}$).\n\nIt is guaranteed that the path from $u$ to $v$ does not pass through vertex $1$.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\nOutput Format:\nFor each test case, output $m$ lines.\n\nIn the $i$-th line, print the winner of the game if Alice starts at vertex $1$ and Bob starts at vertex $p_i$. Print \"Alice\" (without quotes) if Alice wins, or \"Bob\" (without quotes) otherwise.\n\nTags:\n['binary search', 'brute force', 'data structures', 'dp', 'games', 'greedy', 'implementation', 'trees']\n\nTime Limit: 4000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "3\n3\n1 2\n2 3\n2 2\n3\n1 2\n2 3\n3 3\n6\n1 2\n1 3\n2 4\n2 5\n1 6\n4 4",
                "output": "Bob\nAlice\nAlice"
            }
        ]
    },
    {
        "problem": "\nThis is the hard version of the problem. In this version, it is not guaranteed that $u = v$. You can make hacks only if both versions of the problem are solved.\n\nAlice and Bob are playing a fun game on a tree. This game is played on a tree with $n$ vertices, numbered from $1$ to $n$. Recall that a tree with $n$ vertices is an undirected connected graph with $n - 1$ edges.\n\nAlice and Bob take turns, with Alice going first. Each player starts at some vertex.\n\nOn their turn, a player must move from the current vertex to a neighboring vertex that has not yet been visited by anyone. The first player who cannot make a move loses.\n\nYou are given two vertices $u$ and $v$. Represent the simple path from vertex $u$ to $v$ as an array $p_1, p_2, p_3, \\ldots, p_m$, where $p_1 = u$, $p_m = v$, and there is an edge between $p_i$ and $p_{i + 1}$ for all $i$ ($1 \\le i < m$).\n\nYou need to determine the winner of the game if Alice starts at vertex $1$ and Bob starts at vertex $p_j$ for each $j$ (where $1 \\le j \\le m$).\n\nInput Format:\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($2 \\le n \\le 2 \\cdot 10^5$) \u2014 the number of vertices in the tree.\n\nEach of the following $n - 1$ lines contains two integers $a$ and $b$ ($1 \\le a, b \\le n$), denoting an undirected edge between vertices $a$ and $b$. It is guaranteed that these edges form a tree.\n\nThe last line of each test case contains two integers $u$ and $v$ ($2 \\le u, v \\le n$).\n\nIt is guaranteed that the path from $u$ to $v$ does not pass through vertex $1$.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\nOutput Format:\nFor each test case, output $m$ lines.\n\nIn the $i$-th line, print the winner of the game if Alice starts at vertex $1$ and Bob starts at vertex $p_i$. Print \"Alice\" (without quotes) if Alice wins, or \"Bob\" (without quotes) otherwise.\n\nTags:\n['binary search', 'data structures', 'trees']\n\nTime Limit: 4000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "3\n3\n1 2\n2 3\n2 3\n6\n1 2\n1 3\n2 4\n2 5\n1 6\n4 5\n4\n1 2\n1 3\n2 4\n2 4",
                "output": "Bob\nAlice\nAlice\nBob\nAlice\nBob\nAlice"
            }
        ]
    },
    {
        "problem": "\nThere is a little bit of the outlaw in everyone, and a little bit of the hero too.\n\nThe heroic outlaw Robin Hood is famous for taking from the rich and giving to the poor.\n\nRobin encounters $n$ people starting from the $1$-st and ending with the $n$-th. The $i$-th person has $a_i$ gold. If $a_i \\ge k$, Robin will take all $a_i$ gold, and if $a_i=0$, Robin will give $1$ gold if he has any. Robin starts with $0$ gold.\n\nFind out how many people Robin gives gold to.\n\nInput Format:\nThe first line of the input contains a single integer $t$ ($1\\leq t \\leq 10^4$) \u2014 the number of test cases.\n\nThe first line of each test case contains two integers $n$, $k$ ($1 \\le n \\le 50, 1 \\le k \\le 100$) \u2014 the number of people and the threshold at which Robin Hood takes the gold.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($0 \\le a_i \\le 100$) \u2014 the gold of each person.\n\nOutput Format:\nFor each test case, output a single integer, the number of people that will get gold from Robin Hood.\n\nTags:\n['greedy', 'implementation']\n\nTime Limit: 1000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "4\n2 2\n2 0\n3 2\n3 0 0\n6 2\n0 3 0 0 0 0\n2 5\n5 4",
                "output": "1\n2\n3\n0"
            }
        ]
    },
    {
        "problem": "\nIn Sherwood, the trees are our shelter, and we are all children of the forest.\n\nThe Major Oak in Sherwood is known for its majestic foliage, which provided shelter to Robin Hood and his band of merry men and women.\n\nThe Major Oak grows $i^i$ new leaves in the $i$-th year. It starts with $1$ leaf in year $1$.\n\nLeaves last for $k$ years on the tree. In other words, leaves grown in year $i$ last between years $i$ and $i+k-1$ inclusive.\n\nRobin considers even numbers lucky. Help Robin determine whether the Major Oak will have an even number of leaves in year $n$.\n\nInput Format:\nThe first line of the input contains a single integer $t$ ($1 \\le t \\le 10^4$) \u2014 the number of test cases.\n\nEach test case consists of two integers $n$, $k$ ($1 \\le n \\le 10^9$, $1 \\le k \\le n$) \u2014 the requested year and the number of years during which the leaves remain.\n\nOutput Format:\nFor each test case, output one line, \"YES\" if in year $n$ the Major Oak will have an even number of leaves and \"NO\" otherwise.\n\nYou can output the answer in any case (upper or lower). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as positive responses.\n\nTags:\n['math']\n\nTime Limit: 1000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "5\n1 1\n2 1\n2 2\n3 2\n4 4",
                "output": "NO\nYES\nNO\nNO\nYES"
            }
        ]
    },
    {
        "problem": "\nIn Sherwood, we judge a man not by his wealth, but by his merit.\n\nLook around, the rich are getting richer, and the poor are getting poorer. We need to take from the rich and give to the poor. We need Robin Hood!\n\nThere are $n$ people living in the town. Just now, the wealth of the $i$-th person was $a_i$ gold. But guess what? The richest person has found an extra pot of gold!\n\nMore formally, find an $a_j=max(a_1, a_2, \\dots, a_n)$, change $a_j$ to $a_j+x$, where $x$ is a non-negative integer number of gold found in the pot. If there are multiple maxima, it can be any one of them.\n\nA person is unhappy if their wealth is strictly less than half of the average wealth$^{\\text{\u2217}}$.\n\nIf strictly more than half of the total population $n$ are unhappy, Robin Hood will appear by popular demand.\n\nDetermine the minimum value of $x$ for Robin Hood to appear, or output $-1$ if it is impossible.\n\n$^{\\text{\u2217}}$The average wealth is defined as the total wealth divided by the total population $n$, that is, $\\frac{\\sum a_i}{n}$, the result is a real number.\n\nInput Format:\nThe first line of input contains one integer $t$ ($1 \\le t \\le 10^4$) \u2014 the number of test cases.\n\nThe first line of each test case contains an integer $n$ ($1 \\le n \\le 2\\cdot10^5$) \u2014 the total population.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\le a_i \\le 10^6$) \u2014 the wealth of each person.\n\nIt is guaranteed that the sum of $n$ across all test cases does not exceed $2 \\cdot 10^5$.\n\nOutput Format:\nFor each test case, output one integer \u2014 the minimum number of gold that the richest person must find for Robin Hood to appear. If it is impossible, output $-1$ instead.\n\nTags:\n['binary search', 'greedy', 'math']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "6\n1\n2\n2\n2 19\n3\n1 3 20\n4\n1 2 3 4\n5\n1 2 3 4 5\n6\n1 2 1 1 1 25",
                "output": "-1\n-1\n0\n15\n16\n0"
            }
        ]
    },
    {
        "problem": "\nImpress thy brother, yet fret not thy mother.\n\nRobin's brother and mother are visiting, and Robin gets to choose the start day for each visitor.\n\nAll days are numbered from $1$ to $n$. Visitors stay for $d$ continuous days, all of those $d$ days must be between day $1$ and $n$ inclusive.\n\nRobin has a total of $k$ risky 'jobs' planned. The $i$-th job takes place between days $l_i$ and $r_i$ inclusive, for $1 \\le i \\le k$. If a job takes place on any of the $d$ days, the visit overlaps with this job (the length of overlap is unimportant).\n\nRobin wants his brother's visit to overlap with the maximum number of distinct jobs, and his mother's the minimum.\n\nFind suitable start days for the visits of Robin's brother and mother. If there are multiple suitable days, choose the earliest one.\n\nInput Format:\nThe first line of the input contains a single integer $t$ ($1\\leq t \\leq 10^4$) \u2014 the number of test cases.\n\nThe first line of each test case consists of three integers $n$, $d$, $k$ ($1 \\le n \\le 10^5, 1 \\le d, k \\le n$) \u2014 the number of total days, duration of the visits, and the number of jobs.\n\nThen follow $k$ lines of each test case, each with two integers $l_i$ and $r_i$ ($1 \\le l_i \\le r_i \\le n$) \u2014 the start and end day of each job.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\nOutput Format:\nFor each test case, output two integers, the best starting days of Robin's brother and mother respectively. Both visits must fit between day $1$ and $n$ inclusive.\n\nTags:\n['brute force', 'data structures', 'greedy', 'sortings']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "6\n2 1 1\n1 2\n4 1 2\n1 2\n2 4\n7 2 3\n1 2\n1 3\n6 7\n5 1 2\n1 2\n3 5\n9 2 1\n2 8\n9 2 4\n7 9\n4 8\n1 3\n2 3",
                "output": "1 1\n2 1\n1 4\n1 1\n1 1\n3 4"
            }
        ]
    },
    {
        "problem": "\nIn the humble act of meeting, joy doth unfold like a flower in bloom.\n\nAbsence makes the heart grow fonder. Marian sold her last ware at the Market at the same time Robin finished training at the Major Oak. They couldn't wait to meet, so they both start without delay.\n\nThe travel network is represented as $n$ vertices numbered from $1$ to $n$ and $m$ edges. The $i$-th edge connects vertices $u_i$ and $v_i$, and takes $w_i$ seconds to travel (all $w_i$ are even). Marian starts at vertex $1$ (Market) and Robin starts at vertex $n$ (Major Oak).\n\nIn addition, $h$ of the $n$ vertices each has a single horse available. Both Marian and Robin are capable riders, and could mount horses in no time (i.e. in $0$ seconds). Travel times are halved when riding. Once mounted, a horse lasts the remainder of the travel. Meeting must take place on a vertex (i.e. not on an edge). Either could choose to wait on any vertex.\n\nOutput the earliest time Robin and Marian can meet. If vertices $1$ and $n$ are disconnected, output $-1$ as the meeting is cancelled.\n\nInput Format:\nThe first line of the input contains a single integer $t$ ($1\\leq t \\leq 10^4$) \u2014 the number of test cases.\n\nThe first line of each test case consists of three integers $n$, $m$, $h$ ($2 \\le n \\le 2 \\cdot 10^5, \\;1 \\le m \\le 2 \\cdot 10^5, \\; 1 \\le h \\le n$) \u2014 the number of vertices, the number of edges and the number of vertices that have a single horse.\n\nThe second line of each test case contains $h$ distinct integers $a_1, a_2, \\ldots, a_h$ ($1 \\le a_i \\le n$) \u2014 the vertices that have a single horse available.\n\nThen follow $m$ lines of each test case, each with three integers $u_i$, $v_i$, $w_i$ ($1\\le u_i,v_i \\le n, \\; 2\\le w_i \\le 10^6$) \u2014 meaning that there is an edge between vertices $u_i$ and $v_i$ with travel cost $w_i$ seconds without a horse.\n\nThere are no self loops or multiple edges. By good fortune, all $w_i$ are even integers.\n\nIt is guaranteed that the sums of both $n$ and $m$ over all test cases do not exceed $2 \\cdot 10^5$.\n\nOutput Format:\nFor each test case, output a single integer, the earliest time Robin and Marian can meet. If it is impossible for them to meet, output $-1$.\n\nTags:\n['dfs and similar', 'graphs', 'shortest paths']\n\nTime Limit: 5000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "6\n2 1 1\n1\n1 2 10\n3 1 2\n2 3\n1 2 10\n3 3 1\n2\n1 2 4\n1 3 10\n2 3 6\n4 3 2\n2 3\n1 2 10\n2 3 18\n3 4 16\n3 2 1\n2\n1 2 4\n1 3 16\n7 7 1\n3\n1 5 2\n2 6 12\n1 2 12\n6 4 8\n7 3 4\n6 3 4\n7 6 4",
                "output": "5\n-1\n6\n19\n14\n12"
            }
        ]
    },
    {
        "problem": "\n\"Why, master,\" quoth Little John, taking the bags and weighing them in his hand, \"here is the chink of gold.\"\n\nThe folk hero Robin Hood has been troubling Sheriff of Nottingham greatly. Sheriff knows that Robin Hood is about to attack his camps and he wants to be prepared.\n\nSheriff of Nottingham built the camps with strategy in mind and thus there are exactly $n$ camps numbered from $1$ to $n$ and $n-1$ trails, each connecting two camps. Any camp can be reached from any other camp. Each camp $i$ has initially $a_i$ gold.\n\nAs it is now, all camps would be destroyed by Robin. Sheriff can strengthen a camp by subtracting exactly $c$ gold from each of its neighboring camps and use it to build better defenses for that camp. Strengthening a camp doesn't change its gold, only its neighbors' gold. A camp can have negative gold.\n\nAfter Robin Hood's attack, all camps that have been strengthened survive the attack, all others are destroyed.\n\nWhat's the maximum gold Sheriff can keep in his surviving camps after Robin Hood's attack if he strengthens his camps optimally?\n\nCamp $a$ is neighboring camp $b$ if and only if there exists a trail connecting $a$ and $b$. Only strengthened camps count towards the answer, as others are destroyed.\n\nInput Format:\nThe first line contains a single integer $t$ ($1 \\le t \\le 10^4$) \u2014 the number of test cases.\n\nEach test case begins with two integers $n$, $c$ ($1 \\le n \\le 2\\cdot10^5, 1 \\le c \\le 10^9$) \u2014 the number of camps and the gold taken from each neighboring camp for strengthening.\n\nThe second line of each test case contains $n$ integers $a_1,a_2,\\dots,a_n$ ($-10^9 \\le a_i \\le 10^9$) \u2014 the initial gold of each camp.\n\nThen follow $n-1$ lines, each with integers $u$, $v$ ($1 \\le u, v \\le n$, $u \\ne v$) \u2014 meaning that there is a trail between $u$ and $v$.\n\nThe sum of $n$ over all test cases doesn't exceed $2\\cdot10^5$.\n\nIt is guaranteed that any camp is reachable from any other camp.\n\nOutput Format:\nOutput a single integer, the maximum gold Sheriff of Nottingham can keep in his surviving camps after Robin Hood's attack.\n\nTags:\n['dfs and similar', 'dp', 'greedy', 'trees']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "5\n3 1\n2 3 1\n1 2\n2 3\n3 1\n3 6 3\n1 2\n2 3\n3 1\n-2 -3 -1\n1 2\n2 3\n6 1\n5 -4 3 6 7 3\n4 1\n5 1\n3 5\n3 6\n1 2\n8 1\n3 5 2 7 8 5 -3 -4\n7 3\n1 8\n4 3\n3 5\n7 6\n8 7\n2 1",
                "output": "3\n8\n0\n17\n26"
            }
        ]
    },
    {
        "problem": "\nWhat is done is done, and the spoilt milk cannot be helped.\n\nLittle John is as little as night is day \u2014 he was known to be a giant, at possibly $2.1$ metres tall. It has everything to do with his love for milk.\n\nHis dairy diary has $n$ entries, showing that he acquired $a_i$ pints of fresh milk on day $d_i$. Milk declines in freshness with time and stays drinkable for a maximum of $k$ days. In other words, fresh milk acquired on day $d_i$ will be drinkable between days $d_i$ and $d_i+k-1$ inclusive.\n\nEvery day, Little John drinks drinkable milk, up to a maximum of $m$ pints. In other words, if there are less than $m$ pints of milk, he will drink them all and not be satisfied; if there are at least $m$ pints of milk, he will drink exactly $m$ pints and be satisfied, and it's a milk satisfaction day.\n\nLittle John always drinks the freshest drinkable milk first.\n\nDetermine the number of milk satisfaction days for Little John.\n\nInput Format:\nThe first line of the input contains a single integer $t$ ($1\\leq t \\leq 10^4$), the number of test cases.\n\nThe first line of each test case consists of three integers $n$, $m$, $k$ ($1\\le n$, $m$, $k \\le 10^5$), the number of diary entries, the maximum pints needed for a milk satisfaction day, and the duration of milk's freshness.\n\nThen follow $n$ lines of each test case, each with two integers $d_i$ and $a_i$ ($1\\le d_i$, $a_i \\le 10^6$), the day on which the milk was acquired and the number of pints acquired. They are sorted in increasing values of $d_i$, and all values of $d_i$ are distinct.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\nOutput Format:\nFor each test case, output a single integer, the number of milk satisfaction days.\n\nTags:\n['brute force', 'data structures', 'greedy', 'implementation']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "6\n1 1 3\n1 5\n2 3 3\n1 5\n2 7\n4 5 2\n1 9\n2 6\n4 9\n5 6\n5 2 4\n4 7\n5 3\n7 1\n11 2\n12 1\n4 1 3\n5 10\n9 4\n14 8\n15 3\n5 5 5\n8 9\n10 7\n16 10\n21 5\n28 9",
                "output": "3\n3\n4\n5\n10\n6"
            }
        ]
    },
    {
        "problem": "\nAt such times archery was always the main sport of the day, for the Nottinghamshire yeomen were the best hand at the longbow in all merry England, but this year the Sheriff hesitated...\n\nSheriff of Nottingham has organized a tournament in archery. It's the final round and Robin Hood is playing against Sheriff!\n\nThere are $n$ targets in a row numbered from $1$ to $n$. When a player shoots target $i$, their score increases by $a_i$ and the target $i$ is destroyed. The game consists of turns and players alternate between whose turn it is. Robin Hood always starts the game, then Sheriff and so on. The game continues until all targets are destroyed. Both players start with score $0$.\n\nAt the end of the game, the player with most score wins and the other player loses. If both players have the same score, it's a tie and no one wins or loses. In each turn, the player can shoot any target that wasn't shot before. Both play optimally to get the most score possible.\n\nSheriff of Nottingham has a suspicion that he might lose the game! This cannot happen, you must help Sheriff. Sheriff will pose $q$ queries, each specifying $l$ and $r$. This means that the game would be played only with targets $l, l+1, \\dots, r$, as others would be removed by Sheriff before the game starts.\n\nFor each query $l$, $r$, determine whether the Sheriff can not lose the game when only considering the targets $l, l+1, \\dots, r$.\n\nInput Format:\nThe first line of input contains one integer $t$ ($1 \\le t \\le 10^4$) \u2014 the number of test cases.\n\nThe first line of each test case contains two integers $n$, $q$ ($1 \\le n,q \\le 2\\cdot10^5$) \u2014 the number of targets and the queries Sheriff will pose.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\le a_i \\le 10^6$) \u2014 the points for hitting each target.\n\nThen follow $q$ lines, each with two integers $l$ and $r$ ($1 \\le l \\le r \\le n$) \u2014 the range of the targets that is considered for each query.\n\nIt is guaranteed that the sum of both $n$ and $q$ across all test cases does not exceed $2 \\cdot 10^5$.\n\nOutput Format:\nFor each query, output \"YES\", if the Sheriff does not lose the game when only considering the targets $l, l+1, \\dots, r$, and \"NO\" otherwise.\n\nYou can output the answer in any case (upper or lower). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as positive responses.\n\nTags:\n['data structures', 'divide and conquer', 'greedy', 'hashing']\n\nTime Limit: 3000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "2\n3 3\n1 2 2\n1 2\n1 3\n2 3\n5 3\n2 1 2 1 1\n1 2\n1 3\n4 5",
                "output": "NO\nNO\nYES\nNO\nNO\nYES"
            }
        ]
    },
    {
        "problem": "\n[DJ Genki vs Gram - Einherjar Joker](https://soundcloud.com/leon- hwang-368077289/einherjar-joker-dj-genki-vs-gram)\n\n\u2800\n\nYou have some cards. An integer between $1$ and $n$ is written on each card: specifically, for each $i$ from $1$ to $n$, you have $a_i$ cards which have the number $i$ written on them.\n\nThere is also a shop which contains unlimited cards of each type. You have $k$ coins, so you can buy at most $k$ new cards in total, and the cards you buy can contain any integer between $\\mathbf{1}$ and $\\mathbf{n}$, inclusive.\n\nAfter buying the new cards, you must partition all your cards into decks, according to the following rules:\n\n  * all the decks must have the same size;    * there are no pairs of cards with the same value in the same deck. \n\nFind the maximum possible size of a deck after buying cards and partitioning them optimally.\n\nInput Format:\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains two integers $n$, $k$ ($1 \\leq n \\leq 2 \\cdot 10^5$, $0 \\leq k \\leq 10^{16}$) \u2014 the number of distinct types of cards and the number of coins.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($0 \\leq a_i \\leq 10^{10}$, $\\sum a_i \\geq 1$) \u2014 the number of cards of type $i$ you have at the beginning, for each $1 \\leq i \\leq n$.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\nOutput Format:\nFor each test case, output a single integer: the maximum possible size of a deck if you operate optimally.\n\nTags:\n['2-sat', 'brute force', 'greedy', 'implementation', 'math']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "9\n3 1\n3 2 2\n5 4\n2 6 1 2 4\n2 100\n1410065408 10000000000\n10 8\n7 4 6 6 9 3 10 2 8 7\n2 12\n2 2\n2 70\n0 1\n1 0\n1\n3 0\n2 1 2\n3 1\n0 3 3",
                "output": "2\n3\n1\n7\n2\n2\n1\n1\n2"
            }
        ]
    },
    {
        "problem": "\n[Djjaner - Speedbreaker](https://soundcloud.com/luciano- ferrari-151560131/speedbreaker)\n\n\u2800\n\nThere are $n$ cities in a row, numbered $1, 2, \\ldots, n$ left to right.\n\n  * At time $1$, you conquer exactly one city, called the starting city.    * At time $2, 3, \\ldots, n$, you can choose a city adjacent to the ones conquered so far and conquer it. \n\nYou win if, for each $i$, you conquer city $i$ at a time no later than $a_i$. A winning strategy may or may not exist, also depending on the starting city. How many starting cities allow you to win?\n\nInput Format:\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($1 \\le n \\le 2 \\cdot 10^5$) \u2014 the number of cities.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\le a_i \\le n$) \u2014 the deadlines for conquering the cities.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\nOutput Format:\nFor each test case, output a single integer: the number of starting cities that allow you to win.\n\nTags:\n['binary search', 'data structures', 'dp', 'greedy', 'implementation', 'two pointers']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "3\n6\n6 3 3 3 5 5\n6\n5 6 4 1 4 5\n9\n8 6 4 2 1 3 5 7 9",
                "output": "3\n0\n1"
            }
        ]
    },
    {
        "problem": "\n[t+pazolite, ginkiha, Hommarju - Paved Garden](https://soundcloud.com/fractalex-gd/ginkiha-paved-garden-little)\n\n\u2800\n\nYou are given a tree with $n$ nodes, rooted at node $1$. In this problem, a leaf is a non-root node with degree $1$.\n\nIn one operation, you can remove a leaf and the edge adjacent to it (possibly, new leaves appear). What is the minimum number of operations that you have to perform to get a tree, also rooted at node $1$, where all the leaves are at the same distance from the root?\n\nInput Format:\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($3 \\leq n \\leq 5 \\cdot 10^5$) \u2014 the number of nodes.\n\nEach of the next $n-1$ lines contains two integers $u$, $v$ ($1 \\leq u, v \\leq n$, $u \\neq v$), describing an edge that connects $u$ and $v$. It is guaranteed that the given edges form a tree.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $5 \\cdot 10^5$.\n\nOutput Format:\nFor each test case, output a single integer: the minimum number of operations needed to achieve your goal.\n\nTags:\n['brute force', 'dfs and similar', 'greedy', 'sortings', 'trees']\n\nTime Limit: 3000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "3\n7\n1 2\n1 3\n2 4\n2 5\n4 6\n4 7\n7\n1 2\n1 3\n1 4\n2 5\n3 6\n5 7\n15\n12 9\n1 6\n6 14\n9 11\n8 7\n3 5\n13 5\n6 10\n13 15\n13 6\n14 12\n7 2\n8 1\n1 4",
                "output": "2\n2\n5"
            }
        ]
    },
    {
        "problem": "\n[EnV - The Dusty Dragon Tavern](https://soundcloud.com/envyofficial/env-the- dusty-dragon-tavern)\n\n\u2800\n\nYou are given an array $a_1, a_2, \\ldots, a_n$ of positive integers.\n\nYou can color some elements of the array red, but there cannot be two adjacent red elements (i.e., for $1 \\leq i \\leq n-1$, at least one of $a_i$ and $a_{i+1}$ must not be red).\n\nYour score is the maximum value of a red element, plus the minimum value of a red element, plus the number of red elements. Find the maximum score you can get.\n\nInput Format:\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($1 \\le n \\le 2 \\cdot 10^5$) \u2014 the length of the array.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\le a_i \\le 10^9$) \u2014 the given array.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\nOutput Format:\nFor each test case, output a single integer: the maximum possible score you can get after coloring some elements red according to the statement.\n\nTags:\n['data structures', 'dp', 'dsu', 'greedy', 'implementation', 'matrices', 'sortings']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "4\n3\n5 4 5\n3\n4 5 4\n10\n3 3 3 3 4 1 2 3 5 4\n10\n17 89 92 42 29 41 92 14 70 45",
                "output": "12\n11\n12\n186"
            }
        ]
    },
    {
        "problem": "\n[Ken Arai - COMPLEX](https://soundcloud.com/diatomichail2/complex)\n\n\u2800\n\nThis is the easy version of the problem. In this version, the constraints on $n$ and the time limit are lower. You can make hacks only if both versions of the problem are solved.\n\nA set of (closed) segments is complex if it can be partitioned into some subsets such that\n\n  * all the subsets have the same size; and    * a pair of segments intersects if and only if the two segments are in the same subset. \n\nYou are given $n$ segments $[l_1, r_1], [l_2, r_2], \\ldots, [l_n, r_n]$. Find the maximum size of a complex subset of these segments.\n\nInput Format:\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^3$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($1 \\le n \\le 2 \\cdot 10^4$) \u2014 the number of segments.\n\nThe second line of each test case contains $n$ integers $l_1, l_2, \\ldots, l_n$ ($1 \\le l_i \\le 2n$) \u2014 the left endpoints of the segments.\n\nThe third line of each test case contains $n$ integers $r_1, r_2, \\ldots, r_n$ ($l_i \\leq r_i \\le 2n$) \u2014 the right endpoints of the segments.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^4$.\n\nOutput Format:\nFor each test case, output a single integer: the maximum size of a complex subset of the given segments.\n\nTags:\n['binary search', 'data structures', 'divide and conquer', 'dsu', 'greedy', 'math', 'sortings']\n\nTime Limit: 6000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "3\n3\n1 2 3\n5 4 6\n5\n1 2 3 6 8\n5 4 7 9 10\n5\n3 1 4 1 5\n7 2 6 5 10",
                "output": "3\n4\n4"
            }
        ]
    },
    {
        "problem": "\n[Ken Arai - COMPLEX](https://soundcloud.com/diatomichail2/complex)\n\n\u2800\n\nThis is the hard version of the problem. In this version, the constraints on $n$ and the time limit are higher. You can make hacks only if both versions of the problem are solved.\n\nA set of (closed) segments is complex if it can be partitioned into some subsets such that\n\n  * all the subsets have the same size; and    * a pair of segments intersects if and only if the two segments are in the same subset. \n\nYou are given $n$ segments $[l_1, r_1], [l_2, r_2], \\ldots, [l_n, r_n]$. Find the maximum size of a complex subset of these segments.\n\nInput Format:\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^3$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($1 \\le n \\le 3 \\cdot 10^5$) \u2014 the number of segments.\n\nThe second line of each test case contains $n$ integers $l_1, l_2, \\ldots, l_n$ ($1 \\le l_i \\le 2n$) \u2014 the left endpoints of the segments.\n\nThe third line of each test case contains $n$ integers $r_1, r_2, \\ldots, r_n$ ($l_i \\leq r_i \\le 2n$) \u2014 the right endpoints of the segments.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $3 \\cdot 10^5$.\n\nOutput Format:\nFor each test case, output a single integer: the maximum size of a complex subset of the given segments.\n\nTags:\n['binary search', 'data structures', 'divide and conquer', 'dsu', 'greedy', 'math', 'sortings']\n\nTime Limit: 13000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "3\n3\n1 2 3\n5 4 6\n5\n1 2 3 6 8\n5 4 7 9 10\n5\n3 1 4 1 5\n7 2 6 5 10",
                "output": "3\n4\n4"
            }
        ]
    },
    {
        "problem": "\n[NightHawk22 - Isolation](https://soundcloud.com/vepium/nighthawk22-isolation- official-limbo-remix)\n\n\u2800\n\nThis is the easy version of the problem. In the three versions, the constraints on $n$ and the time limit are different. You can make hacks only if all the versions of the problem are solved.\n\nThis is the statement of Problem D1B:\n\n  * There are $n$ cities in a row, numbered $1, 2, \\ldots, n$ left to right.     * At time $1$, you conquer exactly one city, called the starting city.      * At time $2, 3, \\ldots, n$, you can choose a city adjacent to the ones conquered so far and conquer it. \n\nYou win if, for each $i$, you conquer city $i$ at a time no later than $a_i$. A winning strategy may or may not exist, also depending on the starting city. How many starting cities allow you to win?\n\nFor each $0 \\leq k \\leq n$, count the number of arrays of positive integers $a_1, a_2, \\ldots, a_n$ such that\n\n  * $1 \\leq a_i \\leq n$ for each $1 \\leq i \\leq n$;    * the answer to Problem D1B is $k$. \n\nThe answer can be very large, so you have to calculate it modulo a given prime $p$.\n\nInput Format:\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 80$). The description of the test cases follows.\n\nThe only line of each test case contains two integers $n$, $p$ ($1 \\le n \\le 80$, $10^8 \\leq p \\leq 10^9$, $p$ is prime) \u2014 the number of cities and the modulo.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $80$.\n\nOutput Format:\nFor each test case, output $n+1$ integers: the $i$-th integer should be the number of arrays that satisfy the conditions for $k = i-1$.\n\nTags:\n['combinatorics', 'dp', 'greedy', 'math']\n\nTime Limit: 2000 ms\nMemory Limit: 1024 MB\n",
        "tests": [
            {
                "input": "11\n1 998244353\n2 998244353\n3 998244353\n4 998244353\n5 998244353\n6 998244353\n7 998244353\n8 998244353\n9 998244353\n10 102275857\n10 999662017",
                "output": "0 1 \n1 2 1 \n14 7 4 2 \n183 34 19 16 4 \n2624 209 112 120 48 12 \n42605 1546 793 992 468 216 36 \n785910 13327 6556 9190 4672 2880 864 144 \n16382863 130922 61939 94992 50100 36960 14256 4608 576 \n382823936 1441729 657784 1086596 583344 488700 216000 96480 23040 2880 \n20300780 17572114 7751377 13641280 7376068 6810552 3269700 1785600 576000 144000 14400 \n944100756 17572114 7751377 13641280 7376068 6810552 3269700 1785600 576000 144000 14400"
            }
        ]
    },
    {
        "problem": "\n[NightHawk22 - Isolation](https://soundcloud.com/vepium/nighthawk22-isolation- official-limbo-remix)\n\n\u2800\n\nThis is the medium version of the problem. In the three versions, the constraints on $n$ and the time limit are different. You can make hacks only if all the versions of the problem are solved.\n\nThis is the statement of Problem D1B:\n\n  * There are $n$ cities in a row, numbered $1, 2, \\ldots, n$ left to right.     * At time $1$, you conquer exactly one city, called the starting city.      * At time $2, 3, \\ldots, n$, you can choose a city adjacent to the ones conquered so far and conquer it. \n\nYou win if, for each $i$, you conquer city $i$ at a time no later than $a_i$. A winning strategy may or may not exist, also depending on the starting city. How many starting cities allow you to win?\n\nFor each $0 \\leq k \\leq n$, count the number of arrays of positive integers $a_1, a_2, \\ldots, a_n$ such that\n\n  * $1 \\leq a_i \\leq n$ for each $1 \\leq i \\leq n$;    * the answer to Problem D1B is $k$. \n\nThe answer can be very large, so you have to calculate it modulo a given prime $p$.\n\nInput Format:\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 500$). The description of the test cases follows.\n\nThe only line of each test case contains two integers $n$, $p$ ($1 \\le n \\le 500$, $10^8 \\leq p \\leq 10^9$, $p$ is prime) \u2014 the number of cities and the modulo.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $500$.\n\nOutput Format:\nFor each test case, output $n+1$ integers: the $i$-th integer should be the number of arrays that satisfy the conditions for $k = i-1$.\n\nTags:\n['dp', 'greedy', 'math']\n\nTime Limit: 10000 ms\nMemory Limit: 1024 MB\n",
        "tests": [
            {
                "input": "11\n1 998244353\n2 998244353\n3 998244353\n4 998244353\n5 998244353\n6 998244353\n7 998244353\n8 998244353\n9 998244353\n10 102275857\n10 999662017",
                "output": "0 1 \n1 2 1 \n14 7 4 2 \n183 34 19 16 4 \n2624 209 112 120 48 12 \n42605 1546 793 992 468 216 36 \n785910 13327 6556 9190 4672 2880 864 144 \n16382863 130922 61939 94992 50100 36960 14256 4608 576 \n382823936 1441729 657784 1086596 583344 488700 216000 96480 23040 2880 \n20300780 17572114 7751377 13641280 7376068 6810552 3269700 1785600 576000 144000 14400 \n944100756 17572114 7751377 13641280 7376068 6810552 3269700 1785600 576000 144000 14400"
            }
        ]
    },
    {
        "problem": "\n[NightHawk22 - Isolation](https://soundcloud.com/vepium/nighthawk22-isolation- official-limbo-remix)\n\n\u2800\n\nThis is the hard version of the problem. In the three versions, the constraints on $n$ and the time limit are different. You can make hacks only if all the versions of the problem are solved.\n\nThis is the statement of Problem D1B:\n\n  * There are $n$ cities in a row, numbered $1, 2, \\ldots, n$ left to right.     * At time $1$, you conquer exactly one city, called the starting city.      * At time $2, 3, \\ldots, n$, you can choose a city adjacent to the ones conquered so far and conquer it. \n\nYou win if, for each $i$, you conquer city $i$ at a time no later than $a_i$. A winning strategy may or may not exist, also depending on the starting city. How many starting cities allow you to win?\n\nFor each $0 \\leq k \\leq n$, count the number of arrays of positive integers $a_1, a_2, \\ldots, a_n$ such that\n\n  * $1 \\leq a_i \\leq n$ for each $1 \\leq i \\leq n$;    * the answer to Problem D1B is $k$. \n\nThe answer can be very large, so you have to calculate it modulo a given prime $p$.\n\nInput Format:\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 3000$). The description of the test cases follows.\n\nThe only line of each test case contains two integers $n$, $p$ ($1 \\le n \\le 3000$, $10^8 \\leq p \\leq 10^9$, $p$ is prime) \u2014 the number of cities and the modulo.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $3000$.\n\nOutput Format:\nFor each test case, output $n+1$ integers: the $i$-th integer should be the number of arrays that satisfy the conditions for $k = i-1$.\n\nTags:\n['dp', 'greedy', 'math']\n\nTime Limit: 10000 ms\nMemory Limit: 1024 MB\n",
        "tests": [
            {
                "input": "11\n1 998244353\n2 998244353\n3 998244353\n4 998244353\n5 998244353\n6 998244353\n7 998244353\n8 998244353\n9 998244353\n10 102275857\n10 999662017",
                "output": "0 1 \n1 2 1 \n14 7 4 2 \n183 34 19 16 4 \n2624 209 112 120 48 12 \n42605 1546 793 992 468 216 36 \n785910 13327 6556 9190 4672 2880 864 144 \n16382863 130922 61939 94992 50100 36960 14256 4608 576 \n382823936 1441729 657784 1086596 583344 488700 216000 96480 23040 2880 \n20300780 17572114 7751377 13641280 7376068 6810552 3269700 1785600 576000 144000 14400 \n944100756 17572114 7751377 13641280 7376068 6810552 3269700 1785600 576000 144000 14400"
            }
        ]
    },
    {
        "problem": "\n[EnV - Dynasty](https://soundcloud.com/envyofficial/env-dynasty)\n\n\u2800\n\nYou are given an array $a_1, a_2, \\ldots, a_n$ of positive integers.\n\nYou can color some elements of the array red, but there cannot be two adjacent red elements (i.e., for $1 \\leq i \\leq n-1$, at least one of $a_i$ and $a_{i+1}$ must not be red).\n\nYour score is the maximum value of a red element plus the number of red elements. Find the maximum score you can get.\n\nInput Format:\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 500$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($1 \\le n \\le 100$) \u2014 the length of the array.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\le a_i \\le 1000$) \u2014 the given array.\n\nOutput Format:\nFor each test case, output a single integer: the maximum possible score you can get after coloring some elements red according to the statement.\n\nTags:\n['brute force', 'dp', 'greedy']\n\nTime Limit: 1000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "4\n3\n5 4 5\n3\n4 5 4\n10\n3 3 3 3 4 1 2 3 4 5\n9\n17 89 92 42 29 92 14 70 45",
                "output": "7\n6\n10\n97"
            }
        ]
    },
    {
        "problem": "\n[Shirobon - FOX](https://soundcloud.com/shirobon/fox?in=mart_207/sets/fav)\n\n\u2800\n\nYou are given $n$ points on the $x$ axis, at increasing positive integer coordinates $x_1 < x_2 < \\ldots < x_n$.\n\nFor each pair $(i, j)$ with $1 \\leq i < j \\leq n$, you draw the segment $[x_i, x_j]$. The segments are closed, i.e., a segment $[a, b]$ contains the points $a, a+1, \\ldots, b$.\n\nYou are given $q$ queries. In the $i$-th query, you are given a positive integer $k_i$, and you have to determine how many points with integer coordinates are contained in exactly $k_i$ segments.\n\nInput Format:\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains two integers $n$, $q$ ($2 \\le n \\le 10^5$, $1 \\le q \\le 10^5$) \u2014 the number of points and the number of queries.\n\nThe second line of each test case contains $n$ integers $x_1, x_2, \\ldots, x_n$ ($1 \\leq x_1 < x_2 < \\ldots < x_n \\leq 10^9$) \u2014 the coordinates of the $n$ points.\n\nThe third line of each test case contains $q$ integers $k_1, k_2, \\ldots, k_q$ ($1 \\leq k_i \\leq 10^{18}$) \u2014 the parameters of the $q$ queries.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $10^5$, and the sum of $q$ over all test cases does not exceed $10^5$.\n\nOutput Format:\nFor each test case, output a single line with $q$ integers: the $i$-th integer is the answer to the $i$-th query.\n\nTags:\n['implementation', 'math']\n\nTime Limit: 1500 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "3\n2 2\n101 200\n2 1\n6 15\n1 2 3 5 6 7\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15\n5 8\n254618033 265675151 461318786 557391198 848083778\n6 9 15 10 6 9 4 4294967300",
                "output": "0 100 \n0 0 0 0 2 0 0 0 3 0 2 0 0 0 0 \n291716045 0 0 0 291716045 0 301749698 0"
            }
        ]
    },
    {
        "problem": "\n[DJ Genki vs Gram - Einherjar Joker](https://soundcloud.com/leon- hwang-368077289/einherjar-joker-dj-genki-vs-gram)\n\n\u2800\n\nYou have some cards. An integer between $1$ and $n$ is written on each card: specifically, for each $i$ from $1$ to $n$, you have $a_i$ cards which have the number $i$ written on them.\n\nThere is also a shop which contains unlimited cards of each type. You have $k$ coins, so you can buy at most $k$ new cards in total, and the cards you buy can contain any integer between $\\mathbf{1}$ and $\\mathbf{n}$, inclusive.\n\nAfter buying the new cards, you must partition all your cards into decks, according to the following rules:\n\n  * all the decks must have the same size;    * there are no pairs of cards with the same value in the same deck. \n\nFind the maximum possible size of a deck after buying cards and partitioning them optimally.\n\nInput Format:\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains two integers $n$, $k$ ($1 \\leq n \\leq 2 \\cdot 10^5$, $0 \\leq k \\leq 10^{16}$) \u2014 the number of distinct types of cards and the number of coins.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($0 \\leq a_i \\leq 10^{10}$, $\\sum a_i \\geq 1$) \u2014 the number of cards of type $i$ you have at the beginning, for each $1 \\leq i \\leq n$.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\nOutput Format:\nFor each test case, output a single integer: the maximum possible size of a deck if you operate optimally.\n\nTags:\n['greedy', 'implementation', 'math']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "9\n3 1\n3 2 2\n5 4\n2 6 1 2 4\n2 100\n1410065408 10000000000\n10 8\n7 4 6 6 9 3 10 2 8 7\n2 12\n2 2\n2 70\n0 1\n1 0\n1\n3 0\n2 1 2\n3 1\n0 3 3",
                "output": "2\n3\n1\n7\n2\n2\n1\n1\n2"
            }
        ]
    },
    {
        "problem": "\n[Djjaner - Speedbreaker](https://soundcloud.com/luciano- ferrari-151560131/speedbreaker)\n\n\u2800\n\nThere are $n$ cities in a row, numbered $1, 2, \\ldots, n$ left to right.\n\n  * At time $1$, you conquer exactly one city, called the starting city.    * At time $2, 3, \\ldots, n$, you can choose a city adjacent to the ones conquered so far and conquer it. \n\nYou win if, for each $i$, you conquer city $i$ at a time no later than $a_i$. A winning strategy may or may not exist, also depending on the starting city. How many starting cities allow you to win?\n\nInput Format:\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($1 \\le n \\le 2 \\cdot 10^5$) \u2014 the number of cities.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\le a_i \\le n$) \u2014 the deadlines for conquering the cities.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\nOutput Format:\nFor each test case, output a single integer: the number of starting cities that allow you to win.\n\nTags:\n['binary search', 'constructive algorithms', 'data structures', 'greedy', 'math']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "3\n6\n6 3 3 3 5 5\n6\n5 6 4 1 4 5\n9\n8 6 4 2 1 3 5 7 9",
                "output": "3\n0\n1"
            }
        ]
    },
    {
        "problem": "\n[t+pazolite, ginkiha, Hommarju - Paved Garden](https://soundcloud.com/fractalex-gd/ginkiha-paved-garden-little)\n\n\u2800\n\nYou are given a tree with $n$ nodes, rooted at node $1$. In this problem, a leaf is a non-root node with degree $1$.\n\nIn one operation, you can remove a leaf and the edge adjacent to it (possibly, new leaves appear). What is the minimum number of operations that you have to perform to get a tree, also rooted at node $1$, where all the leaves are at the same distance from the root?\n\nInput Format:\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($3 \\leq n \\leq 5 \\cdot 10^5$) \u2014 the number of nodes.\n\nEach of the next $n-1$ lines contains two integers $u$, $v$ ($1 \\leq u, v \\leq n$, $u \\neq v$), describing an edge that connects $u$ and $v$. It is guaranteed that the given edges form a tree.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $5 \\cdot 10^5$.\n\nOutput Format:\nFor each test case, output a single integer: the minimum number of operations needed to achieve your goal.\n\nTags:\n['constructive algorithms', 'dfs and similar', 'dp', 'sortings', 'trees']\n\nTime Limit: 3000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "3\n7\n1 2\n1 3\n2 4\n2 5\n4 6\n4 7\n7\n1 2\n1 3\n1 4\n2 5\n3 6\n5 7\n15\n12 9\n1 6\n6 14\n9 11\n8 7\n3 5\n13 5\n6 10\n13 15\n13 6\n14 12\n7 2\n8 1\n1 4",
                "output": "2\n2\n5"
            }
        ]
    },
    {
        "problem": "\n[EnV - The Dusty Dragon Tavern](https://soundcloud.com/envyofficial/env-the- dusty-dragon-tavern)\n\n\u2800\n\nYou are given an array $a_1, a_2, \\ldots, a_n$ of positive integers.\n\nYou can color some elements of the array red, but there cannot be two adjacent red elements (i.e., for $1 \\leq i \\leq n-1$, at least one of $a_i$ and $a_{i+1}$ must not be red).\n\nYour score is the maximum value of a red element, plus the minimum value of a red element, plus the number of red elements. Find the maximum score you can get.\n\nInput Format:\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($1 \\le n \\le 2 \\cdot 10^5$) \u2014 the length of the array.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\le a_i \\le 10^9$) \u2014 the given array.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\nOutput Format:\nFor each test case, output a single integer: the maximum possible score you can get after coloring some elements red according to the statement.\n\nTags:\n['data structures', 'dp', 'dsu', 'greedy', 'sortings']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "4\n3\n5 4 5\n3\n4 5 4\n10\n3 3 3 3 4 1 2 3 5 4\n10\n17 89 92 42 29 41 92 14 70 45",
                "output": "12\n11\n12\n186"
            }
        ]
    },
    {
        "problem": "\nYou are given two integers $n$ and $k$.\n\nIn one operation, you can subtract any power of $k$ from $n$. Formally, in one operation, you can replace $n$ by $(n-k^x)$ for any non-negative integer $x$.\n\nFind the minimum number of operations required to make $n$ equal to $0$.\n\nInput Format:\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe only line of each test case contains two integers $n$ and $k$ ($1 \\le n, k \\le 10^9$).\n\nOutput Format:\nFor each test case, output the minimum number of operations on a new line.\n\nTags:\n['bitmasks', 'brute force', 'greedy', 'math', 'number theory']\n\nTime Limit: 1000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "6\n5 2\n3 5\n16 4\n100 3\n6492 10\n10 1",
                "output": "2\n3\n1\n4\n21\n10"
            }
        ]
    },
    {
        "problem": "\nImagine you have $n$ light bulbs numbered $1, 2, \\ldots, n$. Initially, all bulbs are on. To flip the state of a bulb means to turn it off if it used to be on, and to turn it on otherwise.\n\nNext, you do the following:\n\n  * for each $i = 1, 2, \\ldots, n$, flip the state of all bulbs $j$ such that $j$ is divisible by $i^\\dagger$. \n\nAfter performing all operations, there will be several bulbs that are still on. Your goal is to make this number exactly $k$.\n\nFind the smallest suitable $n$ such that after performing the operations there will be exactly $k$ bulbs on. We can show that an answer always exists.\n\n$^\\dagger$ An integer $x$ is divisible by $y$ if there exists an integer $z$ such that $x = y\\cdot z$.\n\nInput Format:\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe only line of each test case contains a single integer $k$ ($1 \\le k \\le 10^{18}$).\n\nOutput Format:\nFor each test case, output $n$ \u2014 the minimum number of bulbs.\n\nTags:\n['binary search', 'math']\n\nTime Limit: 1000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "3\n1\n3\n8",
                "output": "2\n5\n11"
            }
        ]
    },
    {
        "problem": "\nYou are given three non-negative integers $b$, $c$, and $d$.\n\nPlease find a non-negative integer $a \\in [0, 2^{61}]$ such that $(a\\, |\\, b)-(a\\, \\&\\, c)=d$, where $|$ and $\\&$ denote the [bitwise OR operation](https://en.wikipedia.org/wiki/Bitwise_operation#OR) and the [bitwise AND operation](https://en.wikipedia.org/wiki/Bitwise_operation#AND), respectively.\n\nIf such an $a$ exists, print its value. If there is no solution, print a single integer $-1$. If there are multiple solutions, print any of them.\n\nInput Format:\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^5$). The description of the test cases follows.\n\nThe only line of each test case contains three positive integers $b$, $c$, and $d$ ($0 \\le b, c, d \\le 10^{18}$).\n\nOutput Format:\nFor each test case, output the value of $a$, or $-1$ if there is no solution. Please note that $a$ must be non-negative and cannot exceed $2^{61}$.\n\nTags:\n['bitmasks', 'hashing', 'implementation', 'math', 'schedules', 'ternary search']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "3\n2 2 2\n4 2 6\n10 2 14",
                "output": "0\n-1\n12"
            }
        ]
    },
    {
        "problem": "\nOne fine evening, Alice sat down to play the classic game \"Connect the Dots\", but with a twist.\n\nTo play the game, Alice draws a straight line and marks $n$ points on it, indexed from $1$ to $n$. Initially, there are no arcs between the points, so they are all disjoint. After that, Alice performs $m$ operations of the following type:\n\n  * She picks three integers $a_i$, $d_i$ ($1 \\le d_i \\le 10$), and $k_i$.    * She selects points $a_i, a_i+d_i, a_i+2d_i, a_i+3d_i, \\ldots, a_i+k_i\\cdot d_i$ and connects each pair of these points with arcs. \n\nAfter performing all $m$ operations, she wants to know the number of connected components$^\\dagger$ these points form. Please help her find this number.\n\n$^\\dagger$ Two points are said to be in one connected component if there is a path between them via several (possibly zero) arcs and other points.\n\nInput Format:\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^5$). The description of the test cases follows.\n\nThe first line of each test case contains two integers $n$ and $m$ ($1 \\le n \\le 2 \\cdot 10^5$, $1 \\le m \\le 2 \\cdot 10^5$).\n\nThe $i$-th of the following $m$ lines contains three integers $a_i$, $d_i$, and $k_i$ ($1 \\le a_i \\le a_i + k_i\\cdot d_i \\le n$, $1 \\le d_i \\le 10$, $0 \\le k_i \\le n$).\n\nIt is guaranteed that both the sum of $n$ and the sum of $m$ over all test cases do not exceed $2 \\cdot 10^5$.\n\nOutput Format:\nFor each test case, output the number of connected components.\n\nTags:\n['brute force', 'dp', 'dsu', 'graphs', 'math', 'trees']\n\nTime Limit: 2000 ms\nMemory Limit: 512 MB\n",
        "tests": [
            {
                "input": "3\n10 2\n1 2 4\n2 2 4\n100 1\n19 2 4\n100 3\n1 2 5\n7 2 6\n17 2 31",
                "output": "2\n96\n61"
            }
        ]
    },
    {
        "problem": "\nYou are given an array of $n$ integers $a_1,a_2,\\ldots,a_n$. You are also given an array $p_1, p_2, \\ldots, p_n$.\n\nLet $S$ denote the random multiset (i. e., it may contain equal elements) constructed as follows:\n\n  * Initially, $S$ is empty.    * For each $i$ from $1$ to $n$, insert $a_i$ into $S$ with probability $\\frac{p_i}{10^4}$. Note that each element is inserted independently. \n\nDenote $f(S)$ as the [bitwise XOR](https://en.wikipedia.org/wiki/Bitwise_operation#XOR) of all elements of $S$. Please calculate the expected value of $(f(S))^2$. Output the answer modulo $10^9 + 7$.\n\nFormally, let $M = 10^9 + 7$. It can be shown that the answer can be expressed as an irreducible fraction $\\frac{p}{q}$, where $p$ and $q$ are integers and $q \\not \\equiv 0 \\pmod{M}$. Output the integer equal to $p \\cdot q^{-1} \\bmod M$. In other words, output such an integer $x$ that $0 \\le x < M$ and $x \\cdot q \\equiv p \\pmod{M}$.\n\nInput Format:\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($1 \\le n \\le 2 \\cdot 10^5$).\n\nThe second line of each test case contains $n$ integers $a_1,a_2,\\ldots,a_n$ ($1 \\le a_i \\le 1023$).\n\nThe third line of each test case contains $n$ integers $p_1,p_2,\\ldots,p_n$ ($1 \\le p_i \\le 10^4$).\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\nOutput Format:\nFor each test case, output the expected value of $(f(S))^2$, modulo $10^9 + 7$.\n\nTags:\n['bitmasks', 'dp', 'math', 'probabilities']\n\nTime Limit: 4000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "4\n2\n1 2\n5000 5000\n2\n1 1\n1000 2000\n6\n343 624 675 451 902 820\n6536 5326 7648 2165 9430 5428\n1\n1\n10000",
                "output": "500000007\n820000006\n280120536\n1"
            }
        ]
    },
    {
        "problem": "\nLet $n$ and $d$ be positive integers. We build the the divisor tree $T_{n,d}$ as follows:\n\n  * The root of the tree is a node marked with number $n$. This is the $0$-th layer of the tree.    * For each $i$ from $0$ to $d - 1$, for each vertex of the $i$-th layer, do the following. If the current vertex is marked with $x$, create its children and mark them with all possible distinct divisors$^\\dagger$ of $x$. These children will be in the $(i+1)$-st layer.    * The vertices on the $d$-th layer are the leaves of the tree. \n\nFor example, $T_{6,2}$ (the divisor tree for $n = 6$ and $d = 2$) looks like this:\n\n![](CDN_BASE_URL/782ea6d6fe622ee5ec986b0d8cae274d)\n\nDefine $f(n,d)$ as the number of leaves in $T_{n,d}$.\n\nGiven integers $n$, $k$, and $d$, please compute $\\sum\\limits_{i=1}^{n} f(i^k,d)$, modulo $10^9+7$.\n\n$^\\dagger$ In this problem, we say that an integer $y$ is a divisor of $x$ if $y \\ge 1$ and there exists an integer $z$ such that $x = y \\cdot z$.\n\nInput Format:\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe only line of each test case contains three integers $n$, $k$, and $d$ ($1 \\le n \\le 10^9$, $1 \\le k,d \\le 10^5$).\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $10^9$.\n\nOutput Format:\nFor each test case, output $\\sum\\limits_{i=1}^{n} f(i^k,d)$, modulo $10^9+7$.\n\nTags:\n['dp', 'math', 'number theory']\n\nTime Limit: 4000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "3\n6 1 1\n1 3 3\n10 1 2",
                "output": "14\n1\n53"
            }
        ]
    },
    {
        "problem": "\nPak Chanek has an array $a$ of $n$ positive integers. Since he is currently learning how to calculate the floored average of two numbers, he wants to practice it on his array $a$.\n\nWhile the array $a$ has at least two elements, Pak Chanek will perform the following three-step operation:\n\n  1. Pick two different indices $i$ and $j$ ($1 \\leq i, j \\leq |a|$; $i \\neq j$), note that $|a|$ denotes the current size of the array $a$.    2. Append $\\lfloor \\frac{a_i+a_j}{2} \\rfloor$$^{\\text{\u2217}}$ to the end of the array.    3. Remove elements $a_i$ and $a_j$ from the array and concatenate the remaining parts of the array. \n\nFor example, suppose that $a=[5,4,3,2,1,1]$. If we choose $i=1$ and $j=5$, the resulting array will be $a=[4,3,2,1,3]$. If we choose $i=4$ and $j=3$, the resulting array will be $a=[5,4,1,1,2]$.\n\nAfter all operations, the array will consist of a single element $x$. Find the maximum possible value of $x$ if Pak Chanek performs the operations optimally.\n\n$^{\\text{\u2217}}$$\\lfloor x \\rfloor$ denotes the floor function of $x$, which is the greatest integer that is less than or equal to $x$. For example, $\\lfloor 6 \\rfloor = 6$, $\\lfloor 2.5 \\rfloor=2$, $\\lfloor -3.6 \\rfloor=-4$ and $\\lfloor \\pi \\rfloor=3$\n\nInput Format:\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 5000$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($2 \\le n \\le 50$) \u2014 the length of the array $a$.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\le a_i \\le 10^9$) \u2014 the elements of the array $a$.\n\nDo note that the sum of $n$ over all test cases is not bounded.\n\nOutput Format:\nFor each test case, output a single integer: the maximum possible value of $x$ after all numbers have been picked.\n\nTags:\n['data structures', 'greedy', 'math', 'sortings']\n\nTime Limit: 1000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "3\n5\n1 7 8 4 5\n3\n2 6 5\n5\n5 5 5 5 5",
                "output": "6\n4\n5"
            }
        ]
    },
    {
        "problem": "\nYou are given an array $a$ of $n$ positive integers and an integer $x$. You can do the following two-step operation any (possibly zero) number of times:\n\n  1. Choose an index $i$ ($1 \\leq i \\leq n$).    2. Increase $a_i$ by $x$, in other words $a_i := a_i + x$. \n\nFind the maximum value of the $\\operatorname{MEX}$ of $a$ if you perform the operations optimally.\n\nThe $\\operatorname{MEX}$ (minimum excluded value) of an array is the smallest non-negative integer that is not in the array. For example:\n\n  * The $\\operatorname{MEX}$ of $[2,2,1]$ is $0$ because $0$ is not in the array.    * The $\\operatorname{MEX}$ of $[3,1,0,1]$ is $2$ because $0$ and $1$ are in the array but $2$ is not.    * The $\\operatorname{MEX}$ of $[0,3,1,2]$ is $4$ because $0$, $1$, $2$ and $3$ are in the array but $4$ is not.\n\nInput Format:\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 5000$). The description of the test cases follows.\n\nThe first line of each test case contains two integers $n$ and $x$ ($1 \\le n \\le 2 \\cdot 10^5$; $1 \\le x \\le 10^9$) \u2014 the length of the array and the integer to be used in the operation.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($0 \\le a_i \\le 10^9$) \u2014 the given array.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\nOutput Format:\nFor each test case, output a single integer: the maximum $\\operatorname{MEX}$ of $a$ if you perform the operations optimally.\n\nTags:\n['brute force', 'greedy', 'math', 'number theory']\n\nTime Limit: 1000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "3\n6 3\n0 3 2 1 5 2\n6 2\n1 3 4 1 0 2\n4 5\n2 5 10 3",
                "output": "4\n6\n0"
            }
        ]
    },
    {
        "problem": "\nThis is the easy version of the problem. In the two versions, the constraints on $q$ and the time limit are different. In this version, $q=0$. You can make hacks only if all the versions of the problem are solved.\n\nA team consisting of $n$ members, numbered from $1$ to $n$, is set to present a slide show at a large meeting. The slide show contains $m$ slides.\n\nThere is an array $a$ of length $n$. Initially, the members are standing in a line in the order of $a_1, a_2, \\ldots, a_n$ from front to back. The slide show will be presented in order from slide $1$ to slide $m$. Each section will be presented by the member at the front of the line. After each slide is presented, you can move the member at the front of the line to any position in the lineup (without changing the order of the rest of the members). For example, suppose the line of members is $[\\color{red}{3},1,2,4]$. After member $3$ presents the current slide, you can change the line of members into either $[\\color{red}{3},1,2,4]$, $[1,\\color{red}{3},2,4]$, $[1,2,\\color{red}{3},4]$ or $[1,2,4,\\color{red}{3}]$.\n\nThere is also an array $b$ of length $m$. The slide show is considered good if it is possible to make member $b_i$ present slide $i$ for all $i$ from $1$ to $m$ under these constraints.\n\nHowever, your annoying boss wants to make $q$ updates to the array $b$. In the $i$-th update, he will choose a slide $s_i$ and a member $t_i$ and set $b_{s_i} := t_i$. Note that these updates are persistent, that is changes made to the array $b$ will apply when processing future updates.\n\nFor each of the $q+1$ states of array $b$, the initial state and after each of the $q$ updates, determine if the slideshow is good.\n\nInput Format:\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains three integers $n$, $m$ and $q$ ($1 \\le n, m \\le 2 \\cdot 10^5$; $q=0$) \u2014 the number of members, the number of sections and the number of updates.\n\nThe second line of each test case contains $n$ integers $a_1,a_2,\\ldots,a_n$ ($1 \\le a_i \\le n$) \u2014 the initial order of the members from front to back. It is guaranteed that each integer from $1$ to $n$ appears exactly once in $a$.\n\nThe third line of each test case contains $m$ integers $b_1, b_2, \\ldots, b_m$ ($1 \\le b_i \\le n$) \u2014 the members who should present each section.\n\nIt is guaranteed that the sum of $n$ and the sum of $m$ over all test cases do not exceed $2 \\cdot 10^5$ respectively.\n\nOutput Format:\nFor each test case, output $q+1$ lines corresponding to the $q+1$ states of the array $b$. Output \"YA\" if the slide show is good, and \"TIDAK\" otherwise.\n\nYou can output the answer in any case (upper or lower). For example, the strings \"yA\", \"Ya\", \"ya\", and \"YA\" will be recognized as positive responses.\n\nTags:\n['constructive algorithms', 'greedy']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "3\n4 2 0\n1 2 3 4\n1 1\n3 6 0\n1 2 3\n1 1 2 3 3 2\n4 6 0\n3 1 4 2\n3 1 1 2 3 4",
                "output": "YA\nYA\nTIDAK"
            }
        ]
    },
    {
        "problem": "\nThis is the hard version of the problem. In the two versions, the constraints on $q$ and the time limit are different. In this version, $0 \\leq q \\leq 2 \\cdot 10^5$. You can make hacks only if all the versions of the problem are solved.\n\nA team consisting of $n$ members, numbered from $1$ to $n$, is set to present a slide show at a large meeting. The slide show contains $m$ slides.\n\nThere is an array $a$ of length $n$. Initially, the members are standing in a line in the order of $a_1, a_2, \\ldots, a_n$ from front to back. The slide show will be presented in order from slide $1$ to slide $m$. Each section will be presented by the member at the front of the line. After each slide is presented, you can move the member at the front of the line to any position in the lineup (without changing the order of the rest of the members). For example, suppose the line of members is $[\\color{red}{3},1,2,4]$. After member $3$ presents the current slide, you can change the line of members into either $[\\color{red}{3},1,2,4]$, $[1,\\color{red}{3},2,4]$, $[1,2,\\color{red}{3},4]$ or $[1,2,4,\\color{red}{3}]$.\n\nThere is also an array $b$ of length $m$. The slide show is considered good if it is possible to make member $b_i$ present slide $i$ for all $i$ from $1$ to $m$ under these constraints.\n\nHowever, your annoying boss wants to make $q$ updates to the array $b$. In the $i$-th update, he will choose a slide $s_i$ and a member $t_i$ and set $b_{s_i} := t_i$. Note that these updates are persistent, that is changes made to the array $b$ will apply when processing future updates.\n\nFor each of the $q+1$ states of array $b$, the initial state and after each of the $q$ updates, determine if the slideshow is good.\n\nInput Format:\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains three integers $n$, $m$ and $q$ ($1 \\le n, m \\le 2 \\cdot 10^5$; $0 \\leq q \\leq 2 \\cdot 10^5$) \u2014 the number of members and the number of sections.\n\nThe second line of each test case contains $n$ integers $a_1,a_2,\\ldots,a_n$ ($1 \\le a_i \\le n$) \u2014 the initial order of the members from front to back. It is guaranteed that each integer from $1$ to $n$ appears exactly once in $a$.\n\nThe third line of each test case contains $m$ integers $b_1, b_2, \\ldots, b_m$ ($1 \\le b_i \\le n$) \u2014 the members who should present each section.\n\nEach of the next $q$ lines contains two integers $s_i$ and $t_i$ ($1 \\le s_i \\le m$, $1 \\le t_i \\le n$) \u2014 parameters of an update.\n\nIt is guaranteed that the sum of $n$, the sum of $m$ and the sum of $q$ over all test cases do not exceed $2 \\cdot 10^5$ respectively.\n\nOutput Format:\nFor each test case, output $q+1$ lines corresponding to the $q+1$ states of the array $b$. Output \"YA\" if the slide show is good, and \"TIDAK\" otherwise.\n\nYou can output the answer in any case (upper or lower). For example, the strings \"yA\", \"Ya\", \"ya\", and \"YA\" will be recognized as positive responses.\n\nTags:\n['constructive algorithms', 'data structures', 'greedy', 'implementation', 'sortings']\n\nTime Limit: 5000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "3\n4 2 2\n1 2 3 4\n1 1\n1 2\n1 1\n3 6 2\n1 2 3\n1 1 2 3 3 2\n3 3\n2 2\n4 6 2\n3 1 4 2\n3 1 1 2 3 4\n3 4\n4 2",
                "output": "YA\nTIDAK\nYA\nYA\nTIDAK\nYA\nTIDAK\nYA\nYA"
            }
        ]
    },
    {
        "problem": "\nPak Chanek has a friend who runs a drink stall in a canteen. His friend will sell drinks for $n$ days, numbered from day $1$ to day $n$. There are also $m$ types of drinks, numbered from $1$ to $m$.\n\nThe profit gained from selling a drink on a particular day can vary. On day $i$, the projected profit from selling drink of type $j$ is $A_{i, j}$. Note that $A_{i, j}$ can be negative, meaning that selling the drink would actually incur a loss.\n\nPak Chanek wants to help his friend plan the sales over the $n$ days. On day $i$, Pak Chanek must choose to sell at least one type of drink. Furthermore, the types of drinks sold on a single day must form a subarray. In other words, in each day, Pak Chanek will select $i$ and $j$ such that $1 \\leq i \\leq j \\leq m$. Then all types of drinks between $i$ and $j$ (inclusive) will be sold.\n\nHowever, to ensure that customers from the previous day keep returning, the selection of drink types sold on day $i$ ($i>1$) must meet the following conditions:\n\n  * At least one drink type sold on day $i$ must also have been sold on day $i-1$.    * At least one drink type sold on day $i$ must not have been sold on day $i-1$. \n\nThe daily profit is the sum of the profits from all drink types sold on that day. The total profit from the sales plan is the sum of the profits over $n$ days. What is the maximum total profit that can be achieved if Pak Chanek plans the sales optimally?\n\nInput Format:\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 1000$). The description of the test cases follows.\n\nThe first line of each test case contains two integers $n$ and $m$ ($1 \\leq n \\leq 2 \\cdot 10^5$; $3 \\leq m \\leq 2 \\cdot 10^5$; $n \\cdot m \\leq 2 \\cdot 10^5$) \u2014 the number of rows and columns in a grid.\n\nThe next $n$ lines of each test case contain $m$ integers each, where the $i$-th line contains the integers $A_{i,1} A_{i,2}, \\ldots, A_{i,m}$ ($-10^9 \\leq A_{i,j} \\leq 10^9$) \u2014 project profits of each drink type on the $i$-th day.\n\nIt is guaranteed that the sum of $n \\cdot m$ over all test cases does not exceed $2 \\cdot 10^5$.\n\nOutput Format:\nFor each test case, output a single integer: the maximum profit that Pak Chanek can achieve.\n\nTags:\n['dp', 'greedy', 'implementation']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "1\n3 6\n79 20 49 5 -1000 500\n-105 9 109 24 -98 -499\n14 47 12 39 23 50",
                "output": "475"
            }
        ]
    },
    {
        "problem": "\nThis is the easy version of the problem. In the three versions, the constraints on $n$ and $m$ are different. You can make hacks only if all the versions of the problem are solved.\n\nPak Chanek is setting up internet connections for the village of Khuntien. The village can be represented as a connected simple graph with $n$ houses and $m$ internet cables connecting house $u_i$ and house $v_i$, each with a latency of $w_i$.\n\nThere are $p$ houses that require internet. Pak Chanek can install servers in at most $k$ of the houses. The houses that need internet will then be connected to one of the servers. However, since each cable has its latency, the latency experienced by house $s_i$ requiring internet will be the maximum latency of the cables between that house and the server it is connected to.\n\nFor each $k = 1,2,\\ldots,n$, help Pak Chanek determine the minimum total latency that can be achieved for all the houses requiring internet.\n\nInput Format:\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 100$). The description of the test cases follows.\n\nThe first line of each test case contains three integers $n$, $m$, $p$ ($2 \\le n \\le 400$; $n-1 \\le m \\le 400$; $1 \\le p \\le n$) \u2014 the number of houses, the number of cables and the number of houses that need internet.\n\nThe second line of each test case contains $p$ integers $s_1, s_2, \\ldots, s_p$ ($1 \\le s_i \\le n$) \u2014 the houses that need internet. It is guaranteed that all elements of $s$ are distinct.\n\nThe $i$-th of the next $m$ lines of each test case contains three integers $u_i$, $v_i$, and $w_i$ ($1 \\le u_i < v_i \\le n$; $1 \\le w_i \\le 10^9$) \u2014 the internet cable connecting house $u_i$ and house $v_i$ with latency of $w_i$. It is guaranteed that the given edges form a connected simple graph.\n\nIt is guaranteed that the sum of $n^3$ and the sum of $m^3$ do not exceed $10^8$.\n\nOutput Format:\nFor each test case, output $n$ integers: the minimum total latency that can be achieved for all the houses requiring internet for each $k = 1,2,\\ldots,n$.\n\nTags:\n['brute force', 'data structures', 'dfs and similar', 'dp', 'dsu', 'fft', 'graphs', 'greedy', 'implementation', 'math', 'trees']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "2\n9 8 5\n2 5 6 8 9\n1 2 1\n1 3 2\n3 4 10\n4 5 3\n4 6 5\n1 7 10\n7 8 4\n7 9 2\n3 3 2\n3 1\n1 2 1\n2 3 3\n1 3 2",
                "output": "34 19 9 4 0 0 0 0 0\n2 0 0"
            }
        ]
    },
    {
        "problem": "\nThis is the hard version of the problem. In the three versions, the constraints on $n$ and $m$ are different. You can make hacks only if all the versions of the problem are solved.\n\nPak Chanek is setting up internet connections for the village of Khuntien. The village can be represented as a connected simple graph with $n$ houses and $m$ internet cables connecting house $u_i$ and house $v_i$, each with a latency of $w_i$.\n\nThere are $p$ houses that require internet. Pak Chanek can install servers in at most $k$ of the houses. The houses that need internet will then be connected to one of the servers. However, since each cable has its latency, the latency experienced by house $s_i$ requiring internet will be the maximum latency of the cables between that house and the server it is connected to.\n\nFor each $k = 1,2,\\ldots,n$, help Pak Chanek determine the minimum total latency that can be achieved for all the houses requiring internet.\n\nInput Format:\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 2000$). The description of the test cases follows.\n\nThe first line of each test case contains three integers $n$, $m$, $p$ ($2 \\le n \\le 5000$; $n-1 \\le m \\le 5000$; $1 \\le p \\le n$) \u2014 the number of houses, the number of cables, and the number of houses that need internet.\n\nThe second line of each test case contains $p$ integers $s_1, s_2, \\ldots, s_p$ ($1 \\le s_i \\le n$) \u2014 the houses that need internet. It is guaranteed that all elements of $s$ are distinct.\n\nThe $i$-th of the next $m$ lines of each test case contains three integers $u_i$, $v_i$, and $w_i$ ($1 \\le u_i < v_i \\le n$; $1 \\le w_i \\le 10^9$) \u2014 the internet cable connecting house $u_i$ and house $v_i$ with latency of $w_i$. It is guaranteed that the given edges form a connected simple graph.\n\nIt is guaranteed that the sum of $n$ and the sum of $m$ do not exceed $5000$.\n\nOutput Format:\nFor each test case, output $n$ integers: the minimum total latency that can be achieved for all the houses requiring internet for each $k = 1,2,\\ldots,n$.\n\nTags:\n['data structures', 'dp', 'dsu', 'graphs', 'math', 'trees']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "2\n9 8 5\n2 5 6 8 9\n1 2 1\n1 3 2\n3 4 10\n4 5 3\n4 6 5\n1 7 10\n7 8 4\n7 9 2\n3 3 2\n3 1\n1 2 1\n2 3 3\n1 3 2",
                "output": "34 19 9 4 0 0 0 0 0\n2 0 0"
            }
        ]
    },
    {
        "problem": "\nThis is the extreme version of the problem. In the three versions, the constraints on $n$ and $m$ are different. You can make hacks only if all the versions of the problem are solved.\n\nPak Chanek is setting up internet connections for the village of Khuntien. The village can be represented as a connected simple graph with $n$ houses and $m$ internet cables connecting house $u_i$ and house $v_i$, each with a latency of $w_i$.\n\nThere are $p$ houses that require internet. Pak Chanek can install servers in at most $k$ of the houses. The houses that need internet will then be connected to one of the servers. However, since each cable has its latency, the latency experienced by house $s_i$ requiring internet will be the maximum latency of the cables between that house and the server it is connected to.\n\nFor each $k = 1,2,\\ldots,n$, help Pak Chanek determine the minimum total latency that can be achieved for all the houses requiring internet.\n\nInput Format:\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains 3 integers $n$, $m$, $p$ ($2 \\le n \\le 2 \\cdot 10^5$; $n-1 \\le m \\le 2 \\cdot 10^5$; $1 \\le p \\le n$) \u2014 the number of houses, the number of cables, and the number of houses that need internet.\n\nThe second line of each test case contains $p$ integers $s_1, s_2, \\ldots, s_p$ ($1 \\le s_i \\le n$) \u2014 the houses that need internet. It is guaranteed that all elements of $s$ are distinct.\n\nThe $i$-th of the next $m$ lines of each test case contains three integers $u_i$, $v_i$, and $w_i$ ($1 \\le u_i < v_i \\le n$; $1 \\le w_i \\le 10^9$) \u2014 the internet cable connecting house $u_i$ and house $v_i$ with latency of $w_i$. It is guaranteed that the given edges form a connected simple graph.\n\nIt is guaranteed that the sum of $n$ and the sum of $m$ do not exceed $2 \\cdot 10^5$.\n\nOutput Format:\nFor each test case, output $n$ integers: the minimum total latency that can be achieved for all the houses requiring internet for each $k = 1,2,\\ldots,n$.\n\nTags:\n['data structures', 'dfs and similar', 'dp', 'dsu', 'graphs', 'greedy', 'math', 'trees']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "2\n9 8 5\n2 5 6 8 9\n1 2 1\n1 3 2\n3 4 10\n4 5 3\n4 6 5\n1 7 10\n7 8 4\n7 9 2\n3 3 2\n3 1\n1 2 1\n2 3 3\n1 3 2",
                "output": "34 19 9 4 0 0 0 0 0\n2 0 0"
            }
        ]
    },
    {
        "problem": "\nYa vamos llegando a P\u00e9eeenjamoo \u266b\u266b\u266b\n\nThere are $n$ families travelling to P\u00e9njamo to witness Mexico's largest- ever \"walking a chicken on a leash\" marathon. The $i$-th family has $a_i$ family members. All families will travel using a single bus consisting of $r$ rows with $2$ seats each.\n\nA person is considered happy if:\n\n  * Another family member is seated in the same row as them, or    * They are sitting alone in their row (with an empty seat next to them). \n\nDetermine the maximum number of happy people in an optimal seating arrangement. Note that everyone must be seated in the bus.\n\nIt is guaranteed that all family members will fit on the bus. Formally, it is guaranteed that $\\displaystyle\\sum_{i=1}^{n}a_i \\le 2r$.\n\nInput Format:\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 1000$). The description of the test cases follows.\n\nThe first line of each test case contains two integers $n$ and $r$ ($1 \\le n \\le 100$; $1 \\le r \\le 500$) \u2014 the number of families and the number of rows in the bus.\n\nThe second line contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\le a_i \\le 10$) \u2014 the number of family members in each family.\n\nOutput Format:\nFor each test case, output the maximum number of happy people in an optimal seating arrangement.\n\nTags:\n['constructive algorithms', 'greedy', 'implementation', 'math']\n\nTime Limit: 1000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "4\n3 3\n2 3 1\n3 3\n2 2 2\n4 5\n1 1 2 2\n4 5\n3 1 1 3",
                "output": "4\n6\n6\n6"
            }
        ]
    },
    {
        "problem": "\nKarel is a salesman in a car dealership. The dealership has $n$ different models of cars. There are $a_i$ cars of the $i$-th model. Karel is an excellent salesperson and can convince customers to buy up to $x$ cars (of Karel's choice), as long as the cars are from different models.      Determine the minimum number of customers Karel has to bring in to sell all the cars.\n\nInput Format:\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains two integers $n$ and $x$ ($1 \\le n \\le 5 \\cdot 10^5$; $1 \\le x \\le 10$) \u2014 the number of different models of cars and the maximum number of cars Karel can convince a customer to buy.\n\nThe second line contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\le a_i \\le 10^9$) \u2014 the number of cars of each model.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $5 \\cdot 10^5$.\n\nOutput Format:\nFor each test case, output the minimum possible number of customers needed to sell all the cars.\n\nTags:\n['binary search', 'greedy', 'math']\n\nTime Limit: 1000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "4\n3 2\n3 1 2\n3 3\n2 1 3\n5 3\n2 2 1 9 2\n7 4\n2 5 3 3 5 2 5",
                "output": "3\n3\n9\n7"
            }
        ]
    },
    {
        "problem": "\nWe all steal a little bit. But I have only one hand, while my adversaries have two.\n\n\u00c1lvaro Obreg\u00f3n\n\n\u00c1lvaro and Jos\u00e9 are the only candidates running for the presidency of Tepito, a rectangular grid of $2$ rows and $n$ columns, where each cell represents a house. It is guaranteed that $n$ is a multiple of $3$.\n\nUnder the voting system of Tepito, the grid will be split into districts, which consist of any $3$ houses that are connected$^{\\text{\u2217}}$. Each house will belong to exactly one district.\n\nEach district will cast a single vote. The district will vote for \u00c1lvaro or Jos\u00e9 respectively if at least $2$ houses in that district select them. Therefore, a total of $\\frac{2n}{3}$ votes will be cast.\n\nAs \u00c1lvaro is the current president, he knows exactly which candidate each house will select. If \u00c1lvaro divides the houses into districts optimally, determine the maximum number of votes he can get.\n\n$^{\\text{\u2217}}$A set of cells is connected if there is a path between any $2$ cells that requires moving only up, down, left and right through cells in the set.\n\nInput Format:\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains one integer $n$ ($3 \\le n \\le 10^5$; $n$ is a multiple of $3$) \u2014 the number of columns of Tepito.\n\nThe following two lines each contain a string of length $n$. The $i$-th line contains the string $s_i$, consisting of the characters $\\texttt{A}$ and $\\texttt{J}$. If $s_{i,j}=\\texttt{A}$, the house in the $i$-th row and $j$-th column will select \u00c1lvaro. Otherwise if $s_{i,j}=\\texttt{J}$, the house will select Jos\u00e9.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $10^5$.\n\nOutput Format:\nFor each test case, output a single integer \u2014 the maximum number of districts \u00c1lvaro can win by optimally dividing the houses into districts.\n\nTags:\n['dp', 'implementation']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "4\n3\nAAA\nAJJ\n6\nJAJAJJ\nJJAJAJ\n6\nAJJJAJ\nAJJAAA\n9\nAJJJJAJAJ\nJAAJJJJJA",
                "output": "2\n2\n3\n2"
            }
        ]
    },
    {
        "problem": "\nThis is the easy version of the problem. In this version, you can ask at most $n+69$ questions. You can make hacks only if both versions of the problem are solved.\n\nThis is an interactive problem.\n\nIt is a tradition in Mexico's national IOI trainings to play the game \"Asesino\", which is similar to \"Among Us\" or \"Mafia\".\n\nToday, $n$ players, numbered from $1$ to $n$, will play \"Asesino\" with the following three roles:\n\n  * Knight: a Knight is someone who always tells the truth.    * Knave: a Knave is someone who always lies.    * Impostor: an Impostor is someone everybody thinks is a Knight, but is secretly a Knave. \n\nEach player will be assigned a role in the game. There will be exactly one Impostor but there can be any (possible zero) number of Knights and Knaves.\n\nAs the game moderator, you have accidentally forgotten the roles of everyone, but you need to determine the player who is the Impostor.\n\nTo determine the Impostor, you will ask some questions. In each question, you will pick two players $i$ and $j$ ($1 \\leq i, j \\leq n$; $i \\neq j$) and ask if player $i$ thinks that player $j$ is a Knight. The results of the question is shown in the table below.\n\n| Knight| Knave| Impostor   ---|---|---|---   Knight| Yes| No| Yes   Knave| No| Yes| No   Impostor| No| Yes| \u2014   The response of the cell in row $a$ and column $b$ is the result of asking a question when $i$ has role $a$ and $j$ has row $b$. For example, the \"Yes\" in the top right cell belongs to row \"Knight\" and column \"Impostor\", so it is the response when $i$ is a Knight and $j$ is an Impostor.\n\nFind the Impostor in at most $n + 69$ questions.\n\nNote: the grader is adaptive: the roles of the players are not fixed in the beginning and may change depending on your questions. However, it is guaranteed that there exists an assignment of roles that is consistent with all previously asked questions under the constraints of this problem.\n\nInput Format:\nThe first line of input contains a single integer $t$ ($1 \\leq t \\leq 10^3$) \u2014 the number of test cases. The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($3 \\le n \\le 10^5$) \u2014 the number of people playing the game.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $10^5$.\n\nOutput Format:\n\n\nTags:\n['binary search', 'brute force', 'constructive algorithms', 'implementation', 'interactive']\n\nTime Limit: 2500 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "2\n7\n\n1\n\n0\n\n0\n\n1\n\n1\n\n0\n\n0\n\n1\n\n4\n\n0\n\n1\n\n1\n\n1",
                "output": "? 1 3\n\n? 7 6\n\n? 2 5\n\n? 6 2\n\n? 4 5\n\n? 4 6\n\n? 1 4\n\n? 2 4\n\n! 4\n\n? 1 2\n\n? 2 3\n\n? 3 4\n\n? 4 1\n\n! 3"
            }
        ]
    },
    {
        "problem": "\nThis is the hard version of the problem. In this version, you must use the minimum number of queries possible. You can make hacks only if both versions of the problem are solved.\n\nThis is an interactive problem.\n\nIt is a tradition in Mexico's national IOI trainings to play the game \"Asesino\", which is similar to \"Among Us\" or \"Mafia\".\n\nToday, $n$ players, numbered from $1$ to $n$, will play \"Asesino\" with the following three roles:\n\n  * Knight: a Knight is someone who always tells the truth.    * Knave: a Knave is someone who always lies.    * Impostor: an Impostor is someone everybody thinks is a Knight, but is secretly a Knave. \n\nEach player will be assigned a role in the game. There will be exactly one Impostor but there can be any (possible zero) number of Knights and Knaves.\n\nAs the game moderator, you have accidentally forgotten the roles of everyone, but you need to determine the player who is the Impostor.\n\nTo determine the Impostor, you will ask some questions. In each question, you will pick two players $i$ and $j$ ($1 \\leq i, j \\leq n$; $i \\neq j$) and ask if player $i$ thinks that player $j$ is a Knight. The results of the question is shown in the table below.\n\n| Knight| Knave| Impostor   ---|---|---|---   Knight| Yes| No| Yes   Knave| No| Yes| No   Impostor| No| Yes| \u2014   The response of the cell in row $a$ and column $b$ is the result of asking a question when $i$ has role $a$ and $j$ has row $b$. For example, the \"Yes\" in the top right cell belongs to row \"Knight\" and column \"Impostor\", so it is the response when $i$ is a Knight and $j$ is an Impostor.\n\nFind the Impostor in the minimum number of queries possible. That is, let $f(n)$ be the minimum integer such that for $n$ players, there exists a strategy that can determine the Impostor using at most $f(n)$ questions. Then, you should use at most $f(n)$ questions to determine the Impostor.\n\nNote: the grader is adaptive: the roles of the players are not fixed in the beginning and may change depending on your questions. However, it is guaranteed that there exists an assignment of roles that is consistent with all previously asked questions under the constraints of this problem.\n\nInput Format:\nThe first line of input contains a single integer $t$ ($1 \\leq t \\leq 10^3$) \u2014 the number of test cases. The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($3 \\le n \\le 10^5$) \u2014 the number of people playing the game.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $10^5$.\n\nOutput Format:\n\n\nTags:\n['constructive algorithms', 'dp', 'interactive']\n\nTime Limit: 2500 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "2\n7\n\n1\n\n0\n\n0\n\n1\n\n1\n\n0\n\n0\n\n4\n\n0\n\n1\n\n1\n\n1",
                "output": "? 1 3\n\n? 7 6\n\n? 2 5\n\n? 6 2\n\n? 4 5\n\n? 4 6\n\n? 1 4\n\n! 4\n\n? 1 2\n\n? 2 3\n\n? 3 4\n\n? 4 1\n\n! 3"
            }
        ]
    },
    {
        "problem": "\nThis is the easy version of the problem. In this version, it is guaranteed that $q = 0$. You can make hacks only if both versions of the problem are solved.\n\nAn integer grid $A$ with $p$ rows and $q$ columns is called beautiful if:\n\n  * All elements of the grid are integers between $0$ and $2^{30}-1$, and    * For any subgrid, the XOR of the values at the corners is equal to $0$. Formally, for any four integers $i_1$, $i_2$, $j_1$, $j_2$ ($1 \\le i_1 < i_2 \\le p$; $1 \\le j_1 < j_2 \\le q$), $A_{i_1, j_1} \\oplus A_{i_1, j_2} \\oplus A_{i_2, j_1} \\oplus A_{i_2, j_2} = 0$, where $\\oplus$ denotes the [bitwise XOR operation](https://en.wikipedia.org/wiki/Bitwise_operation#XOR). \n\nThere is a partially filled integer grid $G$ with $n$ rows and $m$ columns where only $k$ cells are filled. Polycarp wants to know how many ways he can assign integers to the unfilled cells so that the grid is beautiful.\n\nHowever, Monocarp thinks that this problem is too easy. Therefore, he will perform $q$ updates on the grid. In each update, he will choose an unfilled cell and assign an integer to it. Note that these updates are persistent. That is, changes made to the grid will apply when processing future updates.\n\nFor each of the $q + 1$ states of the grid, the initial state and after each of the $q$ queries, determine the number of ways Polycarp can assign integers to the unfilled cells so that the grid is beautiful. Since this number can be very large, you are only required to output their values modulo $10^9+7$.\n\nInput Format:\nThe first line contains $t$ ($1 \\le t \\le 10^4$) \u2014 the number of test cases.\n\nThe first line of each test case contains four integers $n$, $m$, $k$ and $q$ ($2 \\le n, m \\le 10^5$; $0 \\le k \\le 10^5$; $q = 0$) \u2014 the number of rows, the number of columns, the number of fixed cells, and the number of updates.\n\nThe following $k$ lines contain three integers $r$, $c$ and $v$ ($1 \\le r \\le n, 1 \\le c \\le m$; $0 \\le v < 2^{30}$) \u2014 indicating that $G_{r, c}$ is assigned the integer $v$.\n\nThe following $q$ lines contain three integers $r$, $c$ and $v$ ($1 \\le r \\le n, 1 \\le c \\le m$; $0 \\le v < 2^{30}$) \u2014 indicating that $G_{r, c}$ is assigned the integer $v$.\n\nIt is guaranteed that the pairs $(r,c)$ over all assignments are distinct.\n\nIt is guaranteed that the sum of $n$, $m$, $k$ and $q$ over all test cases does not exceed $10^5$ respectively.\n\nOutput Format:\nFor each test case, output $q + 1$ lines. The $i$-th line of output should contain the answer of the $i$-th state of the grid modulo $10^9 + 7$.\n\nTags:\n['2-sat', 'binary search', 'combinatorics', 'constructive algorithms', 'dfs and similar', 'dsu', 'graphs']\n\nTime Limit: 2000 ms\nMemory Limit: 512 MB\n",
        "tests": [
            {
                "input": "2\n3 3 8 0\n2 1 6\n3 2 12\n1 2 6\n2 2 0\n1 3 10\n1 1 0\n2 3 12\n3 1 10\n2 5 2 0\n1 1 10\n1 2 30",
                "output": "1\n489373567"
            }
        ]
    },
    {
        "problem": "\nThis is the hard version of the problem. In this version, it is guaranteed that $q \\leq 10^5$. You can make hacks only if both versions of the problem are solved.\n\nAn integer grid $A$ with $p$ rows and $q$ columns is called beautiful if:\n\n  * All elements of the grid are integers between $0$ and $2^{30}-1$, and    * For any subgrid, the XOR of the values at the corners is equal to $0$. Formally, for any four integers $i_1$, $i_2$, $j_1$, $j_2$ ($1 \\le i_1 < i_2 \\le p$; $1 \\le j_1 < j_2 \\le q$), $A_{i_1, j_1} \\oplus A_{i_1, j_2} \\oplus A_{i_2, j_1} \\oplus A_{i_2, j_2} = 0$, where $\\oplus$ denotes the [bitwise XOR operation](https://en.wikipedia.org/wiki/Bitwise_operation#XOR). \n\nThere is a partially filled integer grid $G$ with $n$ rows and $m$ columns where only $k$ cells are filled. Polycarp wants to know how many ways he can assign integers to the unfilled cells so that the grid is beautiful.\n\nHowever, Monocarp thinks that this problem is too easy. Therefore, he will perform $q$ updates on the grid. In each update, he will choose an unfilled cell and assign an integer to it. Note that these updates are persistent. That is, changes made to the grid will apply when processing future updates.\n\nFor each of the $q + 1$ states of the grid, the initial state and after each of the $q$ queries, determine the number of ways Polycarp can assign integers to the unfilled cells so that the grid is beautiful. Since this number can be very large, you are only required to output their values modulo $10^9+7$.\n\nInput Format:\nThe first line contains $t$ ($1 \\le t \\le 10^4$) \u2014 the number of test cases.\n\nThe first line of each test case contains four integers $n$, $m$, $k$ and $q$ ($2 \\le n, m \\le 10^5$; $0 \\le k, q \\leq 10^5$) \u2014 the number of rows, the number of columns, the number of fixed cells, and the number of updates.\n\nThe following $k$ lines contain three integers $r$, $c$ and $v$ ($1 \\le r \\le n, 1 \\le c \\le m$; $0 \\le v < 2^{30}$) indicating that $G_{r, c}$ is assigned the integer $v$.\n\nThe following $q$ lines contain three integers $r$, $c$ and $v$ ($1 \\le r \\le n, 1 \\le c \\le m$; $0 \\le v < 2^{30}$) indicating that $G_{r, c}$ is assigned the integer $v$.\n\nIt is guaranteed that the pairs $(r,c)$ over all assignments are distinct.\n\nIt is guaranteed that the sum of $n$, $m$, $k$ and $q$ over all test cases does not exceed $10^5$ respectively.\n\nOutput Format:\nFor each test case, output $q + 1$ lines. The $i$-th line of output should contain the answer of the $i$-th state of the grid modulo $10^9 + 7$.\n\nTags:\n['binary search', 'combinatorics', 'data structures', 'dsu', 'graphs']\n\nTime Limit: 2000 ms\nMemory Limit: 512 MB\n",
        "tests": [
            {
                "input": "3\n3 3 8 1\n2 1 6\n3 2 12\n1 2 6\n2 2 0\n1 3 10\n1 1 0\n2 3 12\n3 1 10\n3 3 1\n2 5 2 0\n1 1 10\n1 2 30\n2 5 0 2\n1 1 10\n1 2 30",
                "output": "1\n0\n489373567\n651321892\n769740174\n489373567"
            }
        ]
    },
    {
        "problem": "\nYou are given $n$ arrays $a_1$, $\\ldots$, $a_n$. The length of each array is two. Thus, $a_i = [a_{i, 1}, a_{i, 2}]$. You need to concatenate the arrays into a single array of length $2n$ such that the number of inversions$^{\\dagger}$ in the resulting array is minimized. Note that you do not need to count the actual number of inversions.\n\nMore formally, you need to choose a permutation$^{\\ddagger}$ $p$ of length $n$, so that the array $b = [a_{p_1,1}, a_{p_1,2}, a_{p_2, 1}, a_{p_2, 2}, \\ldots, a_{p_n,1}, a_{p_n,2}]$ contains as few inversions as possible.\n\n$^{\\dagger}$The number of inversions in an array $c$ is the number of pairs of indices $i$ and $j$ such that $i < j$ and $c_i > c_j$.\n\n$^{\\ddagger}$A permutation of length $n$ is an array consisting of $n$ distinct integers from $1$ to $n$ in arbitrary order. For example, $[2,3,1,5,4]$ is a permutation, but $[1,2,2]$ is not a permutation ($2$ appears twice in the array), and $[1,3,4]$ is also not a permutation ($n=3$ but there is $4$ in the array).\n\nInput Format:\nEach test consists of multiple test cases. The first line contains a single integer $t$ ($1 \\le t \\le 10^4$) \u2014 the number of test cases. The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($1 \\le n \\le 10^5$) \u2014 the number of arrays.\n\nEach of the following $n$ lines contains two integers $a_{i,1}$ and $a_{i,2}$ ($1 \\le a_{i,j} \\le 10^9$) \u2014 the elements of the $i$-th array.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $10^5$.\n\nOutput Format:\nFor each test case, output $2n$ integers \u2014 the elements of the array you obtained. If there are multiple solutions, output any of them.\n\nTags:\n['constructive algorithms', 'greedy', 'math', 'sortings']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "4\n2\n1 4\n2 3\n3\n3 2\n4 3\n2 1\n5\n5 10\n2 3\n9 6\n4 1\n8 7\n1\n10 20",
                "output": "2 3 1 4\n2 1 3 2 4 3\n4 1 2 3 5 10 8 7 9 6\n10 20"
            }
        ]
    },
    {
        "problem": "\nIt is already the year $3024$, ideas for problems have long run out, and the olympiad now takes place in a modified individual format. The olympiad consists of $n$ problems, numbered from $1$ to $n$. The $i$-th problem has its own score $a_i$ and a certain parameter $b_i$ ($1 \\le b_i \\le n$).\n\nInitially, the testing system gives the participant the first problem. When the participant is given the $i$-th problem, they have two options:\n\n  * They can submit the problem and receive $a_i$ points;    * They can skip the problem, in which case they will never be able to submit it. \n\nThen, the testing system selects the next problem for the participant from problems with indices $j$, such that:\n\n  * If he submitted the $i$-th problem, it looks at problems with indices $j < i$;    * If he skipped the $i$-th problem, it looks at problems with indices $j \\leq b_i$. \n\nAmong these problems, it selects the problem with the maximum index that it has not previously given to the participant (he has neither submitted nor skipped it before). If there is no such problem, then the competition for the participant ends, and their result is equal to the sum of points for all submitted problems. In particular, if the participant submits the first problem, then the competition for them ends. Note that the participant receives each problem at most once.\n\nProkhor has prepared thoroughly for the olympiad, and now he can submit any problem. Help him determine the maximum number of points he can achieve.\n\nInput Format:\nEach test consists of multiple test cases. The first line contains a single integer $t$ ($1 \\leq t \\leq 10^5$) \u2014 the number of test cases. The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($1 \\leq n \\leq 4 \\cdot 10^5$) \u2014 the number of problems in the olympiad.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\leq a_i \\leq 10^9$) \u2014 the scores of the problems.\n\nThe third line of each test case contains $n$ integers $b_1, b_2, \\ldots, b_n$ ($1 \\leq b_i \\leq n$) \u2014 the parameters of the problems.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $4 \\cdot 10^5$.\n\nOutput Format:\nFor each test case, output a single integer \u2014 the maximum number of points that Prokhor can achieve.\n\nTags:\n['binary search', 'dp', 'graphs', 'shortest paths']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "4\n2\n15 16\n2 1\n5\n10 10 100 100 1000\n3 4 1 1 1\n3\n100 49 50\n3 2 2\n4\n100 200 300 1000\n2 3 4 1",
                "output": "16\n200\n100\n1000"
            }
        ]
    },
    {
        "problem": "\nYou are given two strongly connected$^{\\dagger}$ directed graphs, each with exactly $n$ vertices, but possibly different numbers of edges. Upon closer inspection, you noticed an important feature \u2014 the length of any cycle in these graphs is divisible by $k$.\n\nEach of the $2n$ vertices belongs to exactly one of two types: incoming or outgoing. For each vertex, its type is known to you.\n\nYou need to determine whether it is possible to draw exactly $n$ directed edges between the source graphs such that the following four conditions are met:\n\n  * The ends of any added edge lie in different graphs.    * From each outgoing vertex, exactly one added edge originates.    * Into each incoming vertex, exactly one added edge enters.    * In the resulting graph, the length of any cycle is divisible by $k$. \n\n$^{\\dagger}$A strongly connected graph is a graph in which there is a path from every vertex to every other vertex.\n\nInput Format:\nEach test consists of multiple test cases. The first line contains a single integer $t$ ($1 \\le t \\le 10^4$) \u2014 the number of test cases. The description of the test cases follows.\n\nThe first line of each test case contains two integers $n$ and $k$ ($2 \\le k \\le n \\le 2 \\cdot 10^5$) \u2014 the number of vertices in each graph and the value by which the length of each cycle is divisible.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($a_i \\in \\\\{0, 1\\\\}$). If $a_i = 0$, then vertex $i$ of the first graph is incoming. If $a_i = 1$, then vertex $i$ of the first graph is outgoing.\n\nThe third line of each test case contains a single integer $m_1$ ($1 \\le m_1 \\le 5 \\cdot 10^5$) \u2014 the number of edges in the first graph.\n\nThe next $m_1$ lines contain descriptions of the edges of the first graph. The $i$-th of them contains two integers $v_i$ and $u_i$ ($1 \\le v_i, u_i \\le n$) \u2014 an edge in the first graph leading from vertex $v_i$ to vertex $u_i$.\n\nNext, in the same format, follows the description of the second graph.\n\nThe next line contains $n$ integers $b_1, b_2, \\ldots, b_n$ ($b_i \\in \\\\{0, 1\\\\}$). If $b_i = 0$, then vertex $i$ of the second graph is incoming. If $b_i = 1$, then vertex $i$ of the second graph is outgoing.\n\nThe next line contains a single integer $m_2$ ($1 \\le m_2 \\le 5 \\cdot 10^5$) \u2014 the number of edges in the second graph.\n\nThe next $m_2$ lines contain descriptions of the edges of the second graph. The $i$-th of them contains two integers $v_i$ and $u_i$ ($1 \\le v_i, u_i \\le n$) \u2014 an edge in the second graph leading from vertex $v_i$ to vertex $u_i$.\n\nIt is guaranteed that both graphs are strongly connected, and the lengths of all cycles are divisible by $k$.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$. It is guaranteed that the sum of $m_1$ and the sum of $m_2$ over all test cases does not exceed $5 \\cdot 10^5$.\n\nOutput Format:\nFor each test case, output \"YES\" (without quotes) if it is possible to draw $n$ new edges such that all conditions are met, and \"NO\" (without quotes) otherwise.\n\nYou may output the answer in any case (for example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as a positive answer).\n\nTags:\n['constructive algorithms', 'dfs and similar', 'graphs', 'greedy', 'hashing', 'implementation', 'strings']\n\nTime Limit: 3000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "3\n4 2\n1 0 0 1\n4\n1 2\n2 3\n3 4\n4 1\n1 0 0 1\n4\n1 3\n3 2\n2 4\n4 1\n3 3\n0 0 0\n3\n1 2\n2 3\n3 1\n1 1 0\n3\n1 2\n2 3\n3 1\n4 2\n1 1 1 1\n4\n1 2\n2 3\n3 4\n4 1\n0 0 0 0\n6\n1 2\n2 1\n1 3\n3 1\n1 4\n4 1",
                "output": "YES\nNO\nYES"
            }
        ]
    },
    {
        "problem": "\nRecently, you received a rare ticket to the only casino in the world where you can actually earn something, and you want to take full advantage of this opportunity.\n\nThe conditions in this casino are as follows:\n\n  * There are a total of $n$ games in the casino.    * You can play each game at most once.    * Each game is characterized by two parameters: $p_i$ ($1 \\le p_i \\le 100$) and $w_i$ \u2014 the probability of winning the game in percentage and the winnings for a win.    * If you lose in any game you decide to play, you will receive nothing at all (even for the games you won). \n\nYou need to choose a set of games in advance that you will play in such a way as to maximize the expected value of your winnings.\n\nIn this case, if you choose to play the games with indices $i_1 < i_2 < \\ldots < i_k$, you will win in all of them with a probability of $\\prod\\limits_{j=1}^k \\frac{p_{i_j}}{100}$, and in that case, your winnings will be equal to $\\sum\\limits_{j=1}^k w_{i_j}$.\n\nThat is, the expected value of your winnings will be $\\left(\\prod\\limits_{j=1}^k \\frac{p_{i_j}}{100}\\right) \\cdot \\left(\\sum\\limits_{j=1}^k w_{i_j}\\right)$.\n\nTo avoid going bankrupt, the casino owners have limited the expected value of winnings for each individual game. Thus, for all $i$ ($1 \\le i \\le n$), it holds that $w_i \\cdot p_i \\le 2 \\cdot 10^5$.\n\nYour task is to find the maximum expected value of winnings that can be obtained by choosing some set of games in the casino.\n\nInput Format:\nThe first line contains a single integer $n$ ($1 \\le n \\le 2 \\cdot 10^5$) \u2014 the number of games offered to play.\n\nThe $i$-th of the following $n$ lines contains two integers $p_i$ and $w_i$ ($1 \\leq p_i \\leq 100$, $1 \\leq w_i, p_i \\cdot w_i \\leq 2 \\cdot 10^5$) \u2014 the probability of winning and the size of the winnings in the $i$-th game.\n\nOutput Format:\nOutput a single number \u2014 the maximum expected value of winnings in the casino that can be obtained by choosing some subset of games.\n\nYour answer will be accepted if the relative or absolute error does not exceed $10^{-6}$. Formally, if $a$ is your answer and $b$ is the jury's answer, it will be accepted if $\\frac{|a-b|}{\\max(b, 1)} \\le 10^{-6}$.\n\nTags:\n['brute force', 'dp', 'greedy', 'math', 'probabilities']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "3\n80 80\n70 100\n50 200",
                "output": "112.00000000"
            },
            {
                "input": "2\n100 1\n100 1",
                "output": "2.00000000"
            },
            {
                "input": "4\n1 100\n2 1000\n2 100\n3 1",
                "output": "20.00000000"
            },
            {
                "input": "5\n34 804\n78 209\n99 191\n61 439\n90 79",
                "output": "395.20423800"
            }
        ]
    },
    {
        "problem": "\nIn the heart of an ancient kingdom grows the legendary Tree of Life \u2014 the only one of its kind and the source of magical power for the entire world. The tree consists of $n$ nodes. Each node of this tree is a magical source, connected to other such sources through magical channels (edges). In total, there are $n-1$ channels in the tree, with the $i$-th channel connecting nodes $v_i$ and $u_i$. Moreover, there exists a unique simple path through the channels between any two nodes in the tree.\n\nHowever, the magical energy flowing through these channels must be balanced; otherwise, the power of the Tree of Life may disrupt the natural order and cause catastrophic consequences. The sages of the kingdom discovered that when two magical channels converge at a single node, a dangerous \"magical resonance vibration\" occurs between them. To protect the Tree of Life and maintain its balance, it is necessary to select several paths and perform special rituals along them. A path is a sequence of distinct nodes $v_1, v_2, \\ldots, v_k$, where each pair of adjacent nodes $v_i$ and $v_{i+1}$ is connected by a channel. When the sages perform a ritual along such a path, the resonance vibration between the channels $(v_i, v_{i+1})$ and $(v_{i+1}, v_{i+2})$ is blocked for each $1 \\leq i \\leq k - 2$.\n\nThe sages' task is to select the minimum number of paths and perform rituals along them to block all resonance vibrations. This means that for every pair of channels emanating from a single node, there must exist at least one selected path that contains both of these channels.\n\nHelp the sages find the minimum number of such paths so that the magical balance of the Tree of Life is preserved, and its power continues to nourish the entire world!\n\nInput Format:\nEach test consists of multiple test cases. The first line contains a single integer $t$ ($1 \\leq t \\leq 4 \\cdot 10^4$) \u2014 the number of test cases. The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($2 \\leq n \\leq 5 \\cdot 10^5$) \u2014 the number of nodes in the Tree of Life.\n\nThe $i$-th of the following $n - 1$ lines of each test case contains two integers $v_i$ and $u_i$ ($1 \\leq v_i < u_i \\leq n$) \u2014 the channel connecting nodes $v_i$ and $u_i$.\n\nIt is guaranteed that there exists a unique simple path through the channels between any two nodes.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $5 \\cdot 10^5$.\n\nOutput Format:\nFor each test case, output a single integer \u2014 the minimum number of paths that the sages need to select to prevent a catastrophe.\n\nTags:\n['dp', 'greedy', 'trees']\n\nTime Limit: 2000 ms\nMemory Limit: 512 MB\n",
        "tests": [
            {
                "input": "5\n4\n1 2\n2 3\n3 4\n2\n1 2\n4\n1 2\n1 3\n1 4\n8\n3 7\n2 4\n1 2\n2 5\n3 6\n1 3\n3 8\n6\n2 3\n1 2\n3 6\n1 5\n1 4",
                "output": "1\n0\n3\n7\n3"
            }
        ]
    },
    {
        "problem": "\nIn a desert city with a hilly landscape, the city hall decided to level the road surface by purchasing a dump truck. The road is divided into $n$ sections, numbered from $1$ to $n$ from left to right. The height of the surface in the $i$-th section is equal to $a_i$. If the height of the $i$-th section is greater than $0$, then the dump truck must take sand from the $i$-th section of the road, and if the height of the $i$-th section is less than $0$, the dump truck must fill the pit in the $i$-th section of the road with sand. It is guaranteed that the initial heights are not equal to $0$.\n\nWhen the dump truck is in the $i$-th section of the road, it can either take away $x$ units of sand, in which case the height of the surface in the $i$-th section will decrease by $x$, or it can fill in $x$ units of sand (provided that it currently has at least $x$ units of sand in its bed), in which case the height of the surface in the $i$-th section of the road will increase by $x$.\n\nThe dump truck can start its journey from any section of the road. Moving to an adjacent section on the left or right takes $1$ minute, and the time for loading and unloading sand can be neglected. The dump truck has an infinite capacity and is initially empty.\n\nYou need to find the minimum time required for the dump truck to level the sand so that the height in each section becomes equal to $0$. Note that after all movements, the dump truck may still have sand left in its bed. You need to solve this problem independently for the segments numbered from $l_i$ to $r_i$. Sand outside the segment cannot be used.\n\nInput Format:\nEach test consists of multiple test cases. The first line contains a single integer $t$ ($1 \\le t \\le 10^4$) \u2014 the number of test cases. The description of the test cases follows.\n\nThe first line of each test case contains two integers $n$ and $q$ ($1 \\le n, q \\le 3 \\cdot 10^5$) \u2014 the number of sections and the number of queries.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($-10^9 \\le a_i \\le 10^9$, $a_i \\neq 0$) \u2014 the initial height in each section.\n\nThe $i$-th of the following $q$ lines contains two integers $l_i$ and $r_i$ ($1 \\le l_i \\le r_i \\le n$) \u2014 the boundaries of the segment of sections for which the minimum time needs to be determined.\n\nIt is guaranteed that the sum of $n$ over all test cases and the sum of $q$ over all test cases do not exceed $3 \\cdot 10^5$.\n\nOutput Format:\nFor each query, output the minimum time required to level the sand in the segment $[l_i, r_i]$, or $-1$ if it is impossible.\n\nTags:\n['data structures', 'greedy', 'math', 'matrices']\n\nTime Limit: 3000 ms\nMemory Limit: 512 MB\n",
        "tests": [
            {
                "input": "5\n1 1\n-179\n1 1\n5 3\n-2 2 -1 3 -1\n2 4\n1 5\n1 3\n7 1\n1 1 1 -4 1 1 1\n1 7\n7 2\n2 -2 2 -2 1 2 -1\n1 7\n2 7\n4 4\n1000000000 1000000000 999999999 -1000000000\n2 4\n3 4\n2 3\n1 3",
                "output": "-1\n2\n5\n-1\n8\n6\n6\n2\n-1\n1\n2"
            }
        ]
    },
    {
        "problem": "\nAlice has $a$ coins. She can open a bank deposit called \"Profitable\", but the minimum amount required to open this deposit is $b$ coins.\n\nThere is also a deposit called \"Unprofitable\", which can be opened with any amount of coins. Alice noticed that if she opens the \"Unprofitable\" deposit with $x$ coins, the minimum amount required to open the \"Profitable\" deposit decreases by $2x$ coins. However, these coins cannot later be deposited into the \"Profitable\" deposit.\n\nHelp Alice determine the maximum number of coins she can deposit into the \"Profitable\" deposit if she first deposits some amount of coins (possibly $0$) into the \"Unprofitable\" deposit. If Alice can never open the \"Profitable\" deposit, output $0$.\n\nInput Format:\nEach test consists of multiple test cases. The first line contains a single integer $t$ ($1 \\le t \\le 10^4$) \u2014 the number of test cases. The description of the test cases follows.\n\nA single line of each test case contains two integers $a$ and $b$ ($1 \\le a, b \\le 10^9$) \u2014 the number of coins Alice has and the initial minimum amount required to open the \"Profitable\" deposit.\n\nOutput Format:\nFor each test case, output a single integer \u2014 the maximum number of coins that Alice can deposit into the \"Profitable\" deposit. If Alice can never open the \"Profitable\" deposit, output $0$.\n\nTags:\n['greedy', 'math']\n\nTime Limit: 1000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "5\n10 5\n7 9\n5 100\n1 1\n1 2",
                "output": "10\n5\n0\n1\n0"
            }
        ]
    },
    {
        "problem": "\nThere is a vending machine that sells lemonade. The machine has a total of $n$ slots. You know that initially, the $i$-th slot contains $a_i$ cans of lemonade. There are also $n$ buttons on the machine, each button corresponds to a slot, with exactly one button corresponding to each slot. Unfortunately, the labels on the buttons have worn off, so you do not know which button corresponds to which slot.\n\nWhen you press the button corresponding to the $i$-th slot, one of two events occurs:\n\n  * If there is a can of lemonade in the $i$-th slot, it will drop out and you will take it. At this point, the number of cans in the $i$-th slot decreases by $1$.   * If there are no cans of lemonade left in the $i$-th slot, nothing will drop out. \n\nAfter pressing, the can drops out so quickly that it is impossible to track from which slot it fell. The contents of the slots are hidden from your view, so you cannot see how many cans are left in each slot. The only thing you know is the initial number of cans in the slots: $a_1, a_2, \\ldots, a_n$.\n\nDetermine the minimum number of button presses needed to guarantee that you receive at least $k$ cans of lemonade.\n\nNote that you can adapt your strategy during the button presses based on whether you received a can or not. It is guaranteed that there are at least $k$ cans of lemonade in total in the machine. In other words, $k \\leq a_1 + a_2 + \\ldots + a_n$.\n\nInput Format:\nEach test consists of multiple test cases. The first line contains a single integer $t$ ($1 \\le t \\le 10^4$) \u2014 the number of test cases. The description of the test cases follows.\n\nThe first line of each test case contains two integers $n$ and $k$ ($1 \\le n \\le 2 \\cdot 10^5$, $1 \\leq k \\leq 10^9$) \u2014 the number of slots in the machine and the required number of cans of lemonade.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\le a_i \\le 10^9$) \u2014 the number of cans in the slots.\n\nIt is guaranteed that $k \\leq a_1 + a_2 + \\ldots + a_n$, meaning there are at least $k$ cans of lemonade in the machine.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\nOutput Format:\nFor each test case, output a single integer \u2014 the minimum number of button presses needed to guarantee that you receive at least $k$ cans of lemonade.\n\nTags:\n['binary search', 'constructive algorithms', 'sortings']\n\nTime Limit: 1000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "5\n2 1\n1 1\n2 2\n1 2\n3 4\n2 1 3\n10 50\n1 1 3 8 8 9 12 13 27 27\n2 1000000000\n1000000000 500000000",
                "output": "1\n2\n5\n53\n1000000000"
            }
        ]
    },
    {
        "problem": "\nYou are given $n$ arrays $a_1$, $\\ldots$, $a_n$. The length of each array is two. Thus, $a_i = [a_{i, 1}, a_{i, 2}]$. You need to concatenate the arrays into a single array of length $2n$ such that the number of inversions$^{\\dagger}$ in the resulting array is minimized. Note that you do not need to count the actual number of inversions.\n\nMore formally, you need to choose a permutation$^{\\ddagger}$ $p$ of length $n$, so that the array $b = [a_{p_1,1}, a_{p_1,2}, a_{p_2, 1}, a_{p_2, 2}, \\ldots, a_{p_n,1}, a_{p_n,2}]$ contains as few inversions as possible.\n\n$^{\\dagger}$The number of inversions in an array $c$ is the number of pairs of indices $i$ and $j$ such that $i < j$ and $c_i > c_j$.\n\n$^{\\ddagger}$A permutation of length $n$ is an array consisting of $n$ distinct integers from $1$ to $n$ in arbitrary order. For example, $[2,3,1,5,4]$ is a permutation, but $[1,2,2]$ is not a permutation ($2$ appears twice in the array), and $[1,3,4]$ is also not a permutation ($n=3$ but there is $4$ in the array).\n\nInput Format:\nEach test consists of multiple test cases. The first line contains a single integer $t$ ($1 \\le t \\le 10^4$) \u2014 the number of test cases. The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($1 \\le n \\le 10^5$) \u2014 the number of arrays.\n\nEach of the following $n$ lines contains two integers $a_{i,1}$ and $a_{i,2}$ ($1 \\le a_{i,j} \\le 10^9$) \u2014 the elements of the $i$-th array.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $10^5$.\n\nOutput Format:\nFor each test case, output $2n$ integers \u2014 the elements of the array you obtained. If there are multiple solutions, output any of them.\n\nTags:\n['constructive algorithms', 'greedy', 'sortings']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "4\n2\n1 4\n2 3\n3\n3 2\n4 3\n2 1\n5\n5 10\n2 3\n9 6\n4 1\n8 7\n1\n10 20",
                "output": "2 3 1 4\n2 1 3 2 4 3\n4 1 2 3 5 10 8 7 9 6\n10 20"
            }
        ]
    },
    {
        "problem": "\nIt is already the year $3024$, ideas for problems have long run out, and the olympiad now takes place in a modified individual format. The olympiad consists of $n$ problems, numbered from $1$ to $n$. The $i$-th problem has its own score $a_i$ and a certain parameter $b_i$ ($1 \\le b_i \\le n$).\n\nInitially, the testing system gives the participant the first problem. When the participant is given the $i$-th problem, they have two options:\n\n  * They can submit the problem and receive $a_i$ points;    * They can skip the problem, in which case they will never be able to submit it. \n\nThen, the testing system selects the next problem for the participant from problems with indices $j$, such that:\n\n  * If he submitted the $i$-th problem, it looks at problems with indices $j < i$;    * If he skipped the $i$-th problem, it looks at problems with indices $j \\leq b_i$. \n\nAmong these problems, it selects the problem with the maximum index that it has not previously given to the participant (he has neither submitted nor skipped it before). If there is no such problem, then the competition for the participant ends, and their result is equal to the sum of points for all submitted problems. In particular, if the participant submits the first problem, then the competition for them ends. Note that the participant receives each problem at most once.\n\nProkhor has prepared thoroughly for the olympiad, and now he can submit any problem. Help him determine the maximum number of points he can achieve.\n\nInput Format:\nEach test consists of multiple test cases. The first line contains a single integer $t$ ($1 \\leq t \\leq 10^5$) \u2014 the number of test cases. The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($1 \\leq n \\leq 4 \\cdot 10^5$) \u2014 the number of problems in the olympiad.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\leq a_i \\leq 10^9$) \u2014 the scores of the problems.\n\nThe third line of each test case contains $n$ integers $b_1, b_2, \\ldots, b_n$ ($1 \\leq b_i \\leq n$) \u2014 the parameters of the problems.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $4 \\cdot 10^5$.\n\nOutput Format:\nFor each test case, output a single integer \u2014 the maximum number of points that Prokhor can achieve.\n\nTags:\n['constructive algorithms', 'data structures', 'divide and conquer', 'dp', 'flows', 'graphs', 'greedy', 'implementation', 'shortest paths']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "4\n2\n15 16\n2 1\n5\n10 10 100 100 1000\n3 4 1 1 1\n3\n100 49 50\n3 2 2\n4\n100 200 300 1000\n2 3 4 1",
                "output": "16\n200\n100\n1000"
            }
        ]
    },
    {
        "problem": "\nYou are given two strongly connected$^{\\dagger}$ directed graphs, each with exactly $n$ vertices, but possibly different numbers of edges. Upon closer inspection, you noticed an important feature \u2014 the length of any cycle in these graphs is divisible by $k$.\n\nEach of the $2n$ vertices belongs to exactly one of two types: incoming or outgoing. For each vertex, its type is known to you.\n\nYou need to determine whether it is possible to draw exactly $n$ directed edges between the source graphs such that the following four conditions are met:\n\n  * The ends of any added edge lie in different graphs.    * From each outgoing vertex, exactly one added edge originates.    * Into each incoming vertex, exactly one added edge enters.    * In the resulting graph, the length of any cycle is divisible by $k$. \n\n$^{\\dagger}$A strongly connected graph is a graph in which there is a path from every vertex to every other vertex.\n\nInput Format:\nEach test consists of multiple test cases. The first line contains a single integer $t$ ($1 \\le t \\le 10^4$) \u2014 the number of test cases. The description of the test cases follows.\n\nThe first line of each test case contains two integers $n$ and $k$ ($2 \\le k \\le n \\le 2 \\cdot 10^5$) \u2014 the number of vertices in each graph and the value by which the length of each cycle is divisible.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($a_i \\in \\\\{0, 1\\\\}$). If $a_i = 0$, then vertex $i$ of the first graph is incoming. If $a_i = 1$, then vertex $i$ of the first graph is outgoing.\n\nThe third line of each test case contains a single integer $m_1$ ($1 \\le m_1 \\le 5 \\cdot 10^5$) \u2014 the number of edges in the first graph.\n\nThe next $m_1$ lines contain descriptions of the edges of the first graph. The $i$-th of them contains two integers $v_i$ and $u_i$ ($1 \\le v_i, u_i \\le n$) \u2014 an edge in the first graph leading from vertex $v_i$ to vertex $u_i$.\n\nNext, in the same format, follows the description of the second graph.\n\nThe next line contains $n$ integers $b_1, b_2, \\ldots, b_n$ ($b_i \\in \\\\{0, 1\\\\}$). If $b_i = 0$, then vertex $i$ of the second graph is incoming. If $b_i = 1$, then vertex $i$ of the second graph is outgoing.\n\nThe next line contains a single integer $m_2$ ($1 \\le m_2 \\le 5 \\cdot 10^5$) \u2014 the number of edges in the second graph.\n\nThe next $m_2$ lines contain descriptions of the edges of the second graph. The $i$-th of them contains two integers $v_i$ and $u_i$ ($1 \\le v_i, u_i \\le n$) \u2014 an edge in the second graph leading from vertex $v_i$ to vertex $u_i$.\n\nIt is guaranteed that both graphs are strongly connected, and the lengths of all cycles are divisible by $k$.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$. It is guaranteed that the sum of $m_1$ and the sum of $m_2$ over all test cases does not exceed $5 \\cdot 10^5$.\n\nOutput Format:\nFor each test case, output \"YES\" (without quotes) if it is possible to draw $n$ new edges such that all conditions are met, and \"NO\" (without quotes) otherwise.\n\nYou may output the answer in any case (for example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as a positive answer).\n\nTags:\n['constructive algorithms', 'graphs', 'hashing', 'strings']\n\nTime Limit: 3000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "3\n4 2\n1 0 0 1\n4\n1 2\n2 3\n3 4\n4 1\n1 0 0 1\n4\n1 3\n3 2\n2 4\n4 1\n3 3\n0 0 0\n3\n1 2\n2 3\n3 1\n1 1 0\n3\n1 2\n2 3\n3 1\n4 2\n1 1 1 1\n4\n1 2\n2 3\n3 4\n4 1\n0 0 0 0\n6\n1 2\n2 1\n1 3\n3 1\n1 4\n4 1",
                "output": "YES\nNO\nYES"
            }
        ]
    },
    {
        "problem": "\nRecently, you received a rare ticket to the only casino in the world where you can actually earn something, and you want to take full advantage of this opportunity.\n\nThe conditions in this casino are as follows:\n\n  * There are a total of $n$ games in the casino.    * You can play each game at most once.    * Each game is characterized by two parameters: $p_i$ ($1 \\le p_i \\le 100$) and $w_i$ \u2014 the probability of winning the game in percentage and the winnings for a win.    * If you lose in any game you decide to play, you will receive nothing at all (even for the games you won). \n\nYou need to choose a set of games in advance that you will play in such a way as to maximize the expected value of your winnings.\n\nIn this case, if you choose to play the games with indices $i_1 < i_2 < \\ldots < i_k$, you will win in all of them with a probability of $\\prod\\limits_{j=1}^k \\frac{p_{i_j}}{100}$, and in that case, your winnings will be equal to $\\sum\\limits_{j=1}^k w_{i_j}$.\n\nThat is, the expected value of your winnings will be $\\left(\\prod\\limits_{j=1}^k \\frac{p_{i_j}}{100}\\right) \\cdot \\left(\\sum\\limits_{j=1}^k w_{i_j}\\right)$.\n\nTo avoid going bankrupt, the casino owners have limited the expected value of winnings for each individual game. Thus, for all $i$ ($1 \\le i \\le n$), it holds that $w_i \\cdot p_i \\le 2 \\cdot 10^5$.\n\nYour task is to find the maximum expected value of winnings that can be obtained by choosing some set of games in the casino.\n\nInput Format:\nThe first line contains a single integer $n$ ($1 \\le n \\le 2 \\cdot 10^5$) \u2014 the number of games offered to play.\n\nThe $i$-th of the following $n$ lines contains two integers $p_i$ and $w_i$ ($1 \\leq p_i \\leq 100$, $1 \\leq w_i, p_i \\cdot w_i \\leq 2 \\cdot 10^5$) \u2014 the probability of winning and the size of the winnings in the $i$-th game.\n\nOutput Format:\nOutput a single number \u2014 the maximum expected value of winnings in the casino that can be obtained by choosing some subset of games.\n\nYour answer will be accepted if the relative or absolute error does not exceed $10^{-6}$. Formally, if $a$ is your answer and $b$ is the jury's answer, it will be accepted if $\\frac{|a-b|}{\\max(b, 1)} \\le 10^{-6}$.\n\nTags:\n['dp', 'math']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "3\n80 80\n70 100\n50 200",
                "output": "112.00000000"
            },
            {
                "input": "2\n100 1\n100 1",
                "output": "2.00000000"
            },
            {
                "input": "4\n1 100\n2 1000\n2 100\n3 1",
                "output": "20.00000000"
            },
            {
                "input": "5\n34 804\n78 209\n99 191\n61 439\n90 79",
                "output": "395.20423800"
            }
        ]
    },
    {
        "problem": "\nThere are two screens which can display sequences of uppercase Latin letters. Initially, both screens display nothing.\n\nIn one second, you can do one of the following two actions:\n\n  * choose a screen and an uppercase Latin letter, and append that letter to the end of the sequence displayed on that screen;    * choose a screen and copy the sequence from it to the other screen, overwriting the sequence that was displayed on the other screen. \n\nYou have to calculate the minimum number of seconds you have to spend so that the first screen displays the sequence $s$, and the second screen displays the sequence $t$.\n\nInput Format:\nThe first line contains one integer $q$ ($1 \\le q \\le 500$) \u2014 the number of test cases.\n\nEach test case consists of two lines. The first line contains the string $s$, and the second line contains the string $t$ ($1 \\le |s|, |t| \\le 100$). Both strings consist of uppercase Latin letters.\n\nOutput Format:\nFor each test case, print one integer \u2014 the minimum possible number of seconds you have to spend so that the first screen displays the sequence $s$, and the second screen displays the sequence $t$.\n\nTags:\n['binary search', 'greedy', 'strings', 'two pointers']\n\nTime Limit: 2000 ms\nMemory Limit: 512 MB\n",
        "tests": [
            {
                "input": "3\nGARAGE\nGARAGEFORSALE\nABCDE\nAABCD\nTRAINING\nDRAINING",
                "output": "14\n10\n16"
            }
        ]
    },
    {
        "problem": "\nRecently, akshiM met a task that needed binomial coefficients to solve. He wrote a code he usually does that looked like this:\n\n                  for (int n = 0; n < N; n++) { // loop over n from 0 to N-1 (inclusive)               C[n][0] = 1;               C[n][n] = 1;               for (int k = 1; k < n; k++) // loop over k from 1 to n-1 (inclusive)                   C[n][k] = C[n][k - 1] + C[n - 1][k - 1];           }       \n\nUnfortunately, he made an error, since the right formula is the following:\n\n                          C[n][k] = C[n - 1][k] + C[n - 1][k - 1]       \n\nBut his team member keblidA is interested in values that were produced using the wrong formula. Please help him to calculate these coefficients for $t$ various pairs $(n_i, k_i)$. Note that they should be calculated according to the first (wrong) formula.\n\nSince values $C[n_i][k_i]$ may be too large, print them modulo $10^9 + 7$.\n\nInput Format:\nThe first line contains a single integer $t$ ($1 \\le t \\le 10^5$) \u2014 the number of pairs. Next, $t$ pairs are written in two lines.\n\nThe second line contains $t$ integers $n_1, n_2, \\dots, n_t$ ($2 \\le n_i \\le 10^5$).\n\nThe third line contains $t$ integers $k_1, k_2, \\dots, k_t$ ($1 \\le k_i < n_i$).\n\nOutput Format:\nPrint $t$ integers $C[n_i][k_i]$ modulo $10^9 + 7$.\n\nTags:\n['combinatorics', 'dp', 'math']\n\nTime Limit: 2000 ms\nMemory Limit: 512 MB\n",
        "tests": [
            {
                "input": "7\n2 5 5 100000 100000 100000 100000\n1 2 3 1 33333 66666 99999",
                "output": "2\n4\n8\n2\n326186014\n984426998\n303861760"
            }
        ]
    },
    {
        "problem": "\nThere's a new game Monocarp wants to play. The game uses a deck of $n$ cards, where the $i$-th card has exactly one integer $a_i$ written on it.\n\nAt the beginning of the game, on the first turn, Monocarp can take any card from the deck. During each subsequent turn, Monocarp can take exactly one card that has either the same number as on the card taken on the previous turn or a number that is one greater than the number on the card taken on the previous turn.\n\nIn other words, if on the previous turn Monocarp took a card with the number $x$, then on the current turn he can take either a card with the number $x$ or a card with the number $x + 1$. Monocarp can take any card which meets that condition, regardless of its position in the deck.\n\nAfter Monocarp takes a card on the current turn, it is removed from the deck.\n\nAccording to the rules of the game, the number of distinct numbers written on the cards that Monocarp has taken must not exceed $k$.\n\nIf, after a turn, Monocarp cannot take a card without violating the described rules, the game ends.\n\nYour task is to determine the maximum number of cards that Monocarp can take from the deck during the game, given that on the first turn he can take any card from the deck.\n\nInput Format:\nThe first line contains a single integer $t$ ($1 \\le t \\le 10^4$) \u2014 the number of test cases.\n\nThe first line of each test case contains two integers $n$ and $k$ ($1 \\le k \\le n \\le 200\\,000$) \u2014 the number of cards in the deck and the maximum number of distinct numbers that can be written on the cards that Monocarp takes.\n\nThe second line contains a sequence of integers $a_1, a_2, \\dots, a_n$ ($1 \\le a_i \\le 10^{9}$), where $a_i$ is the number written on the $i$-th card.\n\nAdditional constraint of the input: the sum of $n$ over all test cases doesn't exceed $200\\,000$.\n\nOutput Format:\nFor each test case, print the maximum number of cards that Monocarp can take from the deck during the game, given that on the first turn he can take any card from the deck.\n\nTags:\n['binary search', 'brute force', 'greedy', 'implementation', 'sortings', 'two pointers']\n\nTime Limit: 2000 ms\nMemory Limit: 512 MB\n",
        "tests": [
            {
                "input": "4\n10 2\n5 2 4 3 4 3 4 5 3 2\n5 1\n10 11 10 11 10\n9 3\n4 5 4 4 6 5 4 4 6\n3 2\n1 3 1",
                "output": "6\n3\n9\n2"
            }
        ]
    },
    {
        "problem": "\nImagine a game where you play as a character that has two attributes: \"Strength\" and \"Intelligence\", that are at zero level initially.\n\nDuring the game, you'll acquire $m$ attribute points that allow you to increase your attribute levels \u2014 one point will increase one of the attributes by one level. But sometimes, you'll encounter a so-called \"Attribute Checks\": if your corresponding attribute is high enough, you'll pass it; otherwise, you'll fail it.\n\nSpending some time, you finally prepared a list which contains records of all points you got and all checks you've met. And now you're wondering: what is the maximum number of attribute checks you can pass in a single run if you'd spend points wisely?\n\nNote that you can't change the order of records.\n\nInput Format:\nThe first line contains two integers $n$ and $m$ ($1 \\le m \\le 5000$; $m < n \\le 2 \\cdot 10^6$) \u2014 the number of records in the list and the total number of points you'll get during the game.\n\nThe second line contains $n$ integers $r_1, r_2, \\dots, r_n$ ($-m \\le r_i \\le m$), where $r_i$ encodes the $i$-th record:\n\n  * If $r_i = 0$, then the $i$-th record is an acquiring one attribute point. You can spend to level up either Strength or Intelligence;    * If $r_i > 0$, then it's an Intelligence check: if your Intelligence level is greater than or equal to $|r_i|$, you pass.    * If $r_i < 0$, then it's a Strength check: if your Strength level is greater than or equal to $|r_i|$, you pass. \n\nAdditional constraint on the input: the sequence $r_1, r_2, \\dots, r_n$ contains exactly $m$ elements equal to $0$.\n\nOutput Format:\nPrint one integer \u2014 the maximum number of checks you can pass.\n\nTags:\n['brute force', 'data structures', 'dp', 'implementation', 'math', 'two pointers']\n\nTime Limit: 2500 ms\nMemory Limit: 512 MB\n",
        "tests": [
            {
                "input": "10 5\n0 1 0 2 0 -3 0 -4 0 -5",
                "output": "3"
            },
            {
                "input": "3 1\n1 -1 0",
                "output": "0"
            },
            {
                "input": "9 3\n0 0 1 0 2 -3 -2 -2 1",
                "output": "4"
            }
        ]
    },
    {
        "problem": "\nIn the most popular card game in Berland, a deck of $n \\times m$ cards is used. Each card has two parameters: suit and rank. Suits in the game are numbered from $1$ to $n$, and ranks are numbered from $1$ to $m$. There is exactly one card in the deck for each combination of suit and rank.\n\nA card with suit $a$ and rank $b$ can beat a card with suit $c$ and rank $d$ in one of two cases:\n\n  * $a = 1$, $c \\ne 1$ (a card of suit $1$ can beat a card of any other suit);    * $a = c$, $b > d$ (a card can beat any other card of the same suit but of a lower rank). \n\nTwo players play the game. Before the game starts, they receive exactly half of the deck each. The first player wins if for every card of the second player, he can choose his card that can beat it, and there is no card that is chosen twice (i. e. there exists a matching of the first player's cards with the second player's cards such that in each pair the first player's card beats the second player's card). Otherwise, the second player wins.\n\nYour task is to calculate the number of ways to distribute the cards so that the first player wins. Two ways are considered different if there exists a card such that in one way it belongs to the first player and in the other way it belongs to the second player. The number of ways can be very large, so print it modulo $998244353$.\n\nInput Format:\nThe only line contains two integers $n$ and $m$ ($1 \\le n, m \\le 500$).\n\nAdditional constraint on the input: $m$ is even.\n\nOutput Format:\nPrint a single integer \u2014 the number of ways to distribute the cards so that the first player wins, taken modulo $998244353$.\n\nTags:\n['combinatorics', 'dp', 'fft', 'greedy', 'math']\n\nTime Limit: 2000 ms\nMemory Limit: 512 MB\n",
        "tests": [
            {
                "input": "1 4",
                "output": "2"
            },
            {
                "input": "2 2",
                "output": "2"
            },
            {
                "input": "3 6",
                "output": "1690"
            },
            {
                "input": "5 4",
                "output": "568"
            },
            {
                "input": "500 500",
                "output": "84693741"
            }
        ]
    },
    {
        "problem": "\nYou are given an array $a$, consisting of $n$ integers (numbered from $1$ to $n$). Initially, they are all zeroes.\n\nYou have to process $q$ queries. The $i$-th query consists of two different integers $x_i$ and $y_i$. During the $i$-th query, you have to choose an integer $p$ (which is either $x_i$ or $y_i$) and an integer $d$ (which is either $1$ or $-1$), and assign $a_p = a_p + d$.\n\nAfter each query, every element of $a$ should be a non-negative integer.\n\nProcess all queries in such a way that the sum of all elements of $a$ after the last query is the minimum possible.\n\nInput Format:\nThe first line contains two integers $n$ and $q$ ($2 \\le n \\le 3 \\cdot 10^5$; $1 \\le q \\le 3 \\cdot 10^5$) \u2014 the number of elements in $a$ and the number of queries, respectively.\n\nThen $q$ lines follow. The $i$-th of these lines contains two integers $x_i$ and $y_i$ ($1 \\le x_i, y_i \\le n$; $x_i \\ne y_i$) \u2014 the description of the $i$-th query.\n\nOutput Format:\nFor each query, print a line containing two characters:\n\n  * the first character should be x if you choose $p=x_i$, or y if you choose $p=y_i$;    * the second character should be + if you choose $d=1$, or - if you choose $d=-1$. \n\nIf there are multiple answers, print any of them.\n\nTags:\n['constructive algorithms', 'dfs and similar', 'dp', 'graphs', 'greedy', 'trees']\n\nTime Limit: 3000 ms\nMemory Limit: 512 MB\n",
        "tests": [
            {
                "input": "3 4\n1 2\n3 2\n3 1\n1 2",
                "output": "y+\nx+\nx-\ny-"
            },
            {
                "input": "4 4\n1 2\n2 3\n3 4\n3 2",
                "output": "y+\ny+\nx-\ny-"
            },
            {
                "input": "4 2\n2 1\n4 3",
                "output": "y+\nx+"
            }
        ]
    },
    {
        "problem": "\nMonocarp is gathering an army to fight a dragon in a videogame.\n\nThe army consists of two parts: the heroes and the defensive artifacts. Each hero has one parameter \u2014 his health. Each defensive artifact also has one parameter \u2014 its durability.\n\nBefore the battle begins, Monocarp distributes artifacts to the heroes so that each hero receives at most one artifact.\n\nThe battle consists of rounds that proceed as follows:\n\n  * first, the dragon deals damage equal to $\\frac{1}{a + b}$ (a real number without rounding) to each hero, where $a$ is the number of heroes alive and $b$ is the number of active artifacts;    * after that, all heroes with health $0$ or less die;    * finally, some artifacts are deactivated. An artifact with durability $x$ is deactivated when one of the following occurs: the hero holding the artifact either dies or receives $x$ total damage (from the start of the battle). If an artifact is not held by any hero, it is inactive from the beginning of the battle. \n\nThe battle ends when there are no heroes left alive.\n\nInitially, the army is empty. There are $q$ queries: add a hero with health $x$ or an artifact with durability $y$ to the army. After each query, determine the maximum number of rounds that Monocarp can survive if he distributes the artifacts optimally.\n\nInput Format:\nThe first line contains one integer $q$ ($1 \\le q \\le 3 \\cdot 10^5$) \u2014 the number of queries.\n\nIn the $i$-th of the following $q$ lines, there are two integers $t_i$ and $v_i$ ($t_i \\in \\\\{1, 2\\\\}$; $1 \\le v_i \\le 10^9$) \u2014 the type of the query and the value of the query parameter. If the type is $1$, a hero with health $v_i$ is added. If the type is $2$, an artifact with durability $v_i$ is added.\n\nOutput Format:\nPrint $q$ integers. After each query, output the maximum number of rounds that Monocarp can survive if he distributes the artifacts optimally.\n\nTags:\n['data structures', 'flows']\n\nTime Limit: 5000 ms\nMemory Limit: 512 MB\n",
        "tests": [
            {
                "input": "3\n2 5\n1 4\n1 10",
                "output": "0\n8\n19"
            },
            {
                "input": "10\n1 9\n1 6\n2 4\n1 8\n1 3\n2 10\n1 3\n1 6\n1 10\n2 6",
                "output": "9\n15\n19\n27\n30\n39\n42\n48\n59\n65"
            }
        ]
    },
    {
        "problem": "\nYou are given a coordinate plane and three integers $X$, $Y$, and $K$. Find two line segments $AB$ and $CD$ such that\n\n  1. the coordinates of points $A$, $B$, $C$, and $D$ are integers;    2. $0 \\le A_x, B_x, C_x, D_x \\le X$ and $0 \\le A_y, B_y, C_y, D_y \\le Y$;    3. the length of segment $AB$ is at least $K$;    4. the length of segment $CD$ is at least $K$;    5. segments $AB$ and $CD$ are perpendicular: if you draw lines that contain $AB$ and $CD$, they will cross at a right angle. \n\nNote that it's not necessary for segments to intersect. Segments are perpendicular as long as the lines they induce are perpendicular.\n\nInput Format:\nThe first line contains a single integer $t$ ($1 \\le t \\le 5000$) \u2014 the number of test cases. Next, $t$ cases follow.\n\nThe first and only line of each test case contains three integers $X$, $Y$, and $K$ ($1 \\le X, Y \\le 1000$; $1 \\le K \\le 1414$).\n\nAdditional constraint on the input: the values of $X$, $Y$, and $K$ are chosen in such a way that the answer exists.\n\nOutput Format:\nFor each test case, print two lines. The first line should contain $4$ integers $A_x$, $A_y$, $B_x$, and $B_y$ \u2014 the coordinates of the first segment.\n\nThe second line should also contain $4$ integers $C_x$, $C_y$, $D_x$, and $D_y$ \u2014 the coordinates of the second segment.\n\nIf there are multiple answers, print any of them.\n\nTags:\n['constructive algorithms', 'geometry', 'greedy', 'math']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "4\n1 1 1\n3 4 1\n4 3 3\n3 4 4",
                "output": "0 0 1 0\n0 0 0 1\n2 4 2 2\n0 1 1 1\n0 0 1 3\n1 2 4 1\n0 1 3 4\n0 3 3 0"
            }
        ]
    },
    {
        "problem": "\nYou are given a strip divided into cells, numbered from left to right from $0$ to $10^{18}$. Initially, all cells are white.\n\nYou can perform the following operation: choose two white cells $i$ and $j$, such that $i \\ne j$ and $|i - j| \\le k$, and paint them black.\n\nA list $a$ is given. All cells from this list must be painted black. Additionally, at most one cell that is not in this list can also be painted black. Your task is to determine the minimum value of $k$ for which this is possible.\n\nInput Format:\nThe first line contains a single integer $t$ ($1 \\le t \\le 500$) \u2014 the number of test cases.\n\nThe first line of each test case contains a single integer $n$ ($1 \\le n \\le 2000$).\n\nThe second line contains $n$ integers $a_1, a_2, \\dots, a_n$ ($0 < a_i < 10^{18}$; $a_i < a_{i + 1}$).\n\nAdditional constraint on the input: the sum of $n$ across all test cases does not exceed $2000$.\n\nOutput Format:\nFor each test case, print a single integer \u2014 the minimum value of $k$ for which it is possible to paint all the given cells black.\n\nTags:\n['binary search', 'brute force', 'constructive algorithms', 'greedy']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "4\n2\n1 2\n1\n7\n3\n2 4 9\n5\n1 5 8 10 13",
                "output": "1\n1\n2\n3"
            }
        ]
    },
    {
        "problem": "\nThere is a shop that sells action figures near Monocarp's house. A new set of action figures will be released shortly; this set contains $n$ figures, the $i$-th figure costs $i$ coins and is available for purchase from day $i$ to day $n$.\n\nFor each of the $n$ days, Monocarp knows whether he can visit the shop.\n\nEvery time Monocarp visits the shop, he can buy any number of action figures which are sold in the shop (of course, he cannot buy an action figure that is not yet available for purchase). If Monocarp buys at least two figures during the same day, he gets a discount equal to the cost of the most expensive figure he buys (in other words, he gets the most expensive of the figures he buys for free).\n\nMonocarp wants to buy exactly one $1$-st figure, one $2$-nd figure, ..., one $n$-th figure from the set. He cannot buy the same figure twice. What is the minimum amount of money he has to spend?\n\nInput Format:\nThe first line contains one integer $t$ ($1 \\le t \\le 10^4$) \u2014 the number of test cases.\n\nEach test case consists of two lines:\n\n  * the first line contains one integer $n$ ($1 \\le n \\le 4 \\cdot 10^5$) \u2014 the number of figures in the set (and the number of days);    * the second line contains a string $s$ ($|s| = n$, each $s_i$ is either 0 or 1). If Monocarp can visit the shop on the $i$-th day, then $s_i$ is 1; otherwise, $s_i$ is 0. \n\nAdditional constraints on the input:\n\n  * in each test case, $s_n$ is 1, so Monocarp is always able to buy all figures during the $n$-th day;    * the sum of $n$ over all test cases does not exceed $4 \\cdot 10^5$.\n\nOutput Format:\nFor each test case, print one integer \u2014 the minimum amount of money Monocarp has to spend.\n\nTags:\n['binary search', 'brute force', 'constructive algorithms', 'data structures', 'greedy', 'implementation']\n\nTime Limit: 2500 ms\nMemory Limit: 512 MB\n",
        "tests": [
            {
                "input": "4\n1\n1\n6\n101101\n7\n1110001\n5\n11111",
                "output": "1\n8\n18\n6"
            }
        ]
    },
    {
        "problem": "\nYou are given a sequence of integers $[a_1, a_2, \\dots, a_n]$. Let $s(l,r)$ be the sum of elements from $a_l$ to $a_r$ (i. e. $s(l,r) = \\sum\\limits_{i=l}^{r} a_i$).\n\nLet's construct another sequence $b$ of size $\\frac{n(n+1)}{2}$ as follows: $b = [s(1,1), s(1,2), \\dots, s(1,n), s(2,2), s(2,3), \\dots, s(2,n), s(3,3), \\dots, s(n,n)]$.\n\nFor example, if $a = [1, 2, 5, 10]$, then $b = [1, 3, 8, 18, 2, 7, 17, 5, 15, 10]$.\n\nYou are given $q$ queries. During the $i$-th query, you are given two integers $l_i$ and $r_i$, and you have to calculate $\\sum \\limits_{j=l_i}^{r_i} b_j$.\n\nInput Format:\nThe first line contains one integer $n$ ($1 \\le n \\le 3 \\cdot 10^5$).\n\nThe second line contains $n$ integers $a_1, a_2, \\dots, a_n$ ($-10 \\le a_i \\le 10$).\n\nThe third line contains one integer $q$ ($1 \\le q \\le 3 \\cdot 10^5$).\n\nThen $q$ lines follow, the $i$-th of them contains two integers $l_i$ and $r_i$ ($1 \\le l_i \\le r_i \\le \\frac{n(n+1)}{2}$).\n\nOutput Format:\nPrint $q$ integers, the $i$-th of which should be equal to $\\sum \\limits_{j=l_i}^{r_i} b_j$.\n\nTags:\n['binary search', 'data structures', 'dp', 'implementation', 'math']\n\nTime Limit: 4000 ms\nMemory Limit: 512 MB\n",
        "tests": [
            {
                "input": "4\n1 2 5 10\n15\n1 1\n1 2\n1 3\n1 4\n1 5\n1 10\n5 10\n6 10\n2 8\n3 4\n3 10\n3 8\n5 6\n5 5\n1 8",
                "output": "1\n4\n12\n30\n32\n86\n56\n54\n60\n26\n82\n57\n9\n2\n61"
            }
        ]
    },
    {
        "problem": "\nGiven an integer array $a$ of size $n$.\n\nLet's define the value of the array as its size minus the number of set bits in the bitwise OR of all elements of the array.\n\nFor example, for the array $[1, 0, 1, 2]$, the bitwise OR is $3$ (which contains $2$ set bits), and the value of the array is $4-2=2$.\n\nYour task is to calculate the maximum possible value of some subsequence of the given array.\n\nInput Format:\nThe first line contains a single integer $t$ ($1 \\le t \\le 100$) \u2014 the number of test cases.\n\nThe first line of each test case contains a single integer $n$ ($1 \\le n \\le 100$).\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\dots, a_n$ ($0 \\le a_i < 2^{60}$).\n\nOutput Format:\nFor each test case, print the maximum possible value of some subsequence of the given array.\n\nTags:\n['bitmasks', 'dfs and similar', 'flows', 'graph matchings', 'graphs']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "4\n3\n0 0 0\n4\n1 0 1 2\n1\n5\n8\n7 1 48 14 13 8 7 6",
                "output": "3\n2\n0\n3"
            }
        ]
    },
    {
        "problem": "\nIn the Bermart chain of stores, a variety of ice cream is sold. Each type of ice cream has two parameters: price and tastiness.\n\nInitially, there is one store numbered $1$, which sells nothing. You have to process $q$ queries of the following types:\n\n  * $1~x$ \u2014 a new store opens, that sells the same types of ice cream as store $x$. It receives the minimum available positive index. The order of the types of ice cream in the new store is the same as in store $x$.    * $2~x~p~t$ \u2014 a type of ice cream with price $p$ and tastiness $t$ becomes available in store $x$.    * $3~x$ \u2014 a type of ice cream that was available the longest (appeared the earliest) in store $x$ is removed.    * $4~x~p$ \u2014 for store $x$, find the maximum total tastiness of a subset of types of ice cream that are sold there, such that the total price does not exceed $p$ (each type can be used in the subset no more than once).\n\nInput Format:\nThe first line contains a single integer $q$ ($1 \\le q \\le 3 \\cdot 10^4$) \u2014 the number of queries.\n\nEach of the following $q$ lines contains a query in the format described in the statement:\n\n  * $1~x$;    * $2~x~p~t$ ($1 \\le p, t \\le 2000$);    * $3~x$;    * $4~x~p$ ($1 \\le p \\le 2000$). \n\nAdditional constraints on the input data:\n\n  * $x$ in each query does not exceed the current number of stores (that is, $1$ plus the number of type $1$ queries);    * query type $3$ is not applied to a store that has no types of ice cream;    * there is at least one query of type $4$.\n\nOutput Format:\nFor each query of type $4$, output a single integer \u2014 for store $x$, find the maximum total tastiness of a subset of types of ice cream that are sold there, such that the total price does not exceed $p$ (each type can be used in the subset no more than once).\n\nTags:\n['data structures', 'dfs and similar', 'divide and conquer', 'dp', 'implementation', 'trees']\n\nTime Limit: 2000 ms\nMemory Limit: 1024 MB\n",
        "tests": [
            {
                "input": "12\n2 1 5 7\n2 1 3 4\n4 1 4\n4 1 8\n4 1 2\n1 1\n2 2 4 10\n4 1 9\n4 2 9\n3 1\n4 1 9\n4 2 9",
                "output": "4\n11\n0\n11\n17\n4\n17"
            }
        ]
    },
    {
        "problem": "\nYou are coloring an infinite square grid, in which all cells are initially white. To do this, you are given $n$ stamps. Each stamp is a rectangle of width $w_i$ and height $h_i$.\n\nYou will use each stamp exactly once to color a rectangle of the same size as the stamp on the grid in black. You cannot rotate the stamp, and for each cell, the stamp must either cover it fully or not cover it at all. You can use the stamp at any position on the grid, even if some or all of the cells covered by the stamping area are already black.\n\nWhat is the minimum sum of the perimeters of the connected regions of black squares you can obtain after all the stamps have been used?\n\nInput Format:\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 500$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($1 \\le n \\le 100$).\n\nThe $i$-th of the next $n$ lines contains two integers $w_i$ and $h_i$ ($1 \\le w_i, h_i \\le 100$).\n\nOutput Format:\nFor each test case, output a single integer \u2014 the minimum sum of the perimeters of the connected regions of black squares you can obtain after all the stamps have been used.\n\nTags:\n['geometry', 'implementation', 'math']\n\nTime Limit: 1000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "5\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n3\n2 2\n1 1\n1 2\n1\n3 2\n3\n100 100\n100 100\n100 100\n4\n1 4\n2 3\n1 5\n3 2",
                "output": "20\n8\n10\n400\n16"
            }
        ]
    },
    {
        "problem": "\nStalin Sort is a humorous sorting algorithm designed to eliminate elements which are out of place instead of bothering to sort them properly, lending itself to an $\\mathcal{O}(n)$ time complexity.\n\nIt goes as follows: starting from the second element in the array, if it is strictly smaller than the previous element (ignoring those which have already been deleted), then delete it. Continue iterating through the array until it is sorted in non-decreasing order. For example, the array $[1, 4, 2, 3, 6, 5, 5, 7, 7]$ becomes $[1, 4, 6, 7, 7]$ after a Stalin Sort.\n\nWe define an array as vulnerable if you can sort it in non-increasing order by repeatedly applying a Stalin Sort to any of its subarrays$^{\\text{\u2217}}$, as many times as is needed.\n\nGiven an array $a$ of $n$ integers, determine the minimum number of integers which must be removed from the array to make it vulnerable.\n\n$^{\\text{\u2217}}$An array $a$ is a subarray of an array $b$ if $a$ can be obtained from $b$ by the deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end.\n\nInput Format:\nEach test consists of several test cases. The first line contains a single integer $t$ ($1 \\le t \\le 500$) \u2014 the number of test cases. This is followed by descriptions of the test cases.\n\nThe first line of each test case contains a single integer $n$ ($1 \\le n \\le 2000$) \u2014 the size of the array.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\le a_i \\le 10^9$).\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2000$.\n\nOutput Format:\nFor each test case, output a single integer \u2014 the minimum number of integers which must be removed from the array to make it vulnerable.\n\nTags:\n['brute force', 'greedy']\n\nTime Limit: 1000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "6\n7\n3 6 4 9 2 5 2\n5\n5 4 4 2 2\n8\n2 2 4 4 6 6 10 10\n1\n1000\n9\n6 8 9 10 12 9 7 5 4\n7\n300000000 600000000 400000000 900000000 200000000 400000000 200000000",
                "output": "2\n0\n6\n0\n4\n2"
            }
        ]
    },
    {
        "problem": "\nYou're given an array $a$ initially containing $n$ integers. In one operation, you must do the following:\n\n  * Choose a position $i$ such that $1 < i \\le |a|$ and $a_i = |a| + 1 - i$, where $|a|$ is the current size of the array.    * Append $i - 1$ zeros onto the end of $a$. \n\nAfter performing this operation as many times as you want, what is the maximum possible length of the array $a$?\n\nInput Format:\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 1000$). The description of the test cases follows.\n\nThe first line of each test case contains $n$ ($1 \\le n \\le 3 \\cdot 10^5$) \u2014 the length of the array $a$.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\le a_i \\le 10^{12}$).\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $3 \\cdot 10^5$.\n\nOutput Format:\nFor each test case, output a single integer \u2014 the maximum possible length of $a$ after performing some sequence of operations.\n\nTags:\n['brute force', 'data structures', 'dfs and similar', 'dp', 'graphs', 'greedy']\n\nTime Limit: 3000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "4\n5\n2 4 6 2 5\n5\n5 4 4 5 1\n4\n6 8 2 3\n1\n1",
                "output": "10\n11\n10\n1"
            }
        ]
    },
    {
        "problem": "\nThis is the easy version of this problem. The only difference is that you only need to output the minimum total cost of operations in this version. You must solve both versions to be able to hack.\n\nYou're given an array $a$ of length $n$, and an array $b$ of length $m$ ($b_i > b_{i+1}$ for all $1 \\le i < m$). Initially, the value of $k$ is $1$. Your aim is to make the array $a$ empty by performing one of these two operations repeatedly:\n\n  * Type $1$ \u2014 If the value of $k$ is less than $m$ and the array $a$ is not empty, you can increase the value of $k$ by $1$. This does not incur any cost.    * Type $2$ \u2014 You remove a non-empty prefix of array $a$, such that its sum does not exceed $b_k$. This incurs a cost of $m - k$. \n\nYou need to minimize the total cost of the operations to make array $a$ empty. If it's impossible to do this through any sequence of operations, output $-1$. Otherwise, output the minimum total cost of the operations.\n\nInput Format:\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 1000$). The description of the test cases follows.\n\nThe first line of each test case contains two integers $n$ and $m$ ($1 \\le n, m \\le 3 \\cdot 10^5$, $\\boldsymbol{1 \\le n \\cdot m \\le 3 \\cdot 10^5}$).\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\le a_i \\le 10^9$).\n\nThe third line of each test case contains $m$ integers $b_1, b_2, \\ldots, b_m$ ($1 \\le b_i \\le 10^9$).\n\nIt is also guaranteed that $b_i > b_{i+1}$ for all $1 \\le i < m$.\n\nIt is guaranteed that the sum of $\\boldsymbol{n \\cdot m}$ over all test cases does not exceed $3 \\cdot 10^5$.\n\nOutput Format:\nFor each test case, if it's possible to make $a$ empty, then output the minimum total cost of the operations.\n\nIf there is no possible sequence of operations which makes $a$ empty, then output a single integer $-1$.\n\nTags:\n['binary search', 'dp', 'graphs', 'greedy', 'implementation', 'two pointers']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "5\n4 2\n9 3 4 3\n11 7\n1 2\n20\n19 18\n10 2\n2 5 2 1 10 3 2 9 9 6\n17 9\n10 11\n2 2 2 2 2 2 2 2 2 2\n20 18 16 14 12 10 8 6 4 2 1\n1 6\n10\n32 16 8 4 2 1",
                "output": "1\n-1\n2\n10\n4"
            }
        ]
    },
    {
        "problem": "\nThis is the hard version of this problem. The only difference is that you need to also output the number of optimal sequences in this version. You must solve both versions to be able to hack.\n\nYou're given an array $a$ of length $n$, and an array $b$ of length $m$ ($b_i > b_{i+1}$ for all $1 \\le i < m$). Initially, the value of $k$ is $1$. Your aim is to make the array $a$ empty by performing one of these two operations repeatedly:\n\n  * Type $1$ \u2014 If the value of $k$ is less than $m$ and the array $a$ is not empty, you can increase the value of $k$ by $1$. This does not incur any cost.    * Type $2$ \u2014 You remove a non-empty prefix of array $a$, such that its sum does not exceed $b_k$. This incurs a cost of $m - k$. \n\nYou need to minimize the total cost of the operations to make array $a$ empty. If it's impossible to do this through any sequence of operations, output $-1$. Otherwise, output the minimum total cost of the operations, and the number of sequences of operations which yield this minimum cost modulo $10^9 + 7$.\n\nTwo sequences of operations are considered different if you choose a different type of operation at any step, or the size of the removed prefix is different at any step.\n\nInput Format:\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 1000$). The description of the test cases follows.\n\nThe first line of each test case contains two integers $n$ and $m$ ($1 \\le n, m \\le 3 \\cdot 10^5$, $\\boldsymbol{1 \\le n \\cdot m \\le 3 \\cdot 10^5}$).\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\le a_i \\le 10^9$).\n\nThe third line of each test case contains $m$ integers $b_1, b_2, \\ldots, b_m$ ($1 \\le b_i \\le 10^9$).\n\nIt is also guaranteed that $b_i > b_{i+1}$ for all $1 \\le i < m$.\n\nIt is guaranteed that the sum of $\\boldsymbol{n \\cdot m}$ over all test cases does not exceed $3 \\cdot 10^5$.\n\nOutput Format:\nFor each test case, if it's possible to make $a$ empty, then output two integers. The first should be the minimum total cost of the operations, and the second should be the number of sequences of operations which achieve this minimum cost, modulo $10^9 + 7$.\n\nIf there is no possible sequence of operations which makes $a$ empty, then output a single integer $-1$.\n\nTags:\n['binary search', 'data structures', 'dp', 'greedy', 'implementation', 'two pointers']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "5\n4 2\n9 3 4 3\n11 7\n1 2\n20\n19 18\n10 2\n2 5 2 1 10 3 2 9 9 6\n17 9\n10 11\n2 2 2 2 2 2 2 2 2 2\n20 18 16 14 12 10 8 6 4 2 1\n1 6\n10\n32 16 8 4 2 1",
                "output": "1 3\n-1\n2 11\n10 42\n4 1"
            }
        ]
    },
    {
        "problem": "\nThis is the easy version of this problem. The only difference is that you need to output the winner of the game in this version, and the number of stones in each pile are fixed. You must solve both versions to be able to hack.\n\nAlice and Bob are playing a familiar game where they take turns removing stones from $n$ piles. Initially, there are $x_i$ stones in the $i$-th pile, and it has an associated value $a_i$. A player can take $d$ stones away from the $i$-th pile if and only if both of the following conditions are met:\n\n  * $1 \\le d \\le a_i$, and    * $x \\, \\& \\, d = d$, where $x$ is the current number of stones in the $i$-th pile and $\\&$ denotes the [bitwise AND operation](https://en.wikipedia.org/wiki/Bitwise_operation#AND). \n\nThe player who cannot make a move loses, and Alice goes first.\n\nYou're given the $a_i$ and $x_i$ values for each pile, please determine who will win the game if both players play optimally.\n\nInput Format:\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 1000$). The description of the test cases follows.\n\nThe first line of each test case contains $n$ ($1 \\le n \\le 10^4$) \u2014 the number of piles.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\le a_i < 2^{30}$).\n\nThe third line of each test case contains $n$ integers $x_1, x_2, \\ldots, x_n$ ($1 \\le x_i < 2^{30}$).\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $10^4$.\n\nOutput Format:\nPrint a single line with the winner's name. If Alice wins, print \"Alice\", otherwise print \"Bob\" (without quotes).\n\nTags:\n['bitmasks', 'brute force', 'games', 'math']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "7\n2\n1 6\n10 7\n3\n10 8 15\n25 4 14\n4\n8 32 65 64\n7 45 126 94\n3\n20 40 1\n23 55 1\n5\n12345 9876 86419 8641 1\n6789 54321 7532 97532 1\n2\n20 64\n44 61\n3\n57 109 55\n69 90 85",
                "output": "Bob\nBob\nBob\nBob\nBob\nAlice\nAlice"
            }
        ]
    },
    {
        "problem": "\nThis is the hard version of this problem. The only difference is that you need to output the number of choices of games where Bob wins in this version, where the number of stones in each pile are not fixed. You must solve both versions to be able to hack.\n\nAlice and Bob are playing a familiar game where they take turns removing stones from $n$ piles. Initially, there are $x_i$ stones in the $i$-th pile, and it has an associated value $a_i$. A player can take $d$ stones away from the $i$-th pile if and only if both of the following conditions are met:\n\n  * $1 \\le d \\le a_i$, and    * $x \\, \\& \\, d = d$, where $x$ is the current number of stones in the $i$-th pile and $\\&$ denotes the [bitwise AND operation](https://en.wikipedia.org/wiki/Bitwise_operation#AND). \n\nThe player who cannot make a move loses, and Alice goes first.\n\nYou're given the $a_i$ values of each pile, but the number of stones in the $i$-th pile has not been determined yet. For the $i$-th pile, $x_i$ can be any integer between $1$ and $b_i$, inclusive. That is, you can choose an array $x_1, x_2, \\ldots, x_n$ such that the condition $1 \\le x_i \\le b_i$ is satisfied for all piles.\n\nYour task is to count the number of games where Bob wins if both players play optimally. Two games are considered different if the number of stones in any pile is different, i.e., the arrays of $x$ differ in at least one position.\n\nSince the answer can be very large, please output the result modulo $10^9 + 7$.\n\nInput Format:\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 1000$). The description of the test cases follows.\n\nThe first line of each test case contains $n$ ($1 \\le n \\le 10^4$) \u2014 the number of piles.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\le a_i < 2^{30}$).\n\nThe third line of each test case contains $n$ integers $b_1, b_2, \\ldots, b_n$ ($1 \\le b_i < 2^{30}$).\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $10^4$.\n\nOutput Format:\nOutput a single integer, the number of games where Bob wins, modulo $10^9 + 7$.\n\nTags:\n['bitmasks', 'dp', 'math']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "7\n3\n1 2 3\n3 2 2\n1\n13\n45\n5\n5 4 7 8 6\n4 4 5 5 5\n4\n6 4 8 8\n12 13 14 12\n3\n92856133 46637598 12345678\n29384774 73775896 87654321\n2\n65 12\n110 31\n4\n677810235 275091182 428565855 720629731\n74522416 889934149 3394714 230851724",
                "output": "4\n4\n0\n6552\n722019507\n541\n665443265"
            }
        ]
    },
    {
        "problem": "\nAlice is trying to meet up with the Red Queen in the countryside! Right now, Alice is at position $(0, 0)$, and the Red Queen is at position $(a, b)$. Alice can only move in the four cardinal directions (north, east, south, west).\n\nMore formally, if Alice is at the point $(x, y)$, she will do one of the following:\n\n  * go north (represented by N), moving to $(x, y+1)$;    * go east (represented by E), moving to $(x+1, y)$;    * go south (represented by S), moving to $(x, y-1)$; or    * go west (represented by W), moving to $(x-1, y)$. \n\nAlice's movements are predetermined. She has a string $s$ representing a sequence of moves that she performs from left to right. Once she reaches the end of the sequence, she repeats the same pattern of moves forever.\n\nCan you help Alice figure out if she will ever meet the Red Queen?\n\nInput Format:\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 500$). The description of the test cases follows.\n\nThe first line of each test case contains three integers $n$, $a$, $b$ ($1 \\le n$, $a$, $b \\le 10$) \u2014 the length of the string and the initial coordinates of the Red Queen.\n\nThe second line contains a string $s$ of length $n$ consisting only of the characters N, E, S, or W.\n\nOutput Format:\nFor each test case, output a single string \"YES\" or \"NO\" (without the quotes) denoting whether Alice will eventually meet the Red Queen.\n\nYou can output the answer in any case (upper or lower). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as positive responses.\n\nTags:\n['brute force', 'implementation', 'math', 'strings']\n\nTime Limit: 1000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "6\n2 2 2\nNE\n3 2 2\nNNE\n6 2 1\nNNEESW\n6 10 10\nNNEESW\n3 4 2\nNEE\n4 5 5\nNEWS",
                "output": "YES\nNO\nYES\nYES\nYES\nNO"
            }
        ]
    },
    {
        "problem": "\nAlice mixed up the words transmutation and permutation! She has an array $a$ specified via three integers $n$, $b$, $c$: the array $a$ has length $n$ and is given via $a_i = b\\cdot (i - 1) + c$ for $1\\le i\\le n$. For example, if $n=3$, $b=2$, and $c=1$, then $a=[2 \\cdot 0 + 1, 2 \\cdot 1 + 1, 2 \\cdot 2 + 1] = [1, 3, 5]$.\n\nNow, Alice really enjoys permutations of $[0, \\ldots, n-1]$$^{\\text{\u2217}}$ and would like to transform $a$ into a permutation. In one operation, Alice replaces the maximum element of $a$ with the $\\operatorname{MEX}$$^{\\text{\u2020}}$ of $a$. If there are multiple maximum elements in $a$, Alice chooses the leftmost one to replace.\n\nCan you help Alice figure out how many operations she has to do for $a$ to become a permutation for the first time? If it is impossible, you should report it.\n\n$^{\\text{\u2217}}$A permutation of length $n$ is an array consisting of $n$ distinct integers from $0$ to $n-1$ in arbitrary order. Please note, this is slightly different from the usual definition of a permutation. For example, $[1,2,0,4,3]$ is a permutation, but $[0,1,1]$ is not a permutation ($1$ appears twice in the array), and $[0,2,3]$ is also not a permutation ($n=3$ but there is $3$ in the array).\n\n$^{\\text{\u2020}}$The $\\operatorname{MEX}$ of an array is the smallest non- negative integer that does not belong to the array. For example, the $\\operatorname{MEX}$ of $[0, 3, 1, 3]$ is $2$ and the $\\operatorname{MEX}$ of $[5]$ is $0$.\n\nInput Format:\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^5$). The description of the test cases follows.\n\nThe only line of each test case contains three integers $n$, $b$, $c$ ($1\\le n\\le 10^{18}$; $0\\le b$, $c\\le 10^{18}$) \u2014 the parameters of the array.\n\nOutput Format:\nFor each test case, if the array can never become a permutation, output $-1$. Otherwise, output the minimum number of operations for the array to become a permutation.\n\nTags:\n['binary search', 'implementation', 'math']\n\nTime Limit: 1000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "7\n10 1 0\n1 2 3\n100 2 1\n3 0 1\n3 0 0\n1000000000000000000 0 0\n1000000000000000000 1000000000000000000 1000000000000000000",
                "output": "0\n1\n50\n2\n-1\n-1\n1000000000000000000"
            }
        ]
    },
    {
        "problem": "\nAlice is at the Mad Hatter's tea party! There is a long sheet cake made up of $n$ sections with tastiness values $a_1, a_2, \\ldots, a_n$. There are $m$ creatures at the tea party, excluding Alice.\n\nAlice will cut the cake into $m + 1$ pieces. Formally, she will partition the cake into $m + 1$ subarrays, where each subarray consists of some number of adjacent sections. The tastiness of a piece is the sum of tastiness of its sections. Afterwards, she will divvy these $m + 1$ pieces up among the $m$ creatures and herself (her piece can be empty). However, each of the $m$ creatures will only be happy when the tastiness of its piece is $v$ or more.\n\nAlice wants to make sure every creature is happy. Limited by this condition, she also wants to maximize the tastiness of her own piece. Can you help Alice find the maximum tastiness her piece can have? If there is no way to make sure every creature is happy, output $-1$.\n\nInput Format:\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains three integers $n, m, v$ ($1\\le m\\le n\\le 2\\cdot 10^5$; $1\\le v\\le 10^9$) \u2014 the number of sections, the number of creatures, and the creatures' minimum requirement for tastiness, respectively.\n\nThe next line contains $n$ space separated integers $a_1, a_2, \\ldots, a_n$ ($1 \\le a_i \\le 10^9$) \u2014 the tastinesses of the sections.\n\nThe sum of $n$ over all test cases does not exceed $2\\cdot 10^5$.\n\nOutput Format:\nFor each test case, output the maximum tastiness Alice can achieve for her piece, or $-1$ if there is no way to make sure every creature is happy.\n\nTags:\n['binary search', 'dp', 'greedy', 'two pointers']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "7\n6 2 1\n1 1 10 1 1 10\n6 2 2\n1 1 10 1 1 10\n6 2 3\n1 1 10 1 1 10\n6 2 10\n1 1 10 1 1 10\n6 2 11\n1 1 10 1 1 10\n6 2 12\n1 1 10 1 1 10\n6 2 12\n1 1 1 1 10 10",
                "output": "22\n12\n2\n2\n2\n0\n-1"
            }
        ]
    },
    {
        "problem": "\nAlice is playing cards with the Queen of Hearts, King of Hearts, and Jack of Hearts. There are $n$ different types of cards in their card game. Alice currently has a card of type $1$ and needs a card of type $n$ to escape Wonderland. The other players have one of each kind of card.\n\nIn this card game, Alice can trade cards with the three other players. Each player has different preferences for the $n$ types of cards, which can be described by permutations$^{\\text{\u2217}}$ $q$, $k$, and $j$ for the Queen, King, and Jack, respectively.\n\nA player values card $a$ more than card $b$ if for their permutation $p$, $p_a > p_b$. Then, this player is willing to trade card $b$ to Alice in exchange for card $a$. Alice's preferences are straightforward: she values card $a$ more than card $b$ if $a > b$, and she will also only trade according to these preferences.\n\nDetermine if Alice can trade up from card $1$ to card $n$ subject to these preferences, and if it is possible, give a possible set of trades to do it.\n\n$^{\\text{\u2217}}$A permutation of length $n$ is an array consisting of $n$ distinct integers from $1$ to $n$ in arbitrary order. For example, $[2,3,1,5,4]$ is a permutation, but $[1,2,2]$ is not a permutation ($2$ appears twice in the array), and $[1,3,4]$ is also not a permutation ($n=3$ but there is $4$ in the array).\n\nInput Format:\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains an integer $n$ ($2\\le n\\le 2\\cdot 10^5$) \u2014 the number of card types.\n\nThe next three lines contain the preferences of the Queen, King, and Jack respectively. Each of these lines contains $n$ integers $p_1, p_2, \\ldots, p_n$ ($1\\le p_i\\le n$) \u2014 a permutation corresponding to the player's preferences.\n\nThe sum of $n$ over all test cases does not exceed $2\\cdot 10^5$.\n\nOutput Format:\nFor each test case, on the first line output a single string \"YES\" or \"NO\" (without the quotes) denoting whether Alice can trade up to card $n$.\n\nIf the first line was \"YES\", then on the next line output $k$ \u2014 the number of trades Alice will make. On the next $k$ lines output space separated a character $c\\in \\\\{\\texttt{q}, \\texttt{k}, \\texttt{j}\\\\}$ and integer $x$, denoting that Alice trades with player $c$ to get card $x$. It must be the case that on the $k$'th line, $x = n$. If there are multiple solutions, print any of them.\n\nYou can output this answer in any case (upper or lower). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as positive responses. The same goes for the character $c$ denoting the player in the trade ($\\texttt{Q}, \\texttt{K}, \\texttt{J}$ will all be accepted alongside their lowercase variants).\n\nTags:\n['constructive algorithms', 'divide and conquer', 'dp', 'graphs', 'greedy', 'implementation', 'sortings', 'two pointers']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "2\n3\n1 3 2\n2 1 3\n1 2 3\n4\n2 3 1 4\n1 2 3 4\n1 4 2 3",
                "output": "YES\n2\nk 2\nq 3\nNO"
            }
        ]
    },
    {
        "problem": "\nAlice is at the bottom of the rabbit hole! The rabbit hole can be modeled as a tree$^{\\text{\u2217}}$ which has an exit at vertex $1$, and Alice starts at some vertex $v$. She wants to get out of the hole, but unfortunately, the Queen of Hearts has ordered her execution.\n\nEach minute, a fair coin is flipped. If it lands heads, Alice gets to move to an adjacent vertex of her current location, and otherwise, the Queen of Hearts gets to pull Alice to an adjacent vertex of the Queen's choosing. If Alice ever ends up on any of the non-root leaves$^{\\text{\u2020}}$ of the tree, Alice loses.\n\nAssuming both of them move optimally, compute the probability that Alice manages to escape for every single starting vertex $1\\le v\\le n$. Since these probabilities can be very small, output them modulo $998\\,244\\,353$.\n\nFormally, let $M = 998\\,244\\,353$. It can be shown that the exact answer can be expressed as an irreducible fraction $\\frac{p}{q}$, where $p$ and $q$ are integers and $q \\not \\equiv 0 \\pmod{M}$. Output the integer equal to $p \\cdot q^{-1} \\bmod M$. In other words, output such an integer $x$ that $0 \\le x < M$ and $x \\cdot q \\equiv p \\pmod{M}$.\n\n$^{\\text{\u2217}}$A tree is a connected simple graph which has $n$ vertices and $n-1$ edges.\n\n$^{\\text{\u2020}}$A leaf is a vertex that is connected to exactly one edge.\n\nInput Format:\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($2\\le n\\le 2\\cdot 10^5$) \u2014 the number of vertices in the tree.\n\nThe $i$-th of the next $n - 1$ lines contains two integers $x_i$ and $y_i$ ($1 \\le x_i, y_i \\le n$ and $x_i \\neq y_i$) \u2014 the edges of the tree. It is guaranteed that the given edges form a tree.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2\\cdot 10^5$.\n\nOutput Format:\nFor each test case, output $n$ integers on one line \u2014 the probabilities of Alice escaping starting from vertex $1, 2, \\ldots, n$. Since these probabilities can be very small, output them modulo $998\\,244\\,353$.\n\nTags:\n['combinatorics', 'dfs and similar', 'dp', 'games', 'greedy', 'math', 'probabilities', 'trees']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "2\n5\n1 2\n1 3\n2 4\n3 5\n9\n1 2\n2 3\n4 5\n5 6\n7 8\n8 9\n2 4\n5 7",
                "output": "1 499122177 499122177 0 0 \n1 499122177 0 332748118 166374059 0 443664157 720954255 0"
            }
        ]
    },
    {
        "problem": "\nNote that the memory limit is unusual.\n\nThe Cheshire Cat has a riddle for Alice: given $n$ integers $a_1, a_2, \\ldots, a_n$ and a target $m$, is there a way to insert $+$ and $\\times$ into the circles of the expression $$a_1 \\circ a_2 \\circ \\cdots \\circ a_n = m$$ to make it true? We follow the usual order of operations: $\\times$ is done before $+$.\n\nAlthough Alice is excellent at chess, she is not good at math. Please help her so she can find a way out of Wonderland!\n\nInput Format:\nEach test contains multiple test cases. The first line of input contains a single integer $t$ ($1 \\le t \\le 10^4$) \u2014 the number of test cases. The description of the test cases follows.\n\nThe first line of each test case contains two integers $n, m$ ($1\\le n\\le 2\\cdot 10^5$; $1\\le m\\le 10^4$) \u2014 the number of integers and the target, respectively.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($0\\le a_i\\le 10^4$) \u2014 the elements of the array $a$.\n\nThe sum of $n$ over all test cases does not exceed $2\\cdot 10^5$.\n\nOutput Format:\nFor each test case, output \"YES\" without quotes if it is possible to get the target by inserting $+$ or $\\times$ and \"NO\" otherwise.\n\nYou can output each letter in any case (for example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as a positive answer).\n\nTags:\n['bitmasks', 'brute force', 'dp', 'implementation']\n\nTime Limit: 3000 ms\nMemory Limit: 32 MB\n",
        "tests": [
            {
                "input": "6\n5 4\n2 1 1 1 2\n5 5\n2 1 1 1 2\n5 6\n2 1 1 1 2\n5 7\n2 1 1 1 2\n5 8\n2 1 1 1 2\n5 6\n2 0 2 2 3",
                "output": "YES\nYES\nYES\nYES\nNO\nYES"
            }
        ]
    },
    {
        "problem": "\nYou are given a positive integer $k$ and a set $S$ of all integers from $l$ to $r$ (inclusive).\n\nYou can perform the following two-step operation any number of times (possibly zero):\n\n  1. First, choose a number $x$ from the set $S$, such that there are at least $k$ multiples of $x$ in $S$ (including $x$ itself);    2. Then, remove $x$ from $S$ (note that nothing else is removed).\n\nFind the maximum possible number of operations that can be performed.\n\nInput Format:\nEach test contains multiple test cases. The first line of the input contains a single integer $t$ ($1\\le t\\le 10^4$) \u2014 the number of test cases. The description of test cases follows.\n\nThe only line of each test case contains three integers $l$, $r$, and $k$ ($1\\le l\\le r\\leq 10^9$, $1\\leq k\\le r-l+1$) \u2014 the minimum integer in $S$, the maximum integer in $S$, and the parameter $k$.\n\nOutput Format:\nFor each test case, output a single integer \u2014 the maximum possible number of operations that can be performed.\n\nTags:\n['binary search', 'greedy', 'math']\n\nTime Limit: 1000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "8\n3 9 2\n4 9 1\n7 9 2\n2 10 2\n154 220 2\n147 294 2\n998 24435 3\n1 1000000000 2",
                "output": "2\n6\n0\n4\n0\n1\n7148\n500000000"
            }
        ]
    },
    {
        "problem": "\nYou have a binary string$^{\\text{\u2217}}$ $s$ of length $n$, and Iris gives you another binary string $r$ of length $n-1$.\n\nIris is going to play a game with you. During the game, you will perform $n-1$ operations on $s$. In the $i$-th operation ($1 \\le i \\le n-1$):\n\n  * First, you choose an index $k$ such that $1\\le k\\le |s| - 1$ and $s_{k} \\neq s_{k+1}$. If it is impossible to choose such an index, you lose;    * Then, you replace $s_ks_{k+1}$ with $r_i$. Note that this decreases the length of $s$ by $1$. \n\nIf all the $n-1$ operations are performed successfully, you win.\n\nDetermine whether it is possible for you to win this game.\n\n$^{\\text{\u2217}}$A binary string is a string where each character is either $\\mathtt{0}$ or $\\mathtt{1}$.\n\nInput Format:\nEach test contains multiple test cases. The first line of the input contains a single integer $t$ ($1\\le t\\le 10^4$) \u2014 the number of test cases. The description of test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($2\\le n\\le 10^5$) \u2014 the length of $s$.\n\nThe second line contains the binary string $s$ of length $n$ ($s_i=\\mathtt{0}$ or $\\mathtt{1}$).\n\nThe third line contains the binary string $r$ of length $n-1$ ($r_i=\\mathtt{0}$ or $\\mathtt{1}$).\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $10^5$.\n\nOutput Format:\nFor each test case, print \"YES\" (without quotes) if you can win the game, and \"NO\" (without quotes) otherwise.\n\nYou can output the answer in any case (upper or lower). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as positive responses.\n\nTags:\n['games', 'greedy', 'strings']\n\nTime Limit: 1000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "6\n2\n11\n0\n2\n01\n1\n4\n1101\n001\n6\n111110\n10000\n6\n010010\n11010\n8\n10010010\n0010010",
                "output": "NO\nYES\nYES\nNO\nYES\nNO"
            }
        ]
    },
    {
        "problem": "\nHello, Codeforces Forcescode!\n\n\n\nKevin used to be a participant of Codeforces. Recently, the KDOI Team has developed a new Online Judge called Forcescode.\n\nKevin has participated in $n$ contests on Forcescode. In the $i$-th contest, his performance rating is $a_i$.\n\nNow he has hacked into the backend of Forcescode and will select an interval $[l,r]$ ($1\\le l\\le r\\le n$), then skip all of the contests in this interval. After that, his rating will be recalculated in the following way:\n\n  * Initially, his rating is $x=0$;    * For each $1\\le i\\le n$, after the $i$-th contest,      * If $l\\le i\\le r$, this contest will be skipped, and the rating will remain unchanged;      * Otherwise, his rating will be updated according to the following rules:        * If $a_i>x$, his rating $x$ will increase by $1$;        * If $a_i=x$, his rating $x$ will remain unchanged;        * If $a_i<x$, his rating $x$ will decrease by $1$. \n\nYou have to help Kevin to find his maximum possible rating after the recalculation if he chooses the interval $[l,r]$ optimally. Note that Kevin has to skip at least one contest.\n\nInput Format:\nEach test contains multiple test cases. The first line of the input contains a single integer $t$ ($1\\le t\\le 5\\cdot 10^4$) \u2014 the number of test cases. The description of test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($1\\le n\\le 3\\cdot 10^5$) \u2014 the number of contests.\n\nThe second line contains $n$ integers $a_1,a_2,\\ldots,a_n$ ($1\\le a_i\\le n$) \u2014 the performance ratings in the contests.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $3 \\cdot 10^5$.\n\nOutput Format:\nFor each test case, output a single integer \u2014 the maximum possible rating after the recalculation if Kevin chooses the interval optimally.\n\nTags:\n['binary search', 'data structures', 'dp', 'greedy']\n\nTime Limit: 2000 ms\nMemory Limit: 512 MB\n",
        "tests": [
            {
                "input": "5\n6\n1 2 3 4 5 6\n7\n1 2 1 1 1 3 4\n1\n1\n9\n9 9 8 2 4 4 3 5 3\n10\n1 2 3 4 1 3 2 1 1 10",
                "output": "5\n4\n0\n4\n5"
            }
        ]
    },
    {
        "problem": "\nYou are given an undirected graph with $n$ vertices and $m$ edges.\n\nYou can perform the following operation at most $2\\cdot \\max(n,m)$ times:\n\n  * Choose three distinct vertices $a$, $b$, and $c$, then for each of the edges $(a,b)$, $(b,c)$, and $(c,a)$, do the following:      * If the edge does not exist, add it. On the contrary, if it exists, remove it. \n\nA graph is called cool if and only if one of the following holds:\n\n  * The graph has no edges, or    * The graph is a tree. \n\nYou have to make the graph cool by performing the above operations. Note that you can use at most $2\\cdot \\max(n,m)$ operations.\n\nIt can be shown that there always exists at least one solution.\n\nInput Format:\nEach test contains multiple test cases. The first line of input contains a single integer $t$ ($1\\le t\\le 10^4$) \u2014 the number of test cases. The description of test cases follows.\n\nThe first line of each test case contains two integers $n$ and $m$ ($3\\le n\\le 10^5$, $0\\le m\\le \\min\\left(\\frac{n(n-1)}{2},2\\cdot 10^5\\right)$) \u2014 the number of vertices and the number of edges.\n\nThen $m$ lines follow, the $i$-th line contains two integers $u_i$ and $v_i$ ($1\\le u_i,v_i\\le n$) \u2014 the two nodes that the $i$-th edge connects.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $10^5$, and the sum of $m$ over all test cases does not exceed $2\\cdot 10^5$.\n\nIt is guaranteed that there are no self-loops or multiple-edges in the given graph.\n\nOutput Format:\nFor each test case, in the first line output an integer $k$ ($0\\le k\\le 2\\cdot \\max(n, m)$) \u2014 the number of operations.\n\nThen output $k$ lines, the $i$-th line containing three distinct integers $a$, $b$, and $c$ ($1\\le a,b,c\\le n$) \u2014 the three integers you choose in the $i$-th operation.\n\nIf there are multiple solutions, you can output any of them.\n\nTags:\n['constructive algorithms', 'data structures', 'dfs and similar', 'graphs', 'trees']\n\nTime Limit: 3000 ms\nMemory Limit: 512 MB\n",
        "tests": [
            {
                "input": "5\n3 0\n3 1\n1 2\n3 2\n1 2\n2 3\n3 3\n1 2\n2 3\n3 1\n6 6\n1 2\n1 6\n4 5\n3 4\n4 6\n3 6",
                "output": "0\n1\n1 2 3\n0\n1\n1 2 3\n3\n1 3 6\n2 4 5\n3 4 6"
            }
        ]
    },
    {
        "problem": "\nFor two integers $x$ and $y$ ($x,y\\ge 2$), we will say that $x$ is a generator of $y$ if and only if $x$ can be transformed to $y$ by performing the following operation some number of times (possibly zero):\n\n  * Choose a divisor $d$ ($d\\ge 2$) of $x$, then increase $x$ by $d$. \n\nFor example,\n\n  * $3$ is a generator of $8$ since we can perform the following operations: $3 \\xrightarrow{d = 3} 6 \\xrightarrow{d = 2} 8$;    * $4$ is a generator of $10$ since we can perform the following operations: $4 \\xrightarrow{d = 4} 8 \\xrightarrow{d = 2} 10$;    * $5$ is not a generator of $6$ since we cannot transform $5$ into $6$ with the operation above. \n\nNow, Kevin gives you an array $a$ consisting of $n$ pairwise distinct integers ($a_i\\ge 2$).\n\nYou have to find an integer $x\\ge 2$ such that for each $1\\le i\\le n$, $x$ is a generator of $a_i$, or determine that such an integer does not exist.\n\nInput Format:\nEach test contains multiple test cases. The first line of the input contains a single integer $t$ ($1\\le t\\le 10^4$) \u2014 the number of test cases. The description of test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($1\\le n\\le 10^5$) \u2014 the length of the array $a$.\n\nThe second line contains $n$ integers $a_1,a_2,\\ldots,a_n$ ($2\\le a_i\\le 4\\cdot 10^5$) \u2014 the elements in the array $a$. It is guaranteed that the elements are pairwise distinct.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $10^5$.\n\nOutput Format:\nFor each test case, output a single integer $x$ \u2014 the integer you found. Print $-1$ if there does not exist a valid $x$.\n\nIf there are multiple answers, you may output any of them.\n\nTags:\n['brute force', 'math', 'number theory']\n\nTime Limit: 2000 ms\nMemory Limit: 512 MB\n",
        "tests": [
            {
                "input": "4\n3\n8 9 10\n4\n2 3 4 5\n2\n147 154\n5\n3 6 8 25 100000",
                "output": "2\n-1\n7\n3"
            }
        ]
    },
    {
        "problem": "\nYou are given a cycle with $n$ vertices numbered from $0$ to $n-1$. For each $0\\le i\\le n-1$, there is an undirected edge between vertex $i$ and vertex $((i+1)\\bmod n)$ with the color $c_i$ ($c_i=\\texttt{R}$ or $\\texttt{B}$).\n\nDetermine whether the following condition holds for every pair of vertices $(i,j)$ ($0\\le i<j\\le n-1$):\n\n  * There exists a palindrome route between vertex $i$ and vertex $j$. Note that the route may not be simple. Formally, there must exist a sequence $p=[p_0,p_1,p_2,\\ldots,p_m]$ such that:     * $p_0=i$, $p_m=j$;      * For each $0\\leq x\\le m-1$, either $p_{x+1}=(p_x+1)\\bmod n$ or $p_{x+1}=(p_{x}-1)\\bmod n$;      * For each $0\\le x\\le y\\le m-1$ satisfying $x+y=m-1$, the edge between $p_x$ and $p_{x+1}$ has the same color as the edge between $p_y$ and $p_{y+1}$.\n\nInput Format:\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^5$) \u2014 the number of test cases. The description of the test cases follows.\n\nThe first line of each test case contains an integer $n$ ($3\\leq n\\leq10^6$) \u2014 the number of vertices in the cycle.\n\nThe second line contains a string $c$ of length $n$ ($c_i=\\texttt{R}$ or $\\texttt{B}$) \u2014 the color of each edge.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $10^6$.\n\nOutput Format:\nFor each test case, print \"YES\" (without quotes) if there is a palindrome route between any pair of nodes, and \"NO\" (without quotes) otherwise.\n\nYou can output the answer in any case (upper or lower). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as positive responses.\n\nTags:\n['constructive algorithms', 'greedy']\n\nTime Limit: 2000 ms\nMemory Limit: 512 MB\n",
        "tests": [
            {
                "input": "7\n5\nRRRRR\n5\nRRRRB\n5\nRBBRB\n6\nRBRBRB\n6\nRRBBRB\n5\nRBRBR\n12\nRRBRRBRRBRRB",
                "output": "YES\nYES\nYES\nNO\nNO\nYES\nNO"
            }
        ]
    },
    {
        "problem": "\nThere is an array $a$ consisting of $n$ integers. Initially, all elements of $a$ are equal to $0$.\n\nKevin can perform several operations on the array. Each operation is one of the following two types:\n\n  * Prefix addition \u2014 Kevin first selects an index $x$ ($1\\le x\\le n$), and then for each $1\\le j\\le x$, increases $a_j$ by $1$;    * Suffix addition \u2014 Kevin first selects an index $x$ ($1\\le x\\le n$), and then for each $x\\le j\\le n$, increases $a_j$ by $1$.\n\nIn the country of KDOI, people think that the integer $v$ is balanced. Thus, Iris gives Kevin an array $c$ consisting of $n$ integers and defines the beauty of the array $a$ as follows:\n\n  * Initially, set $b=0$;    * For each $1\\le i\\le n$, if $a_i=v$, add $c_i$ to $b$;    * The beauty of $a$ is the final value of $b$.\n\nKevin wants to maximize the beauty of $a$ after all the operations. However, he had already performed $m$ operations when he was sleepy. Now, he can perform an arbitrary number (possibly zero) of new operations.\n\nYou have to help Kevin find the maximum possible beauty if he optimally performs the new operations.\n\nHowever, to make sure that you are not just rolling the dice, Kevin gives you an integer $V$, and you need to solve the problem for each $1\\le v\\le V$.\n\nInput Format:\nEach test contains multiple test cases. The first line of the input contains a single integer $t$ ($1\\le t\\le 1000$) \u2014 the number of test cases. The description of test cases follows.\n\nThe first line of each test case contains three integers $n$, $m$, and $V$ ($1\\le n, m\\le 2\\cdot 10^5$, $1\\le V\\le 2000$) \u2014 the length of the array $a$, the number of initial operations, and the number that Kevin gives you.\n\nThe second line contains $n$ integers $c_1, c_2, \\ldots, c_n$ ($1\\le c_i\\le 10^9$) \u2014 the elements in the array $c$.\n\nThen $m$ lines follow, the $i$-th line containing a character $op$ and an integer $x$ ($op=\\mathtt{L}$ or $\\mathtt{R}$, $1\\le x\\le n$) \u2014 the type of the $i$-th operation and the selected index.\n\n  * If $op=\\mathtt{L}$, this operation is a prefix addition on index $x$;    * If $op=\\mathtt{R}$, this operation is a suffix addition on index $x$. \n\nIt is guaranteed that:\n\n  * the sum of $n$ over all test cases does not exceed $2\\cdot 10^5$;    * the sum of $m$ over all test cases does not exceed $2\\cdot 10^5$;    * the sum of $V^2$ over all test cases does not exceed $4\\cdot 10^6$.\n\nOutput Format:\nFor each test case, output $V$ integers in a single line, the $i$-th integer denoting the maximum possible beauty after Kevin performs some new operations when $v=i$.\n\nTags:\n['data structures', 'dp']\n\nTime Limit: 3000 ms\nMemory Limit: 1024 MB\n",
        "tests": [
            {
                "input": "5\n3 3 2\n1 2 4\nL 3\nR 3\nL 1\n3 3 2\n5 1 4\nL 3\nR 3\nL 1\n5 4 5\n1 1 1 1 1\nL 3\nR 2\nL 5\nL 4\n10 12 9\n10 9 8 7 6 5 4 3 2 1\nL 2\nL 4\nR 4\nR 4\nL 6\nR 8\nL 3\nL 2\nR 1\nR 10\nL 8\nL 1\n1 1 4\n1000000000\nL 1",
                "output": "2 6\n1 9\n0 1 3 5 5\n0 0 0 6 25 32 35 44 51\n1000000000 1000000000 1000000000 1000000000"
            }
        ]
    },
    {
        "problem": "\nGiven is an undirected graph with $n$ vertices and $m$ edges. Each edge connects two vertices $(u, v)$ and has a probability of $\\frac{p}{q}$ of appearing each day.\n\nInitially, vertex $1$ has a message. At the end of the day, a vertex has a message if and only if itself or at least one of the vertices adjacent to it had the message the day before. Note that each day, each edge chooses its appearance independently.\n\nCalculate the expected number of days before all the vertices have the message, modulo $998\\,244\\,353$.\n\nInput Format:\nThe first line contains two integers $n$ and $m$ ($1\\leq n\\leq 21$, $n-1\\leq m\\leq\\frac{n(n-1)}{2}$).\n\nThen $m$ lines follow, each containing four integers $u$, $v$, $p$, and $q$ ($1\\leq u\\neq v\\leq n$, $1\\leq p<q<998\\,244\\,353$, $\\gcd(p,q)=1$) \u2014 there is an undirected edge between $u$ and $v$, and it has a probability of appearance of $\\frac{p}{q}$ each day.\n\nIt is guaranteed that there are no self-loops or multiple-edges in the graph and that the graph is connected if all of the edges appear.\n\nAdditional constraint in the input: Let $g_{i,j}$ be the probability of appearance of the edge between $i$ and $j$ ($g_{i,j}=0$ if there is no edge between $i$ and $j$). It is guaranteed that for any $S\\subseteq\\\\{1,2,\\ldots,n\\\\}$ ($|S|\\ge 1$), $$ \\prod_{i\\in S}\\left(\\prod_{j\\in\\\\{1,2,\\ldots,n\\\\}\\setminus S}(1-g_{i,j})\\right)\\not\\equiv1\\pmod{998\\,244\\,353}. $$\n\nOutput Format:\nPrint a single integer in the only line of the output \u2014 the expected number of days, modulo $998\\,244\\,353$.\n\nFormally, let $M = 998\\,244\\,353$. It can be shown that the exact answer can be expressed as an irreducible fraction $\\frac{p}{q}$, where $p$ and $q$ are integers and $q \\not \\equiv 0 \\pmod{M}$. Output the integer equal to $p \\cdot q^{-1} \\bmod M$. In other words, output such an integer $x$ that $0 \\le x < M$ and $x \\cdot q \\equiv p \\pmod{M}$.\n\nTags:\n['bitmasks', 'combinatorics', 'dp']\n\nTime Limit: 12000 ms\nMemory Limit: 1024 MB\n",
        "tests": [
            {
                "input": "2 1\n1 2 1 10",
                "output": "10"
            },
            {
                "input": "3 3\n1 2 1 2\n1 3 1 2\n2 3 1 2",
                "output": "887328316"
            },
            {
                "input": "1 0",
                "output": "0"
            },
            {
                "input": "5 8\n1 2 1 11\n1 3 2 11\n1 4 3 11\n1 5 4 11\n2 4 5 11\n2 5 6 11\n3 4 7 11\n4 5 8 11",
                "output": "469993557"
            },
            {
                "input": "21 22\n1 2 3 4\n2 3 4 5\n3 4 5 6\n5 6 7 8\n6 7 8 9\n7 8 9 10\n8 9 2 3\n9 10 3 4\n10 11 4 5\n11 12 5 6\n12 13 6 7\n13 14 7 8\n14 15 8 9\n15 16 9 10\n16 17 2 3\n17 18 3 4\n18 19 4 5\n19 20 5 6\n20 21 6 7\n1 10 100 1001\n15 4 147 220\n4 11 1 998244352",
                "output": "299529765"
            }
        ]
    },
    {
        "problem": "\nKevin has recently learned the definition of variance. For an array $a$ of length $n$, the variance of $a$ is defined as follows:\n\n  * Let $x=\\dfrac{1}{n}\\displaystyle\\sum_{i=1}^n a_i$, i.e., $x$ is the mean of the array $a$;    * Then, the variance of $a$ is $$ V(a)=\\frac{1}{n}\\sum_{i=1}^n(a_i-x)^2. $$ \n\nNow, Kevin gives you an array $a$ consisting of $n$ integers, as well as an integer $k$. You can perform the following operation on $a$:\n\n  * Select an interval $[l,r]$ ($1\\le l\\le r\\le n$), then for each $l\\le i\\le r$, increase $a_i$ by $k$. \n\nFor each $1\\le p\\le m$, you have to find the minimum possible variance of $a$ after exactly $p$ operations are performed, independently for each $p$.\n\nFor simplicity, you only need to output the answers multiplied by $n^2$. It can be proven that the results are always integers.\n\nInput Format:\nEach test contains multiple test cases. The first line of the input contains a single integer $t$ ($1\\le t\\le 100$) \u2014 the number of test cases. The description of test cases follows.\n\nThe first line of each test case contains three integers $n$, $m$, and $k$ ($1\\le n,m\\le 5000$, $\\color{red}{n\\cdot m\\le 2\\cdot 10^4}$, $1\\le k\\le 10^5$) \u2014 the length of the array $a$, the maximum number of operations, and the number you add to $a_i$ each time, respectively.\n\nThe second line contains $n$ integers $a_1,a_2,\\ldots, a_n$ ($1\\le a_i\\le 10^5$) \u2014 the elements of the array $a$.\n\nIt is guaranteed that the sum of $n\\cdot m$ over all tests does not exceed $2\\cdot 10^4$.\n\nOutput Format:\nFor each test case, output $m$ integers in a single line, the $p$-th integer denoting the minimum possible variance of $a$ when exactly $p$ operations are performed, multiplied by $n^2$.\n\nTags:\n['flows', 'graphs', 'greedy']\n\nTime Limit: 6000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "9\n3 2 1\n1 2 2\n3 2 2\n1 2 2\n10 2 1\n10 1 1 1 1 10 1 1 1 1\n6 8 2\n1 1 4 5 1 3\n8 8 7\n20 43 24 2 4 3 20 43\n8 8 3\n20 43 24 2 4 3 20 43\n10 12 1\n5 3 3 5 4 1 8 1 1 1\n13 10 100000\n1 2 3 4 5 6 7 8 9 10 11 5 4\n10 5 10000\n2308 9982 4435 3310 100000 9 7 8100 1919 100000",
                "output": "0 0\n2 2\n1161 1024\n53 21 21 5 5 5 5 5\n10608 6912 4448 3104 1991 1312 535 304\n13248 11184 9375 7815 6447 5319 4383 3687\n385 316 269 224 181 156 124 101 80 56 41 29\n1486 1486 1486 1486 1486 1486 1486 1486 1486 1486\n134618047140 119919447140 107020847140 93922247140 82623647140"
            }
        ]
    },
    {
        "problem": "\nWhile exploring the jungle, you have bumped into a rare orangutan with a bow tie! You shake hands with the orangutan and offer him some food and water. In return...\n\nThe orangutan has gifted you an array $a$ of length $n$. Using $a$, you will construct two arrays $b$ and $c$, both containing $n$ elements, in the following manner:\n\n  * $b_i = \\min(a_1, a_2, \\ldots, a_i)$ for each $1 \\leq i \\leq n$.    * $c_i = \\max(a_1, a_2, \\ldots, a_i)$ for each $1 \\leq i \\leq n$. \n\nDefine the score of $a$ as $\\sum_{i=1}^n c_i - b_i$ (i.e. the sum of $c_i - b_i$ over all $1 \\leq i \\leq n$). Before you calculate the score, you can shuffle the elements of $a$ however you want.\n\nFind the maximum score that you can get if you shuffle the elements of $a$ optimally.\n\nInput Format:\nThe first line contains $t$ ($1 \\leq t \\leq 100$) \u2014 the number of test cases.\n\nThe first line of each test case contains an integer $n$ ($1 \\leq n \\leq 1000$) \u2014 the number of elements in $a$.\n\nThe following line contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\leq a_i \\leq 1000$) \u2014 the elements of the array $a$.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $1000$.\n\nOutput Format:\nFor each test case, output the maximum score that you can get.\n\nTags:\n['constructive algorithms', 'greedy', 'math', 'sortings']\n\nTime Limit: 1000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "3\n1\n69\n3\n7 6 5\n5\n1 1 1 2 2",
                "output": "0\n4\n4"
            }
        ]
    },
    {
        "problem": "\nFor an arbitrary binary string $t$$^{\\text{\u2217}}$, let $f(t)$ be the number of non-empty subsequences$^{\\text{\u2020}}$ of $t$ that contain only $\\mathtt{0}$, and let $g(t)$ be the number of non-empty subsequences of $t$ that contain at least one $\\mathtt{1}$.\n\nNote that for $f(t)$ and for $g(t)$, each subsequence is counted as many times as it appears in $t$. E.g., $f(\\mathtt{000}) = 7, g(\\mathtt{100}) = 4$.\n\nWe define the oneness of the binary string $t$ to be $|f(t)-g(t)|$, where for an arbitrary integer $z$, $|z|$ represents the absolute value of $z$.\n\nYou are given a positive integer $n$. Find a binary string $s$ of length $n$ such that its oneness is as small as possible. If there are multiple strings, you can print any of them.\n\n$^{\\text{\u2217}}$A binary string is a string that only consists of characters $\\texttt{0}$ and $\\texttt{1}$.\n\n$^{\\text{\u2020}}$A sequence $a$ is a subsequence of a sequence $b$ if $a$ can be obtained from $b$ by the deletion of several (possibly, zero or all) elements. For example, subsequences of $\\mathtt{1011101}$ are $\\mathtt{0}$, $\\mathtt{1}$, $\\mathtt{11111}$, $\\mathtt{0111}$, but not $\\mathtt{000}$ nor $\\mathtt{11100}$.\n\nInput Format:\nThe first line contains an integer $t$ ($1 \\leq t \\leq 10^4$) \u2014 the number of test cases.\n\nThe only line of each test case contains an integer $n$ ($1 \\leq n \\leq 2\\cdot10^5$) \u2014 the length of $s$.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2\\cdot10^5$.\n\nOutput Format:\nFor each test case, output $s$ on a new line. If multiple answers exist, output any.\n\nTags:\n['combinatorics', 'constructive algorithms', 'games', 'math']\n\nTime Limit: 1500 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "3\n1\n2\n3",
                "output": "0\n01\n010"
            }
        ]
    },
    {
        "problem": "\nAlice and Bob are playing a game. There is a list of $n$ booleans, each of which is either true or false, given as a binary string $^{\\text{\u2217}}$ of length $n$ (where $\\texttt{1}$ represents true, and $\\texttt{0}$ represents false). Initially, there are no operators between the booleans.\n\nAlice and Bob will take alternate turns placing and or or between the booleans, with Alice going first. Thus, the game will consist of $n-1$ turns since there are $n$ booleans. Alice aims for the final statement to evaluate to true, while Bob aims for it to evaluate to false. Given the list of boolean values, determine whether Alice will win if both players play optimally.\n\nTo evaluate the final expression, repeatedly perform the following steps until the statement consists of a single true or false:\n\n  * If the statement contains an and operator, choose any one and replace the subexpression surrounding it with its evaluation.    * Otherwise, the statement contains an or operator. Choose any one and replace the subexpression surrounding the or with its evaluation. \n\nFor example, the expression true or false and false is evaluated as true or (false and false) $=$ true or false $=$ true. It can be shown that the result of any compound statement is unique.\n\n$^{\\text{\u2217}}$A binary string is a string that only consists of characters $\\texttt{0}$ and $\\texttt{1}$\n\nInput Format:\nThe first line contains $t$ ($1 \\leq t \\leq 10^4$) \u2014 the number of test cases.\n\nThe first line of each test case contains an integer $n$ ($2 \\leq n \\leq 2 \\cdot 10^5$) \u2014 the length of the string.\n\nThe second line contains a binary string of length $n$, consisting of characters $\\texttt{0}$ and $\\texttt{1}$ \u2014 the list of boolean values.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\nOutput Format:\nFor each testcase, output \"YES\" (without quotes) if Alice wins, and \"NO\" (without quotes) otherwise.\n\nYou can output \"YES\" and \"NO\" in any case (for example, strings \"yES\", \"yes\" and \"Yes\" will be recognized as a positive response).\n\nTags:\n['brute force', 'games', 'greedy']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "5\n2\n11\n3\n010\n12\n101111111100\n10\n0111111011\n8\n01000010",
                "output": "YES\nNO\nYES\nYES\nNO"
            }
        ]
    },
    {
        "problem": "\nQED is given a permutation$^{\\text{\u2217}}$ $p$ of length $n$. He also has a string $s$ of length $n$ containing only characters $\\texttt{L}$ and $\\texttt{R}$. QED only likes permutations that are sorted in non-decreasing order. To sort $p$, he can select any of the following operations and perform them any number of times:\n\n  * Choose an index $i$ such that $s_i = \\texttt{L}$. Then, swap $p_i$ and $p_{i-1}$. It is guaranteed that $s_1 \\neq \\texttt{L}$.    * Choose an index $i$ such that $s_i = \\texttt{R}$. Then, swap $p_i$ and $p_{i+1}$. It is guaranteed that $s_n \\neq \\texttt{R}$. \n\nHe is also given $q$ queries. In each query, he selects an index $i$ and changes $s_i$ from $\\texttt{L}$ to $\\texttt{R}$ (or from $\\texttt{R}$ to $\\texttt{L}$). Note that the changes are persistent.\n\nAfter each query, he asks you if it is possible to sort $p$ in non- decreasing order by performing the aforementioned operations any number of times. Note that before answering each query, the permutation $p$ is reset to its original form.\n\n$^{\\text{\u2217}}$A permutation of length $n$ is an array consisting of $n$ distinct integers from $1$ to $n$ in arbitrary order. For example, $[2,3,1,5,4]$ is a permutation, but $[1,2,2]$ is not a permutation ($2$ appears twice in the array), and $[1,3,4]$ is also not a permutation ($n=3$ but there is $4$ in the array).\n\nInput Format:\nThe first line contains $t$ ($1 \\leq t \\leq 10^4$) \u2014 the number of test cases.\n\nThe first line of each test case contains two integers $n$ and $q$ ($3 \\leq n \\leq 2 \\cdot 10^5$, $1 \\leq q \\leq 2 \\cdot 10^5$) \u2013 the length of the permutation and the number of queries.\n\nThe following line contains $n$ integers $p_1, p_2, \\ldots, p_n$ ($1 \\leq p_i \\leq n$, $p$ is a permutation).\n\nThe following line contains $n$ characters $s_1s_2 \\ldots s_n$. It is guaranteed that $s_i$ is either $\\texttt{L}$ or $\\texttt{R}$, $s_1 = \\texttt{R}$, and $s_n = \\texttt{L}$.\n\nThe following $q$ lines contain an integer $i$ ($2 \\leq i \\leq n-1$), denoting that $s_i$ is changed from $\\texttt{L}$ to $\\texttt{R}$ (or from $\\texttt{R}$ to $\\texttt{L}$).\n\nIt is guaranteed that the sum of $n$ and $q$ over all test cases does not exceed $2 \\cdot 10^5$.\n\nOutput Format:\nFor each query, output \"YES\" (without quotes) if it is possible, and \"NO\" (without quotes) otherwise.\n\nYou can output \"YES\" and \"NO\" in any case (for example, strings \"yES\", \"yes\" and \"Yes\" will be recognized as a positive response).\n\nTags:\n['data structures', 'implementation', 'sortings']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "3\n5 3\n1 4 2 5 3\nRLRLL\n2\n4\n3\n8 5\n1 5 2 4 8 3 6 7\nRRLLRRRL\n4\n3\n5\n3\n4\n6 2\n1 2 3 4 5 6\nRLRLRL\n4\n5",
                "output": "YES\nYES\nNO\nNO\nYES\nNO\nNO\nNO\nYES\nYES"
            }
        ]
    },
    {
        "problem": "\nSuppose we partition the elements of an array $b$ into any number $k$ of non-empty multisets $S_1, S_2, \\ldots, S_k$, where $k$ is an arbitrary positive integer. Define the score of $b$ as the maximum value of $\\operatorname{MEX}(S_1)$$^{\\text{\u2217}}$$ + \\operatorname{MEX}(S_2) + \\ldots + \\operatorname{MEX}(S_k)$ over all possible partitions of $b$ for any integer $k$.\n\nEnvy is given an array $a$ of size $n$. Since he knows that calculating the score of $a$ is too easy for you, he instead asks you to calculate the sum of scores of all $2^n - 1$ non-empty subsequences of $a$.$^{\\text{\u2020}}$ Since this answer may be large, please output it modulo $998\\,244\\,353$.\n\n$^{\\text{\u2217}}$$\\operatorname{MEX}$ of a collection of integers $c_1, c_2, \\ldots, c_k$ is defined as the smallest non-negative integer $x$ that does not occur in the collection $c$. For example, $\\operatorname{MEX}([0,1,2,2]) = 3$ and $\\operatorname{MEX}([1,2,2]) = 0$\n\n$^{\\text{\u2020}}$A sequence $x$ is a subsequence of a sequence $y$ if $x$ can be obtained from $y$ by deleting several (possibly, zero or all) elements.\n\nInput Format:\nThe first line contains an integer $t$ ($1 \\leq t \\leq 10^4$) \u2014 the number of test cases.\n\nThe first line of each test case contains an integer $n$ ($1 \\leq n \\leq 2 \\cdot 10^5$) \u2014 the length of $a$.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($0 \\leq a_i < n$) \u2014 the elements of the array $a$.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\nOutput Format:\nFor each test case, output the answer, modulo $998\\,244\\,353$.\n\nTags:\n['combinatorics', 'data structures', 'dp', 'greedy', 'implementation', 'math']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "4\n3\n0 0 1\n4\n0 0 1 1\n5\n0 0 1 2 2\n4\n1 1 1 1",
                "output": "11\n26\n53\n0"
            }
        ]
    },
    {
        "problem": "\nSuppose you have an array $b$. Initially, you also have a set $S$ that contains all distinct elements of $b$. The array $b$ is called orangutan-approved if it can be emptied by repeatedly performing the following operation:\n\n  * In one operation, select indices $l$ and $r$ ($1 \\leq l \\leq r \\leq |b|$) such that $v = b_l = b_{l+1} = \\ldots = b_r$ and $v$ is present in $S$. Remove $v$ from $S$, and simultaneously remove all $b_i$ such that $l \\leq i \\leq r$. Then, reindex the elements $b_{r+1}, b_{r+2}, \\ldots$ as $b_l, b_{l+1}, \\ldots$ accordingly. \n\nYou are given an array $a$ of length $n$ and $q$ queries.\n\nEach query consists of two indices $l$ and $r$ ($1 \\le l \\le r \\le n$), and you need to determine whether or not the subarray $a_{l}, a_{l+1}, \\ldots, a_r$ is orangutan-approved.\n\nInput Format:\nThe first line contains $t$ ($1 \\leq t \\leq 10^4$) \u2014 the number of test cases.\n\nThe first line of each test case contains integers $n$ and $q$ ($1 \\leq n,q \\leq 2 \\cdot 10^5$) \u2014 the size of $a$ and the number of queries, respectively.\n\nThe following line contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\leq a_i \\leq n$) \u2014 the elements of the array $a$.\n\nThe following $q$ lines contain two integers $l$ and $r$ \u2014 the endpoints of the subarray for each query ($1 \\leq l \\leq r \\leq n$).\n\nIt is guaranteed that the sum of $n$ and $q$ over all test cases does not exceed $2 \\cdot 10^5$.\n\nOutput Format:\nFor each query, output \"YES\" (without quotes) if the subarray from $l$ to $r$ is orangutan-approved, and \"NO\" (without quotes) otherwise.\n\nYou can output \"YES\" and \"NO\" in any case (for example, strings \"yES\", \"yes\" and \"Yes\" will be recognized as a positive response).\n\nTags:\n['binary search', 'data structures', 'dp', 'greedy', 'implementation', 'two pointers']\n\nTime Limit: 3000 ms\nMemory Limit: 512 MB\n",
        "tests": [
            {
                "input": "3\n4 2\n1 2 2 1\n1 4\n1 3\n5 3\n1 2 1 2 1\n2 5\n3 5\n1 3\n8 4\n1 2 3 2 1 3 2 3\n1 5\n2 8\n3 5\n6 8",
                "output": "YES\nYES\nNO\nYES\nYES\nYES\nNO\nYES\nYES"
            }
        ]
    },
    {
        "problem": "\nThis is the easy version of the problem. In this version, $n \\leq 5000$. You can only make hacks if both versions of the problem are solved.\n\nOrangutans are powerful beings\u2014so powerful that they only need $1$ unit of time to destroy every vulnerable planet in the universe!\n\nThere are $n$ planets in the universe. Each planet has an interval of vulnerability $[l, r]$, during which it will be exposed to destruction by orangutans. Orangutans can also expand the interval of vulnerability of any planet by $1$ unit.\n\nSpecifically, suppose the expansion is performed on planet $p$ with interval of vulnerability $[l_p, r_p]$. Then, the resulting interval of vulnerability may be either $[l_p - 1, r_p]$ or $[l_p, r_p + 1]$.\n\nGiven a set of planets, orangutans can destroy all planets if the intervals of vulnerability of all planets in the set intersect at least one common point. Let the score of such a set denote the minimum number of expansions that must be performed.\n\nOrangutans are interested in the sum of scores of all non-empty subsets of the planets in the universe. As the answer can be large, output it modulo $998\\,244\\,353$.\n\nInput Format:\nThe first line contains an integer $t$ ($1 \\leq t \\leq 1000$) \u2014 the number of test cases.\n\nThe first line of each test case contains an integer $n$ ($1 \\leq n \\leq 5000$) \u2014 the number of planets in the universe.\n\nThe following $n$ lines contain two integers $l_i$ and $r_i$ ($1 \\leq l_i \\leq r_i \\leq n$) \u2014 the initial interval of vulnerability of the $i$-th planet.\n\nIt is guaranteed that the sum of $n$ does not exceed $5000$ over all test cases.\n\nOutput Format:\nFor each test case, output an integer \u2014 the sum of scores to destroy all non- empty subsets of the planets in the universe, modulo $998\\,244\\,353$.\n\nTags:\n['combinatorics', 'greedy', 'math']\n\nTime Limit: 4000 ms\nMemory Limit: 512 MB\n",
        "tests": [
            {
                "input": "3\n3\n1 1\n2 3\n3 3\n4\n1 4\n2 3\n2 4\n1 1\n5\n1 2\n2 3\n3 4\n4 5\n1 5",
                "output": "5\n6\n24"
            }
        ]
    },
    {
        "problem": "\nThis is the hard version of the problem. In this version, $n \\leq 10^6$. You can only make hacks if both versions of the problem are solved.\n\nOrangutans are powerful beings\u2014so powerful that they only need $1$ unit of time to destroy every vulnerable planet in the universe!\n\nThere are $n$ planets in the universe. Each planet has an interval of vulnerability $[l, r]$, during which it will be exposed to destruction by orangutans. Orangutans can also expand the interval of vulnerability of any planet by $1$ unit.\n\nSpecifically, suppose the expansion is performed on planet $p$ with interval of vulnerability $[l_p, r_p]$. Then, the resulting interval of vulnerability may be either $[l_p - 1, r_p]$ or $[l_p, r_p + 1]$.\n\nGiven a set of planets, orangutans can destroy all planets if the intervals of vulnerability of all planets in the set intersect at least one common point. Let the score of such a set denote the minimum number of expansions that must be performed.\n\nOrangutans are interested in the sum of scores of all non-empty subsets of the planets in the universe. As the answer can be large, output it modulo $998\\,244\\,353$.\n\nInput Format:\nThe first line contains an integer $t$ ($1 \\leq t \\leq 10^4$) \u2014 the number of test cases.\n\nThe first line of each test case contains an integer $n$ ($1 \\leq n \\leq 10^6$) \u2014 the number of planets in the universe.\n\nThe following $n$ lines contain two integers $l_i$ and $r_i$ ($1 \\leq l_i \\leq r_i \\leq n$) \u2014 the initial interval of vulnerability of the $i$-th planet.\n\nIt is guaranteed that the sum of $n$ does not exceed $10^6$ over all test cases.\n\nOutput Format:\nFor each test case, output an integer \u2014 the sum of scores to destroy all non- empty subsets of the planets in the universe, modulo $998\\,244\\,353$.\n\nTags:\n['combinatorics', 'math']\n\nTime Limit: 4000 ms\nMemory Limit: 512 MB\n",
        "tests": [
            {
                "input": "3\n3\n1 1\n2 3\n3 3\n4\n1 4\n2 3\n2 4\n1 1\n5\n1 2\n2 3\n3 4\n4 5\n1 5",
                "output": "5\n6\n24"
            }
        ]
    },
    {
        "problem": "\nAlice has just crafted a circuit with $n$ lights and $2n$ switches. Each component (a light or a switch) has two states: on or off. The lights and switches are arranged in a way that:\n\n  * Each light is connected to exactly two switches.    * Each switch is connected to exactly one light. It's unknown which light each switch is connected to.    * When all switches are off, all lights are also off.    * If a switch is toggled (from on to off, or vice versa), the state of the light connected to it will also toggle. \n\nAlice brings the circuit, which shows only the states of the $2n$ switches, to her sister Iris and gives her a riddle: what is the minimum and maximum number of lights that can be turned on?\n\nKnowing her little sister's antics too well, Iris takes no more than a second to give Alice a correct answer. Can you do the same?\n\nInput Format:\nEach test consists of multiple test cases. The first line contains a single integer $t$ ($1 \\le t \\le 500$) \u2014 the number of test cases. The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($1 \\le n \\le 50$) \u2014 the number of lights in the circuit.\n\nThe second line of each test case contains $2n$ integers $a_1, a_2, \\ldots, a_{2n}$ ($0 \\le a_i \\le 1$) \u2014 the states of the switches in the circuit. $a_i = 0$ means the $i$-th switch is off, and $a_i = 1$ means the $i$-th switch is on.\n\nOutput Format:\nFor each test case, output two integers \u2014 the minimum and maximum number of lights, respectively, that can be turned on.\n\nTags:\n['greedy', 'implementation', 'math', 'number theory']\n\nTime Limit: 1000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "5\n1\n0 0\n1\n0 1\n1\n1 1\n3\n0 0 1 0 1 0\n3\n0 1 1 1 0 0",
                "output": "0 0\n1 1\n0 0\n0 2\n1 3"
            }
        ]
    },
    {
        "problem": "\nYou are given an array $a = [1, 2, \\ldots, n]$, where $n$ is odd, and an integer $k$.\n\nYour task is to choose an odd positive integer $m$ and to split $a$ into $m$ subarrays$^{\\dagger}$ $b_1, b_2, \\ldots, b_m$ such that:\n\n  * Each element of the array $a$ belongs to exactly one subarray.    * For all $1 \\le i \\le m$, $|b_i|$ is odd, i.e., the length of each subarray is odd.    * $\\operatorname{median}([\\operatorname{median}(b_1), \\operatorname{median}(b_2), \\ldots, \\operatorname{median}(b_m)]) = k$, i.e., the median$^{\\ddagger}$ of the array of medians of all subarrays must equal $k$. $\\operatorname{median}(c)$ denotes the median of the array $c$. \n\n$^{\\dagger}$A subarray of the array $a$ of length $n$ is the array $[a_l, a_{l + 1}, \\ldots, a_r]$ for some integers $1 \\le l \\le r \\le n$.\n\n$^{\\ddagger}$A median of the array of odd length is the middle element after the array is sorted in non-decreasing order. For example: $\\operatorname{median}([1,2,5,4,3]) = 3$, $\\operatorname{median}([3,2,1]) = 2$, $\\operatorname{median}([2,1,2,1,2,2,2]) = 2$.\n\nInput Format:\nEach test consists of multiple test cases. The first line contains a single integer $t$ ($1 \\le t \\le 5000$) \u2014 the number of test cases. The description of the test cases follows.\n\nThe first line of each test case contains two integers $n$ and $k$ ($1 \\le k \\le n < 2 \\cdot 10^5$, $n$ is odd) \u2014 the length of array $a$ and the desired median of the array of medians of all subarrays.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\nOutput Format:\nFor each test case:\n\n  * If there is no suitable partition, output $-1$ in a single line.    * Otherwise, in the first line, output an odd integer $m$ ($1 \\le m \\le n$), and in the second line, output $m$ distinct integers $p_1, p_2 , p_3 , \\ldots, p_m$ ($1 = p_1 < p_2 < p_3 < \\ldots < p_m \\le n$) \u2014 denoting the left borders of each subarray. \n\nIn detail, for a valid answer $[p_1, p_2, \\ldots, p_m]$:\n\n  * $b_1 = \\left[ a_{p_1}, a_{p_1 + 1}, \\ldots, a_{p_2 - 1} \\right]$    * $b_2 = \\left[ a_{p_2}, a_{p_2 + 1}, \\ldots, a_{p_3 - 1} \\right]$    * $\\ldots$    * $b_m = \\left[ a_{p_m}, a_{p_m + 1}, \\ldots, a_n \\right]$. \n\nIf there are multiple solutions, you can output any of them.\n\nTags:\n['constructive algorithms', 'greedy', 'implementation', 'math']\n\nTime Limit: 1000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "4\n1 1\n3 2\n3 3\n15 8",
                "output": "1\n1\n3\n1 2 3\n-1\n5\n1 4 7 10 13"
            }
        ]
    },
    {
        "problem": "\nYou are given an array $a$ of $n$ elements $a_1, a_2, \\ldots, a_n$.\n\nYou can perform the following operation any number (possibly $0$) of times:\n\n  * Choose two integers $i$ and $j$, where $1 \\le i, j \\le n$, and assign $a_i := a_j$. \n\nFind the minimum number of operations required to make the array $a$ satisfy the condition:\n\n  * For every pairwise distinct triplet of indices $(x, y, z)$ ($1 \\le x, y, z \\le n$, $x \\ne y$, $y \\ne z$, $x \\ne z$), there exists a non-degenerate triangle with side lengths $a_x$, $a_y$ and $a_z$, i.e. $a_x + a_y > a_z$, $a_y + a_z > a_x$ and $a_z + a_x > a_y$.\n\nInput Format:\nEach test consists of multiple test cases. The first line contains a single integer $t$ ($1 \\le t \\le 10^4$) \u2014 the number of test cases. The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($3 \\le n \\le 2 \\cdot 10^5$) \u2014 the number of elements in the array $a$.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\le a_i \\le 10^9$) \u2014 the elements of the array $a$.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\nOutput Format:\nFor each test case, output a single integer \u2014 the minimum number of operations required.\n\nTags:\n['binary search', 'math', 'sortings', 'two pointers']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "4\n7\n1 2 3 4 5 6 7\n3\n1 3 2\n3\n4 5 3\n15\n9 3 8 1 6 5 3 8 2 1 4 2 9 4 7",
                "output": "3\n1\n0\n8"
            }
        ]
    },
    {
        "problem": "\nThis is an interactive problem.\n\nUpon clearing the Waterside Area, Gretel has found a monster named Genokraken, and she's keeping it contained for her scientific studies.\n\nThe monster's nerve system can be structured as a tree$^{\\dagger}$ of $n$ nodes (really, everything should stop resembling trees all the time$\\ldots$), numbered from $0$ to $n-1$, with node $0$ as the root.\n\nGretel's objective is to learn the exact structure of the monster's nerve system \u2014 more specifically, she wants to know the values $p_1, p_2, \\ldots, p_{n-1}$ of the tree, where $p_i$ ($0 \\le p_i < i$) is the direct parent node of node $i$ ($1 \\le i \\le n - 1$).\n\nShe doesn't know exactly how the nodes are placed, but she knows a few convenient facts:\n\n  * If we remove root node $0$ and all adjacent edges, this tree will turn into a forest consisting of only paths$^{\\ddagger}$. Each node that was initially adjacent to the node $0$ will be the end of some path.    * The nodes are indexed in a way that if $1 \\le x \\le y \\le n - 1$, then $p_x \\le p_y$.    * Node $1$ has exactly two adjacent nodes (including the node $0$). \n\n![](CDN_BASE_URL/9e3efde5fa1c3b92802e71707f427f91)| ![](CDN_BASE_URL/ba6c28030157828dcd682786de7f0527)| ![](CDN_BASE_URL/bdeedf002bf19f7cf8b52abe474df823)   ---|---|---   The tree in this picture does not satisfy the condition, because if we remove node $0$, then node $2$ (which was initially adjacent to the node $0$) will not be the end of the path $4-2-5$.| The tree in this picture does not satisfy the condition, because $p_3 \\le p_4$ must hold.| The tree in this picture does not satisfy the condition, because node $1$ has only one adjacent node.      Gretel can make queries to the containment cell:\n\n  * \"? a b\" ($1 \\le a, b < n$, $a \\ne b$) \u2014 the cell will check if the simple path between nodes $a$ and $b$ contains the node $0$. \n\nHowever, to avoid unexpected consequences by overstimulating the creature, Gretel wants to query at most $2n - 6$ times. Though Gretel is gifted, she can't do everything all at once, so can you give her a helping hand?\n\n$^{\\dagger}$A tree is a connected graph where every pair of distinct nodes has exactly one simple path connecting them.\n\n$^{\\ddagger}$A path is a tree whose vertices can be listed in the order $v_1, v_2, \\ldots, v_k$ such that the edges are $(v_i, v_{i+1})$ ($1 \\le i < k$).\n\nInput Format:\nEach test consists of multiple test cases. The first line contains a single integer $t$ ($1 \\le t \\le 500$) \u2014 the number of test cases. The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($4 \\le n \\le 10^4$) \u2014 the number of nodes in Genokraken's nerve system.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $10^4$.\n\nOutput Format:\n\n\nTags:\n['constructive algorithms', 'data structures', 'graphs', 'implementation', 'interactive', 'trees', 'two pointers']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "3\n4\n\n1\n\n5\n\n1\n\n0\n\n9",
                "output": "? 2 3\n\n! 0 0 1\n\n? 2 3\n\n? 2 4\n\n! 0 0 1 2\n\n! 0 0 0 1 3 5 6 7"
            }
        ]
    },
    {
        "problem": "\nYou are given a cyclic array $a$ with $n$ elements, where $n$ is odd. In each operation, you can do the following:\n\n  * Choose an index $1 \\le i \\le n$ and increase $a_{i - 1}$ by $1$, $a_i$ by $2$, and $a_{i + 1}$ by $1$. The element before the first element is the last element because this is a cyclic array. \n\nA cyclic array is called balanced if all its elements are equal to each other.\n\nFind any sequence of operations to make this cyclic array balanced or determine that it is impossible. Please note that you do not have to minimize the number of operations.\n\nInput Format:\nEach test consists of multiple test cases. The first line contains a single integer $t$ ($1 \\le t \\le 2 \\cdot 10^5$) \u2014 the number of test cases. The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($1 \\le n < 2 \\cdot 10^5$, $n$ is odd) \u2014 the length of the array $a$.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\le a_i \\le 10^{6}$) \u2014 the elements of the array $a$.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\nOutput Format:\nFor each test case:\n\n  * If it is impossible to make the cyclic array balanced, output $-1$.    * Otherwise, output $n$ integers $v_1, v_2, \\ldots, v_n$ ($0 \\leq v_i \\leq 10^{18}$) \u2014 where $v_i$ denotes the number of operations applied to index $i$. It can be proved that if any solution exists, then there exists a solution under the given constraints. If there are several solutions under the given constraints, output any of them.\n\nTags:\n['constructive algorithms', 'data structures', 'greedy', 'implementation', 'math']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "6\n3\n2 1 2\n3\n1 2 3\n5\n1 2 1 2 1\n7\n1 2 1 2 1 3 1\n9\n10000 10000 10000 10000 10000 10001 10002 10001 10000\n1\n10",
                "output": "0 1 0 \n2 1 0 \n2 0 3 0 2 \n4 2 7 0 8 0 6 \n1 1 1 1 1 1 0 1 1 \n0"
            }
        ]
    },
    {
        "problem": "\nHaving the magical beanstalk, Jack has been gathering a lot of peanuts lately. Eventually, he has obtained $n$ pockets of peanuts, conveniently numbered $1$ to $n$ from left to right. The $i$-th pocket has $a_i$ peanuts.\n\nJack and his childhood friend Alice decide to play a game around the peanuts. First, Alice divides the pockets into some boxes; each box will have a non- zero number of consecutive pockets, and each pocket will, obviously, belong to exactly one box. At the same time, Alice does not change the order of the boxes, that is, the boxes are numbered in ascending order of the indices of the pockets in them.\n\nAfter that, Alice and Jack will take turns alternately, with Alice going first.\n\nAt each turn, the current player will remove a positive number of peanuts from exactly one pocket which belongs to the leftmost non-empty box (i.e., the leftmost box containing at least one non-empty pocket). In other words, if we number the boxes from left to right, then each player can only pick peanuts from the pocket in the $j$-th box ($j \\ge 2$) only if the $(j - 1)$-th box has no peanuts left. The player who cannot make a valid move loses.\n\nAlice is sure she will win since she has the advantage of dividing the pockets into boxes herself. Thus, she wanted to know how many ways there are for her to divide the peanuts into boxes at the start of the game so that she will win, assuming both players play optimally. Can you help her with the calculation?\n\nAs the result can be very large, output it modulo $998\\,244\\,353$.\n\nInput Format:\nEach test consists of multiple test cases. The first line contains a single integer $t$ ($1 \\le t \\le 10^4$) \u2014 the number of test cases. The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($1 \\leq n \\leq 10^6$) \u2014 the number of pockets.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\leq a_i \\leq 10^9$) \u2014 the number of peanuts in each pocket.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $10^6$.\n\nOutput Format:\nFor each test case, output a single integer \u2014 the number of ways for Alice to divide the pockets into boxes at the start of the game to guarantee her win, assuming both players play optimally, modulo $998\\,244\\,353$.\n\nTags:\n['combinatorics', 'dp', 'games', 'math']\n\nTime Limit: 4000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "5\n3\n1 2 3\n4\n1 2 3 1\n5\n1 1 1 1 1\n2\n1 1\n10\n1 2 3 4 5 6 7 8 9 10",
                "output": "1\n4\n16\n0\n205"
            }
        ]
    },
    {
        "problem": "\nSakurako and Kosuke decided to play some games with a dot on a coordinate line. The dot is currently located in position $x=0$. They will be taking turns, and Sakurako will be the one to start.\n\nOn the $i$-th move, the current player will move the dot in some direction by $2\\cdot i-1$ units. Sakurako will always be moving the dot in the negative direction, whereas Kosuke will always move it in the positive direction.\n\nIn other words, the following will happen:\n\n  1. Sakurako will change the position of the dot by $-1$, $x = -1$ now    2. Kosuke will change the position of the dot by $3$, $x = 2$ now    3. Sakurako will change the position of the dot by $-5$, $x = -3$ now    4. $\\cdots$ \n\nThey will keep on playing while the absolute value of the coordinate of the dot does not exceed $n$. More formally, the game continues while $-n\\le x\\le n$. It can be proven that the game will always end.\n\nYour task is to determine who will be the one who makes the last turn.\n\nInput Format:\nThe first line contains one integer $t$ ($1\\le t\\le 100$) \u2014 the number of games that Sakurako and Kosuke played.\n\nEach game is described by one number $n$ ($1 \\le n\\le 100$) \u2014 the number that defines the condition when the game ends.\n\nOutput Format:\nFor each of the $t$ games, output a line with the result of that game. If Sakurako makes the last turn, output \"Sakurako\" (without quotes); else output \"Kosuke\".\n\nTags:\n['constructive algorithms', 'implementation', 'math']\n\nTime Limit: 1000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "4\n1\n6\n3\n98",
                "output": "Kosuke\nSakurako\nKosuke\nSakurako"
            }
        ]
    },
    {
        "problem": "\nDuring her journey with Kosuke, Sakurako and Kosuke found a valley that can be represented as a matrix of size $n \\times n$, where at the intersection of the $i$-th row and the $j$-th column is a mountain with a height of $a_{i,j}$. If $a_{i,j} < 0$, then there is a lake there.\n\nKosuke is very afraid of water, so Sakurako needs to help him:\n\n  * With her magic, she can select a square area of mountains and increase the height of each mountain on the main diagonal of that area by exactly one. \n\nMore formally, she can choose a submatrix with the upper left corner located at $(i, j)$ and the lower right corner at $(p, q)$, such that $p-i=q-j$. She can then add one to each element at the intersection of the $(i + k)$-th row and the $(j + k)$-th column, for all $k$ such that $0 \\le k \\le p-i$.\n\nDetermine the minimum number of times Sakurako must use her magic so that there are no lakes.\n\nInput Format:\nThe first line contains a single integer $t$ ($1 \\le t \\le 200$) \u2014 the number of test cases.\n\nEach test case is described as follows:\n\n  * The first line of each test case consists of a single number $n$ ($1 \\le n \\le 500$).    * Each of the following $n$ lines consists of $n$ integers separated by spaces, which correspond to the heights of the mountains in the valley $a$ ($-10^5 \\le a_{i,j} \\le 10^5$). \n\nIt is guaranteed that the sum of $n$ across all test cases does not exceed $1000$.\n\nOutput Format:\nFor each test case, output the minimum number of times Sakurako will have to use her magic so that all lakes disappear.\n\nTags:\n['brute force', 'constructive algorithms', 'greedy']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "4\n1\n1\n2\n-1 2\n3 0\n3\n1 2 3\n-2 1 -1\n0 0 -1\n5\n1 1 -1 -1 3\n-3 1 4 4 -4\n-1 -1 3 0 -5\n4 5 3 -3 -1\n3 1 -3 -1 5",
                "output": "0\n1\n4\n19"
            }
        ]
    },
    {
        "problem": "\nEven in university, students need to relax. That is why Sakurakos teacher decided to go on a field trip. It is known that all of the students will be walking in one line. The student with index $i$ has some topic of interest which is described as $a_i$. As a teacher, you want to minimise the disturbance of the line of students.\n\nThe disturbance of the line is defined as the number of neighbouring people with the same topic of interest. In other words, disturbance is the number of indices $j$ ($1 \\le j < n$) such that $a_j = a_{j + 1}$.\n\nIn order to do this, you can choose index $i$ ($1\\le i\\le n$) and swap students at positions $i$ and $n-i+1$. You can perform any number of swaps.\n\nYour task is to determine the minimal amount of disturbance that you can achieve by doing the operation described above any number of times.\n\nInput Format:\nThe first line contains one integer $t$ ($1\\le t\\le 10^4$) \u2014 the number of test cases.\n\nEach test case is described by two lines.\n\n  * The first line contains one integer $n$ ($2 \\le n \\le 10^5$) \u2014 the length of the line of students.    * The second line contains $n$ integers $a_i$ ($1\\le a_i\\le n$) \u2014 the topics of interest of students in line. \n\nIt is guaranteed that the sum of $n$ across all test cases does not exceed $2\\cdot 10^5$.\n\nOutput Format:\nFor each test case, output the minimal possible disturbance of the line that you can achieve.\n\nTags:\n['dp', 'greedy', 'two pointers']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "9\n5\n1 1 1 2 3\n6\n2 1 2 2 1 1\n4\n1 2 1 1\n6\n2 1 1 2 2 4\n4\n2 1 2 3\n6\n1 2 2 1 2 1\n5\n4 5 5 1 5\n7\n1 4 3 5 1 1 3\n7\n3 1 3 2 2 3 3",
                "output": "1\n2\n1\n0\n0\n1\n1\n0\n2"
            }
        ]
    },
    {
        "problem": "\nAfter a trip with Sakurako, Kousuke was very scared because he forgot about his programming assignment. In this assignment, the teacher gave him an array $a$ of $n$ integers and asked him to calculate the number of non- overlapping segments of the array $a$, such that each segment is considered beautiful.\n\nA segment $[l,r]$ is considered beautiful if $a_l + a_{l+1} + \\dots + a_{r-1} + a_r=0$.\n\nFor a fixed array $a$, your task is to compute the maximum number of non- overlapping beautiful segments.\n\nInput Format:\nThe first line of input contains the number $t$ ($1 \\le t \\le 10^4$) \u2014 the number of test cases. Each test case consists of $2$ lines.\n\n  * The first line contains one integer $n$ ($1 \\le n \\le 10^5$) \u2014 the length of the array.   * The second line contains $n$ integers $a_i$ ($-10^5 \\le a_i \\le 10^5$) \u2014 the elements of the array $a$. \n\nIt is guaranteed that the sum of $n$ across all test cases does not exceed $3\\cdot 10^5$.\n\nOutput Format:\nFor each test case, output a single integer: the maximum number of non- overlapping beautiful segments.\n\nTags:\n['data structures', 'dp', 'dsu', 'greedy', 'math']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "3\n5\n2 1 -3 2 1\n7\n12 -4 4 43 -3 -5 8\n6\n0 -4 0 3 0 1",
                "output": "1\n2\n3"
            }
        ]
    },
    {
        "problem": "\nSakurako's exams are over, and she did excellently. As a reward, she received a permutation $p$. Kosuke was not entirely satisfied because he failed one exam and did not receive a gift. He decided to sneak into her room (thanks to the code for her lock) and spoil the permutation so that it becomes simple.\n\nA permutation $p$ is considered simple if for every $i$ $(1\\le i \\le n)$ one of the following conditions holds:\n\n  * $p_i=i$    * $p_{p_i}=i$ \n\nFor example, the permutations $[1, 2, 3, 4]$, $[5, 2, 4, 3, 1]$, and $[2, 1]$ are simple, while $[2, 3, 1]$ and $[5, 2, 1, 4, 3]$ are not.\n\nIn one operation, Kosuke can choose indices $i,j$ $(1\\le i,j\\le n)$ and swap the elements $p_i$ and $p_j$.\n\nSakurako is about to return home. Your task is to calculate the minimum number of operations that Kosuke needs to perform to make the permutation simple.\n\nInput Format:\nThe first line contains one integer $t$ ($1\\le t\\le 10^4$) \u2014 the number of test cases.\n\nEach test case is described by two lines.\n\n  * The first line contains one integer $n$ ($1\\le n \\le 10^6$) \u2014 the length of the permutation $p$.    * The second line contains $n$ integers $p_i$ ($1\\le p_i\\le n$) \u2014 the elements of the permutation $p$. \n\nIt is guaranteed that the sum of $n$ across all test cases does not exceed $10^6$.\n\nIt is guaranteed that $p$ is a permutation.\n\nOutput Format:\nFor each test case, output the minimum number of operations that Kosuke needs to perform to make the permutation simple.\n\nTags:\n['brute force', 'data structures', 'dfs and similar', 'dsu', 'graphs', 'greedy', 'math']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "6\n5\n1 2 3 4 5\n5\n5 4 3 2 1\n5\n2 3 4 5 1\n4\n2 3 4 1\n3\n1 3 2\n7\n2 3 1 5 6 7 4",
                "output": "0\n0\n2\n1\n0\n2"
            }
        ]
    },
    {
        "problem": "\nKosuke is too lazy. He will not give you any legend, just the task:\n\nFibonacci numbers are defined as follows:\n\n  * $f(1)=f(2)=1$.    * $f(n)=f(n-1)+f(n-2)$ $(3\\le n)$ \n\nWe denote $G(n,k)$ as an index of the $n$-th Fibonacci number that is divisible by $k$. For given $n$ and $k$, compute $G(n,k)$.\n\nAs this number can be too big, output it by modulo $10^9+7$.\n\nFor example: $G(3,2)=9$ because the $3$-rd Fibonacci number that is divisible by $2$ is $34$. $[1,1,\\textbf{2},3,5,\\textbf{8},13,21,\\textbf{34}]$.\n\nInput Format:\nThe first line of the input data contains a single integer $t$ ($1 \\le t \\le 10^4$) \u2014 the number of test cases.\n\nThe first and only line contains two integers $n$ and $k$ ($1 \\le n \\le 10^{18}$, $1 \\le k \\le 10^5$).\n\nIt is guaranteed that the sum of $k$ across all test cases does not exceed $10^6$.\n\nOutput Format:\nFor each test case, output the only number: the value $G(n,k)$ taken by modulo $10^9+7$.\n\nTags:\n['brute force', 'math', 'number theory']\n\nTime Limit: 1000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "3\n3 2\n100 1\n1000000000000 1377",
                "output": "9\n100\n999244007"
            }
        ]
    },
    {
        "problem": "\nGiven a tree with $n$ vertices rooted at vertex $1$. While walking through it with her cat Chefir, Sakurako got distracted, and Chefir ran away.\n\nTo help Sakurako, Kosuke recorded his $q$ guesses. In the $i$-th guess, he assumes that Chefir got lost at vertex $v_i$ and had $k_i$ stamina.\n\nAlso, for each guess, Kosuke assumes that Chefir could move along the edges an arbitrary number of times:\n\n  * from vertex $a$ to vertex $b$, if $a$ is an ancestor$^{\\text{\u2217}}$ of $b$, the stamina will not change;    * from vertex $a$ to vertex $b$, if $a$ is not an ancestor of $b$, then Chefir's stamina decreases by $1$. \n\nIf Chefir's stamina is $0$, he cannot make a move of the second type.\n\nFor each assumption, your task is to find the distance to the farthest vertex that Chefir could reach from vertex $v_i$, having $k_i$ stamina.\n\n$^{\\text{\u2217}}$Vertex $a$ is an ancestor of vertex $b$ if the shortest path from $b$ to the root passes through $a$.\n\nInput Format:\nThe first line contains a single integer $t$ ($1\\le t\\le 10^4$) \u2014 the number of test cases.\n\nEach test case is described as follows:\n\n  * The first line contains a single integer $n$ ($2 \\le n \\le 2 \\cdot 10^5$) \u2014 the number of vertices in the tree.   * The next $n-1$ lines contain the edges of the tree. It is guaranteed that the given edges form a tree.   * The next line consists of a single integer $q$ $(1\\le q\\le 2 \\cdot 10^5)$, which denotes the number of guesses made by Kosuke.   * The next $q$ lines describe the guesses made by Kosuke, with two integers $v_i$, $k_i$ $(1\\le v_i \\le n, 0 \\le k_i\\le n)$. \n\nIt is guaranteed that the sum of $n$ and the sum of $q$ across all test cases does not exceed $2\\cdot 10^5$.\n\nOutput Format:\nFor each test case and for each guess, output the maximum distance to the farthest vertex that Chefir could reach from the starting point $v_i$ having $k_i$ stamina.\n\nTags:\n['data structures', 'dfs and similar', 'dp', 'greedy', 'trees']\n\nTime Limit: 4000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "3\n5\n1 2\n2 3\n3 4\n3 5\n3\n5 1\n3 1\n2 0\n9\n8 1\n1 7\n1 4\n7 3\n4 9\n3 2\n1 5\n3 6\n7\n6 0\n2 3\n6 2\n8 2\n2 4\n9 2\n6 3\n6\n2 1\n2 5\n2 4\n5 6\n4 3\n3\n3 1\n1 3\n6 5",
                "output": "2 1 2 \n0 5 2 4 5 5 5 \n1 3 4"
            }
        ]
    },
    {
        "problem": "\nRed was ejected. They were not the imposter.\n\nThere are $n$ rows of $m$ people. Let the position in the $r$-th row and the $c$-th column be denoted by $(r, c)$. Number each person starting from $1$ in row-major order, i.e., the person numbered $(r-1)\\cdot m+c$ is initially at $(r,c)$.\n\nThe person at $(r, c)$ decides to leave. To fill the gap, let the person who left be numbered $i$. Each person numbered $j>i$ will move to the position where the person numbered $j-1$ is initially at. The following diagram illustrates the case where $n=2$, $m=3$, $r=1$, and $c=2$.\n\n![](CDN_BASE_URL/9b0b8e601446e3410296d7c9b1ff8763)\n\nCalculate the sum of the Manhattan distances of each person's movement. If a person was initially at $(r_0, c_0)$ and then moved to $(r_1, c_1)$, the Manhattan distance is $|r_0-r_1|+|c_0-c_1|$.\n\nInput Format:\nThe first line contains a single integer $t$ ($1\\le t\\le 10^4$) \u2014 the number of test cases.\n\nThe only line of each testcase contains $4$ integers $n$, $m$, $r$, and $c$ ($1\\le r\\le n\\le 10^6$, $1 \\le c \\le m \\le 10^6$), where $n$ is the number of rows, $m$ is the number of columns, and $(r,c)$ is the position where the person who left is initially at.\n\nOutput Format:\nFor each test case, output a single integer denoting the sum of the Manhattan distances.\n\nTags:\n['implementation', 'math']\n\nTime Limit: 1000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "4\n2 3 1 2\n2 2 2 1\n1 1 1 1\n1000000 1000000 1 1",
                "output": "6\n1\n0\n1999998000000"
            }
        ]
    },
    {
        "problem": "\nThere are 3 heroes and 3 villains, so 6 people in total.\n\nGiven a positive integer $n$. Find the smallest integer whose decimal representation has length $n$ and consists only of $3$s and $6$s such that it is divisible by both $33$ and $66$. If no such integer exists, print $-1$.\n\nInput Format:\nThe first line contains a single integer $t$ ($1\\le t\\le 500$) \u2014 the number of test cases.\n\nThe only line of each test case contains a single integer $n$ ($1\\le n\\le 500$) \u2014 the length of the decimal representation.\n\nOutput Format:\nFor each test case, output the smallest required integer if such an integer exists and $-1$ otherwise.\n\nTags:\n['constructive algorithms', 'greedy', 'math', 'number theory']\n\nTime Limit: 1000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "6\n1\n2\n3\n4\n5\n7",
                "output": "-1\n66\n-1\n3366\n36366\n3336366"
            }
        ]
    },
    {
        "problem": "\nAlya has been given a hard problem. Unfortunately, she is too busy running for student council. Please solve this problem for her.\n\nGiven an integer $n$, construct a permutation $p$ of integers $1, 2, \\ldots, n$ that maximizes the value of $k$ (which is initially $0$) after the following process.\n\nPerform $n$ operations, on the $i$-th operation ($i=1, 2, \\dots, n$),\n\n  * If $i$ is odd, $k=k\\,\\&\\,p_i$, where $\\&$ denotes the [bitwise AND operation](https://en.wikipedia.org/wiki/Bitwise_operation#AND).    * If $i$ is even, $k=k\\,|\\,p_i$, where $|$ denotes the [bitwise OR operation](https://en.wikipedia.org/wiki/Bitwise_operation#OR).\n\nInput Format:\nThe first line contains a single integer $t$ ($1\\le t\\le 500$) \u2014 the number of test cases.\n\nThe only line of each test case contains a single integer $n$ ($5\\le n\\le 2 \\cdot 10^5$) \u2014 the length of the permutation.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\nOutput Format:\nFor each test case, output the maximum value of $k$ in the first line and output the permutation $p_1, p_2,\\ldots, p_n$ in the second line.\n\nIf there are multiple such permutations, output any.\n\nTags:\n['bitmasks', 'constructive algorithms', 'math']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "6\n5\n6\n7\n8\n9\n10",
                "output": "5\n2 1 3 4 5 \n7\n1 2 4 6 5 3 \n7\n2 4 5 1 3 6 7 \n15\n2 4 5 1 3 6 7 8 \n9\n2 4 5 6 7 1 3 8 9 \n15\n1 2 3 4 5 6 8 10 9 7"
            }
        ]
    },
    {
        "problem": "\nThree r there are's in strawberry.\n\nYou are given an array $b$ of length $m$. You can perform the following operation any number of times (possibly zero):\n\n  * Choose two distinct indices $i$ and $j$ where $\\bf{1\\le i < j\\le m}$ and $b_i$ is even, divide $b_i$ by $2$ and multiply $b_j$ by $2$. \n\nYour task is to maximize the sum of the array after performing any number of such operations. Since it could be large, output this sum modulo $10^9+7$.\n\nSince this problem is too easy, you are given an array $a$ of length $n$ and need to solve the problem for each prefix of $a$.\n\nIn other words, denoting the maximum sum of $b$ after performing any number of such operations as $f(b)$, you need to output $f([a_1])$, $f([a_1,a_2])$, $\\ldots$, $f([a_1,a_2,\\ldots,a_n])$ modulo $10^9+7$ respectively.\n\nInput Format:\nThe first line contains a single integer $t$ ($1\\le t\\le 10^4$) \u2014 the number of test cases.\n\nThe first line of each test case contains a single integer $n$ ($1 \\le n \\le 2 \\cdot 10^5$) \u2014 the length of $a$.\n\nThe second line contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\le a_i \\le 10^9$) \u2014 the starting values of array $a$.\n\nIt is guaranteed that the sum of $n$ over all test cases will not exceed $2 \\cdot 10^5$.\n\nOutput Format:\nFor each test case, output $n$ integers representing the answer for each prefix of $a$ modulo $10^9+7$.\n\nTags:\n['binary search', 'data structures', 'divide and conquer', 'greedy', 'implementation', 'math']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "3\n10\n1 2 3 4 5 6 7 8 9 10\n11\n1 6 9 4 7 4 4 10 3 2 3\n4\n527792568 502211460 850237282 374773208",
                "output": "1 3 8 13 46 59 126 149 1174 1311 \n1 7 22 26 70 74 150 1303 1306 1308 1568 \n527792568 83665723 399119771 773892979"
            }
        ]
    },
    {
        "problem": "\nMan, this Genshin boss is so hard. Good thing they have a top-up of $6$ coins for only $ \\$4.99$. I should be careful and spend no more than I need to, lest my mom catches me...\n\nYou are fighting a monster with $z$ health using a weapon with $d$ damage. Initially, $d=0$. You can perform the following operations.\n\n  * Increase $d$ \u2014 the damage of your weapon by $1$, costing $x$ coins.    * Attack the monster, dealing $d$ damage and costing $y$ coins. \n\nYou cannot perform the first operation for more than $k$ times in a row.\n\nFind the minimum number of coins needed to defeat the monster by dealing at least $z$ damage.\n\nInput Format:\nThe first line contains a single integer $t$ ($1\\le t\\le 100$) \u2014 the number of test cases.\n\nThe only line of each test case contains 4 integers $x$, $y$, $z$, and $k$ ($1\\leq x, y, z, k\\leq 10^8$) \u2014 the first operation's cost, the second operation's cost, the monster's health, and the limitation on the first operation.\n\nOutput Format:\nFor each test case, output the minimum number of coins needed to defeat the monster.\n\nTags:\n['binary search', 'brute force', 'constructive algorithms', 'greedy', 'implementation', 'math', 'ternary search']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "4\n2 3 5 5\n10 20 40 5\n1 60 100 10\n60 1 100 10",
                "output": "12\n190\n280\n160"
            }
        ]
    },
    {
        "problem": "\nThis really says a lot about our society.\n\nOne day, a turtle gives you a tree with $n$ nodes rooted at node $x$. Each node has an initial nonnegative value; the $i$-th node has starting value $a_i$.\n\nYou want to make the values of all nodes equal to $0$. To do so, you will perform a series of operations on the tree, where each operation will be performed on a certain node. Define an operation on node $u$ as choosing a single node in $u$'s subtree$^{\\text{\u2217}}$ and incrementing or decrementing its value by $1$. The order in which operations are performed on nodes is as follows:\n\n  * For $1 \\le i \\le n$, the $i$-th operation will be performed on node $i$.    * For $i > n$, the $i$-th operation will be performed on the same node as operation $i - n$. \n\nMore formally, the $i$-th operation will be performed on the $(((i - 1) \\bmod n) + 1)$-th node.$^{\\text{\u2020}}$\n\nNote that you cannot skip over operations; that is, you cannot perform the $i$-th operation without first performing operations $1, 2, \\ldots, i - 1$.\n\nFind the minimum number of operations you must perform before you can make the values of all nodes equal to $0$, assuming you pick operations optimally. If it's impossible to make the values of all nodes equal to $0$ after finite operations, output $-1$.\n\n$^{\\text{\u2217}}$The subtree of a node $u$ is the set of nodes for which $u$ lies on the shortest path from this node to the root, including $u$ itself.\n\n$^{\\text{\u2020}}$Here, $a \\bmod b$ denotes the remainder from dividing $a$ by $b$.\n\nInput Format:\nThe first line contains a single integer $t$ ($1\\le t\\le 100$) \u2014 the number of test cases.\n\nThe first line of each test case contains two integers $n$ and $x$ ($1 \\le n \\le 2000$, $1 \\le x \\le n$) \u2014 the number of nodes and the root of the tree.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($0 \\le a_i \\le 10^9$) \u2014 the starting value of each node.\n\nEach of the next $n - 1$ lines of each test case contains two integers $u$ and $v$ ($1 \\le u, v \\le n$, $u \\neq v$) representing an undirected edge from $u$ to $v$. It is guaranteed that the given edges form a tree.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2000$.\n\nOutput Format:\nFor each test case, output a single integer denoting the minimum amount of operations needed to make all nodes $0$. If it's impossible to make all nodes $0$, output $-1$.\n\nTags:\n['binary search', 'brute force', 'dfs and similar', 'dp', 'trees']\n\nTime Limit: 4000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "5\n2 1\n1 2\n1 2\n3 2\n2 1 3\n2 1\n3 2\n4 1\n1 1 0 1\n1 2\n2 3\n1 4\n12 6\n14 4 5 6 12 9 5 11 6 2 1 12\n3 9\n10 6\n6 12\n4 3\n3 1\n5 11\n9 7\n5 6\n1 8\n2 8\n5 1\n1 1\n0",
                "output": "3\n6\n5\n145\n0"
            }
        ]
    },
    {
        "problem": "\nThe differences between the easy and hard versions are the constraints on $n$ and the sum of $n$. In this version, $n \\leq 3000$ and the sum of $n$ does not exceed $10^4$. You can only make hacks if both versions are solved.\n\nWell, well, well, let's see how Bessie is managing her finances. She seems to be in the trenches! Fortunately, she is applying for a job at Moogle to resolve this issue. Moogle interviews require intensive knowledge of obscure algorithms and complex data structures, but Bessie received a tip-off from an LGM on exactly what she has to go learn.\n\nBessie wrote the following code to binary search for a certain element $k$ in a possibly unsorted array $[a_1, a_2,\\ldots,a_n]$ with $n$ elements.\n\n              let l = 1     let h = n          while l < h:       let m = floor((l + h) / 2)            if a[m] < k:         l = m + 1       else:         h = m          return l     \n\nBessie submitted her code to Farmer John's problem with $m$ ($1 \\leq m \\leq n$) tests. The $i$-th test is of the form $(x_i, k_i)$ ($1 \\leq x, k \\leq n$). It is guaranteed all the $x_i$ are distinct and all the $k_i$ are distinct.\n\nTest $i$ is correct if the following hold:\n\n  1. The $x_i$-th element in the array is $k_i$.    2. If Bessie calls the binary search as shown in the above code for $k_i$, it will return $x_i$. \n\nIt might not be possible for all $m$ tests to be correct on the same array, so Farmer John will remove some of them so Bessie can AC. Let $r$ be the minimum of tests removed so that there exists an array $[a_1, a_2,\\ldots,a_n]$ with $1 \\leq a_i \\leq n$ so that all remaining tests are correct.\n\nIn addition to finding $r$, Farmer John wants you to count the number of arrays $[a_1, a_2,\\ldots,a_n]$ with $1 \\leq a_i \\leq n$ such that there exists a way to remove exactly $r$ tests so that all the remaining tests are correct. Since this number may be very large, please find it modulo $998\\,244\\,353$.\n\nInput Format:\nThe first line contains a single integer $t$ ($1 \\le t \\le 10^4$) \u2014 the number of test cases.\n\nThe first line of each test case contains two integers $n$ and $m$ ($1 \\leq m \\leq n \\leq 3000$) denoting the number of the array and the number of tests.\n\nThe following $m$ lines each contain two integers, describing the tests. The $i$-th line contains two integers $x_i$ and $k_i$ ($1 \\leq x_i, k_i \\leq n$) denoting the index and value of the test. It is guaranteed all $x_i$ are distinct and all $k_i$ are distinct.\n\nIt is guaranteed the sum of $n$ across all test cases does not exceed $10^4$.\n\nOutput Format:\nFor each test case, output two integers, $r$ \u2014 the minimum of tests removed so that there exists an array so that all remaining tests are correct, and the number of arrays such that it is possible to remove $r$ tests to make all remaining tests correct modulo $998\\,244\\,353$.\n\nTags:\n['dp', 'trees']\n\nTime Limit: 5000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "2\n5 4\n1 1\n2 2\n4 3\n5 4\n5 4\n5 4\n2 5\n1 2\n3 3",
                "output": "0 1\n1 3"
            },
            {
                "input": "2\n6 6\n1 3\n2 5\n3 1\n4 2\n5 4\n6 6\n30 8\n19 22\n6 12\n12 1\n28 27\n3 4\n14 25\n29 14\n11 15",
                "output": "3 78\n3 839271911"
            }
        ]
    },
    {
        "problem": "\nThe differences between the easy and hard versions are the constraints on $n$ and the sum of $n$. In this version, $n \\leq 3\\cdot 10^5$ and the sum of $n$ does not exceed $10^6$. You can only make hacks if both versions are solved.\n\nWell, well, well, let's see how Bessie is managing her finances. She seems to be in the trenches! Fortunately, she is applying for a job at Moogle to resolve this issue. Moogle interviews require intensive knowledge of obscure algorithms and complex data structures, but Bessie received a tip-off from an LGM on exactly what she has to go learn.\n\nBessie wrote the following code to binary search for a certain element $k$ in a possibly unsorted array $[a_1, a_2,\\ldots,a_n]$ with $n$ elements.\n\n              let l = 1     let h = n          while l < h:       let m = floor((l + h) / 2)            if a[m] < k:         l = m + 1       else:         h = m          return l     \n\nBessie submitted her code to Farmer John's problem with $m$ ($1 \\leq m \\leq n$) tests. The $i$-th test is of the form $(x_i, k_i)$ ($1 \\leq x, k \\leq n$). It is guaranteed all the $x_i$ are distinct and all the $k_i$ are distinct.\n\nTest $i$ is correct if the following hold:\n\n  1. The $x_i$-th element in the array is $k_i$.    2. If Bessie calls the binary search as shown in the above code for $k_i$, it will return $x_i$. \n\nIt might not be possible for all $m$ tests to be correct on the same array, so Farmer John will remove some of them so Bessie can AC. Let $r$ be the minimum of tests removed so that there exists an array $[a_1, a_2,\\ldots,a_n]$ with $1 \\leq a_i \\leq n$ so that all remaining tests are correct.\n\nIn addition to finding $r$, Farmer John wants you to count the number of arrays $[a_1, a_2,\\ldots,a_n]$ with $1 \\leq a_i \\leq n$ such that there exists a way to remove exactly $r$ tests so that all the remaining tests are correct. Since this number may be very large, please find it modulo $998\\,244\\,353$.\n\nInput Format:\nThe first line contains a single integer $t$ ($1 \\le t \\le 10^4$) \u2014 the number of test cases.\n\nThe first line of each test case contains two integers $n$ and $m$ ($1 \\leq m \\leq n \\leq 3 \\cdot 10^5$) denoting the number of the array and the number of tests.\n\nThe following $m$ lines each contain two integers, describing the tests. The $i$-th line contains two integers $x_i$ and $k_i$ ($1 \\leq x_i, k_i \\leq n$) denoting the index and value of the test. It is guaranteed all $x_i$ are distinct and all $k_i$ are distinct.\n\nIt is guaranteed the sum of $n$ across all test cases does not exceed $10^6$.\n\nOutput Format:\nFor each test case, output two integers, $r$ \u2014 the minimum of tests removed so that there exists an array so that all remaining tests are correct, and the number of arrays such that it is possible to remove $r$ tests to make all remaining tests correct modulo $998\\,244\\,353$.\n\nTags:\n['divide and conquer', 'dp']\n\nTime Limit: 5000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "2\n5 4\n1 1\n2 2\n4 3\n5 4\n5 4\n5 4\n2 5\n1 2\n3 3",
                "output": "0 1\n1 3"
            },
            {
                "input": "3\n6 6\n1 3\n2 5\n3 1\n4 2\n5 4\n6 6\n30 8\n19 22\n6 12\n12 1\n28 27\n3 4\n14 25\n29 14\n11 15\n300000 1\n5 10",
                "output": "3 78\n3 839271911\n0 702730519"
            }
        ]
    },
    {
        "problem": "\nI'm peakly productive and this is deep.\n\nYou are given two permutations$^{\\text{\u2217}}$ $a$ and $b$, both of length $n$.\n\nYou can perform the following three-step operation on permutation $a$:\n\n  1. Choose an index $i$ ($1 \\le i \\le n$).   2. Cyclic shift $a_1, a_2, \\ldots, a_{i-1}$ by $1$ to the right. If you had chosen $i = 1$, then this range doesn't exist, and you cyclic shift nothing.   3. Cyclic shift $a_{i + 1}, a_{i + 2}, \\ldots, a_n$ by $1$ to the right. If you had chosen $i = n$, then this range doesn't exist, and you cyclic shift nothing.\n\nAfter the operation, $a_1,a_2,\\ldots, a_{i-2},a_{i-1},a_i,a_{i + 1}, a_{i + 2},\\ldots,a_{n-1}, a_n$ is transformed into $a_{i-1},a_1,\\ldots,a_{i-3},a_{i-2},a_i,a_n, a_{i + 1},\\ldots,a_{n-2}, a_{n-1}$.\n\nHere are some examples of operations done on the identity permutation $[1,2,3,4,5,6,7]$ of length $7$:\n\n  * If we choose $i = 3$, it will become $[2, 1, 3, 7, 4, 5, 6]$.    * If we choose $i = 1$, it will become $[1, 7, 2, 3, 4, 5, 6]$.    * If we choose $i = 7$, it will become $[6, 1, 2, 3, 4, 5, 7]$. \n\nNotably, position $i$ is not shifted.\n\nFind a construction using at most $2n$ operations to make $a$ equal to $b$ or print $-1$ if it is impossible. The number of operations does not need to be minimized. It can be shown that if it is possible to make $a$ equal to $b$, it is possible to do this within $2n$ operations.\n\n$^{\\text{\u2217}}$A permutation of length $n$ is an array consisting of $n$ distinct integers from $1$ to $n$ in arbitrary order. For example, $[2,3,1,5,4]$ is a permutation, but $[1,2,2]$ is not a permutation ($2$ appears twice in the array), and $[1,3,4]$ is also not a permutation ($n=3$ but there is $4$ in the array).\n\nInput Format:\nThe first line contains a single integer $t$ ($1 \\le t \\le 5 \\cdot 10^4$) \u2014 the number of test cases.\n\nThe first line of each test case contains a single integer $n$ ($1 \\le n \\le 5 \\cdot 10^5$) \u2014 the lengths of permutations $a$ and $b$.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\le a_i \\le n$) \u2014 the values of permutation $a$.\n\nThe third line of each test case contains $n$ integers $b_1, b_2, \\ldots, b_n$ ($1 \\le b_i \\le n$) \u2014 the values of permutation $b$.\n\nIt is guaranteed that the sum of $n$ over all test cases will not exceed $5 \\cdot 10^5$.\n\nOutput Format:\nFor each test case:\n\nIf there is a sequence of operations to transform $a$ into $b$, output a single integer $q$ ($0\\le q\\le 2n$) \u2014 the number of operations in the first line and $q$ integers with the $i$-th number representing the index of the $i$-th operation in the second line.\n\nIf there is no sequence of operations, output $-1$ in the only line.\n\nTags:\n['constructive algorithms']\n\nTime Limit: 3000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "4\n1\n1\n1\n2\n1 2\n2 1\n3\n2 1 3\n3 2 1\n8\n7 8 3 5 4 6 1 2\n2 1 6 4 5 3 8 7",
                "output": "0\n\n-1\n2\n1 3\n7\n3 4 5 1 2 1 1"
            }
        ]
    },
    {
        "problem": "\nBoris Notkin composes melodies. He represents them as a sequence of notes, where each note is encoded as an integer from $0$ to $127$ inclusive. The interval between two notes $a$ and $b$ is equal to $|a - b|$ semitones.\n\nBoris considers a melody perfect if the interval between each two adjacent notes is either $5$ semitones or $7$ semitones.\n\nAfter composing his latest melodies, he enthusiastically shows you his collection of works. Help Boris Notkin understand whether his melodies are perfect.\n\nInput Format:\nThe first line contains an integer $t$ ($1 \\leq t \\leq 1000$) \u2014 the number of melodies.\n\nEach melody is described by two lines.\n\nThe first line contains an integer $n$ ($2 \\leq n \\leq 50$) \u2014 the number of notes in the melody.\n\nThe second line contains $n$ integers $a_{1}, a_{2}, \\dots, a_{n}$ ($0 \\leq a_{i} \\leq 127$) \u2014 the notes of the melody.\n\nOutput Format:\nFor each melody, output \"YES\", if it is perfect; otherwise, output \"NO\".\n\nYou can output the answer in any case (upper or lower). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as positive responses.\n\nTags:\n['implementation']\n\nTime Limit: 1000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "8\n2\n114 109\n2\n17 10\n3\n76 83 88\n8\n38 45 38 80 85 92 99 106\n5\n63 58 65 58 65\n8\n117 124 48 53 48 43 54 49\n5\n95 102 107 114 121\n10\n72 77 82 75 70 75 68 75 68 75",
                "output": "YES\nYES\nYES\nNO\nYES\nNO\nYES\nYES"
            }
        ]
    },
    {
        "problem": "\nArseniy came up with another business plan \u2014 to sell soda from a vending machine! For this, he purchased a machine with $n$ shelves, as well as $k$ bottles, where the $i$-th bottle is characterized by the brand index $b_i$ and the cost $c_i$.\n\nYou can place any number of bottles on each shelf, but all bottles on the same shelf must be of the same brand.\n\nArseniy knows that all the bottles he puts on the shelves of the machine will be sold. Therefore, he asked you to calculate the maximum amount he can earn.\n\nInput Format:\nThe first line contains one integer $t$ ($1 \\le t \\le 10^4$) \u2014 the number of test cases.\n\nThe first line of each test case contains two integers $n$ and $k$ ($1 \\le n, k \\le 2 \\cdot 10^5$), where $n$ is the number of shelves in the machine, and $k$ is the number of bottles available to Arseniy.\n\nThe next $k$ lines contain two integers $b_i$ and $c_i$ ($1 \\le b_i \\le k, 1 \\le c_i \\le 1000$) \u2014 the brand and cost of the $i$-th bottle.\n\nIt is also guaranteed that the sum of $n$ across all test cases does not exceed $2 \\cdot 10^5$ and that the sum of $k$ across all test cases also does not exceed $2 \\cdot 10^5$.\n\nOutput Format:\nFor each test case, output one integer \u2014 the maximum amount that Arseniy can earn.\n\nTags:\n['greedy', 'sortings']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "4\n3 3\n2 6\n2 7\n1 15\n1 3\n2 6\n2 7\n1 15\n6 2\n1 7\n2 5\n190000 1\n1 1000",
                "output": "28\n15\n12\n1000"
            }
        ]
    },
    {
        "problem": "\nWhile rummaging through things in a distant drawer, Anya found a beautiful string $s$ consisting only of zeros and ones.\n\nNow she wants to make it even more beautiful by performing $q$ operations on it.\n\nEach operation is described by two integers $i$ ($1 \\le i \\le |s|$) and $v$ ($v \\in \\\\{0, 1\\\\}$) and means that the $i$-th character of the string is assigned the value $v$ (that is, the assignment $s_i = v$ is performed).\n\nBut Anya loves the number $1100$, so after each query, she asks you to tell her whether the substring \"1100\" is present in her string (i.e. there exist such $1 \\le i \\le |s| - 3$ that $s_{i}s_{i + 1}s_{i + 2}s_{i + 3} = \\texttt{1100}$).\n\nInput Format:\nThe first line contains one integer $t$ ($1 \\leq t \\leq 10^4$) \u2014 the number of test cases.\n\nThe first line of the test case contains the string $s$ ($1 \\leq |s| \\leq 2 \\cdot 10^5$), consisting only of the characters \"0\" and \"1\". Here $|s|$ denotes the length of the string $s$.\n\nThe next line contains an integer $q$ ($1 \\leq q \\leq 2 \\cdot 10^5$) \u2014 the number of queries.\n\nThe following $q$ lines contain two integers $i$ ($1 \\leq i \\leq |s|$) and $v$ ($v \\in \\\\{0, 1\\\\}$), describing the query.\n\nIt is guaranteed that the sum of $|s|$ across all test cases does not exceed $2 \\cdot 10^5$. It is also guaranteed that the sum of $q$ across all test cases does not exceed $2 \\cdot 10^5$.\n\nOutput Format:\nFor each query, output \"YES\", if \"1100\" is present in Anya's string; otherwise, output \"NO\".\n\nYou can output the answer in any case (upper or lower). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as positive responses.\n\nTags:\n['brute force', 'implementation']\n\nTime Limit: 3000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "4\n100\n4\n1 1\n2 0\n2 0\n3 1\n1100000\n3\n6 1\n7 1\n4 1\n111010\n4\n1 1\n5 0\n4 1\n5 0\n0100\n4\n3 1\n1 1\n2 0\n2 1",
                "output": "NO\nNO\nNO\nNO\nYES\nYES\nNO\nNO\nYES\nYES\nYES\nNO\nNO\nNO\nNO"
            }
        ]
    },
    {
        "problem": "\nOne morning, Polycarp woke up and realized that $1543$ is the most favorite number in his life.\n\nThe first thing that Polycarp saw that day as soon as he opened his eyes was a large wall carpet of size $n$ by $m$ cells; $n$ and $m$ are even integers. Each cell contains one of the digits from $0$ to $9$.\n\nPolycarp became curious about how many times the number $1543$ would appear in all layers$^{\\text{\u2217}}$ of the carpet when traversed clockwise.\n\n$^{\\text{\u2217}}$The first layer of a carpet of size $n \\times m$ is defined as a closed strip of length $2 \\cdot (n+m-2)$ and thickness of $1$ element, surrounding its outer part. Each subsequent layer is defined as the first layer of the carpet obtained by removing all previous layers from the original carpet.\n\nInput Format:\nThe first line of the input contains a single integer $t$ ($1 \\leq t \\leq 100$) \u2014 the number of test cases. The following lines describe the test cases.\n\nThe first line of each test case contains a pair of numbers $n$ and $m$ ($2 \\leq n, m \\leq 10^3$, $n, m$ \u2014 even integers).\n\nThis is followed by $n$ lines of length $m$, consisting of digits from $0$ to $9$ \u2014 the description of the carpet.\n\nIt is guaranteed that the sum of $n \\cdot m$ across all test cases does not exceed $10^6$.\n\nOutput Format:\nFor each test case, output a single number \u2014 the total number of times $1543$ appears in all layers of the carpet in the order of traversal clockwise.\n\nTags:\n['brute force', 'implementation', 'matrices']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "8\n2 4\n1543\n7777\n2 4\n7154\n8903\n2 4\n3451\n8888\n2 2\n54\n13\n2 2\n51\n43\n2 6\n432015\n512034\n4 4\n5431\n1435\n5518\n7634\n6 4\n5432\n1152\n4542\n2432\n2302\n5942",
                "output": "1\n1\n0\n1\n0\n2\n2\n2"
            }
        ]
    },
    {
        "problem": "\nA conspiracy of ancient sages, who decided to redirect rivers for their own convenience, has put the world on the brink. But before implementing their grand plan, they decided to carefully think through their strategy \u2014 that's what sages do.\n\nThere are $n$ countries, each with exactly $k$ regions. For the $j$-th region of the $i$-th country, they calculated the value $a_{i,j}$, which reflects the amount of water in it.\n\nThe sages intend to create channels between the $j$-th region of the $i$-th country and the $j$-th region of the $(i + 1)$-th country for all $1 \\leq i \\leq (n - 1)$ and for all $1 \\leq j \\leq k$.\n\nSince all $n$ countries are on a large slope, water flows towards the country with the highest number. According to the sages' predictions, after the channel system is created, the new value of the $j$-th region of the $i$-th country will be $b_{i,j} = a_{1,j} | a_{2,j} | ... | a_{i,j}$, where $|$ denotes the [bitwise \"OR\"](http://tiny.cc/bitwise_or) operation.\n\nAfter the redistribution of water, the sages aim to choose the most suitable country for living, so they will send you $q$ queries for consideration.\n\nEach query will contain $m$ requirements.\n\nEach requirement contains three parameters: the region number $r$, the sign $o$ (either \"$<$\" or \"$>$\"), and the value $c$. If $o$ = \"$<$\", then in the $r$-th region of the country you choose, the new value must be strictly less than the limit $c$, and if $o$ = \"$>$\", it must be strictly greater.\n\nIn other words, the chosen country $i$ must satisfy all $m$ requirements. If in the current requirement $o$ = \"$<$\", then it must hold that $b_{i,r} < c$, and if $o$ = \"$>$\", then $b_{i,r} > c$.\n\nIn response to each query, you should output a single integer \u2014 the number of the suitable country. If there are multiple such countries, output the smallest one. If no such country exists, output $-1$.\n\nInput Format:\nThe first line contains three integers $n$, $k$, and $q$ ($1 \\leq n, k, q \\leq 10^5$) \u2014 the number of countries, regions, and queries, respectively.\n\nNext, there are $n$ lines, where the $i$-th line contains $k$ integers $a_{i,1}, a_{i,2}, \\dots, a_{i,k}$ ($1 \\leq a_{i,j} \\leq 10^9$), where $a_{i,j}$ is the value of the $j$-th region of the $i$-th country.\n\nThen, $q$ queries are described.\n\nThe first line of each query contains a single integer $m$ ($1 \\leq m \\leq 10^5$) \u2014 the number of requirements.\n\nThen follow $m$ lines, each containing an integer $r$, a character $o$, and an integer $c$ ($1 \\leq r \\leq k$, $0 \\leq c \\leq 2 \\cdot 10^9$), where $r$ and $c$ are the region number and the value, and $o$ is either \"$<$\" or \"$>$\" \u2014 the sign.\n\nIt is guaranteed that $n \\cdot k$ does not exceed $10^5$ and that the sum of $m$ across all queries also does not exceed $10^5$.\n\nOutput Format:\nFor each query, output a single integer on a new line \u2014 the smallest number of the suitable country, or $-1$ if no such country exists.\n\nTags:\n['binary search', 'constructive algorithms', 'data structures', 'greedy']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "3 4 4\n1 3 5 9\n4 6 5 3\n2 1 2 7\n3\n1 > 4\n2 < 8\n1 < 6\n2\n1 < 8\n2 > 8\n1\n3 > 5\n2\n4 > 8\n1 < 8",
                "output": "2\n-1\n3\n1"
            }
        ]
    },
    {
        "problem": "\nAlice has been giving gifts to Bob for many years, and she knows that what he enjoys the most is performing [bitwise XOR](http://tiny.cc/xor_wiki_eng) of interesting integers. Bob considers a positive integer $x$ to be interesting if it satisfies $x \\not\\equiv k (\\bmod 2^i)$. Therefore, this year for his birthday, she gifted him a super-powerful \"XORificator 3000\", the latest model.\n\nBob was very pleased with the gift, as it allowed him to instantly compute the XOR of all interesting integers in any range from $l$ to $r$, inclusive. After all, what else does a person need for happiness? Unfortunately, the device was so powerful that at one point it performed XOR with itself and disappeared. Bob was very upset, and to cheer him up, Alice asked you to write your version of the \"XORificator\".\n\nInput Format:\nThe first line of input contains a single integer $t$ $(1 \\leq t \\leq 10^4)$ \u2014 the number of XOR queries on the segment. The following $t$ lines contain the queries, each consisting of the integers $l$, $r$, $i$, $k$ $(1 \\leq l \\leq r \\leq 10^{18}$, $0 \\leq i \\leq 30$, $0 \\leq k < 2^i)$.\n\nOutput Format:\nFor each query, output a single integer \u2014 the XOR of all integers $x$ in the range $[l, r]$ such that $x \\not\\equiv k \\mod 2^i$.\n\nTags:\n['bitmasks', 'dp', 'number theory', 'two pointers']\n\nTime Limit: 1000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "6\n1 3 1 0\n2 28 3 7\n15 43 1 0\n57 2007 1 0\n1010 1993 2 2\n1 1000000000 30 1543",
                "output": "2\n2\n13\n0\n4\n1000000519"
            }
        ]
    },
    {
        "problem": "\nThis is an interactive problem.\n\nThe Department of Supernatural Phenomena at the Oxenfurt Academy has opened the Library of Magic, which contains the works of the greatest sorcerers of Redania \u2014 $n$ ($3 \\leq n \\leq 10^{18}$) types of books, numbered from $1$ to $n$. Each book's type number is indicated on its spine. Moreover, each type of book is stored in the library in exactly two copies! And you have been appointed as the librarian.\n\nOne night, you wake up to a strange noise and see a creature leaving the building through a window. Three thick tomes of different colors were sticking out of the mysterious thief's backpack. Before you start searching for them, you decide to compute the numbers $a$, $b$, and $c$ written on the spines of these books. All three numbers are distinct.\n\nSo, you have an unordered set of tomes, which includes one tome with each of the pairwise distinct numbers $a$, $b$, and $c$, and two tomes for all numbers from $1$ to $n$, except for $a$, $b$, and $c$. You want to find these values $a$, $b$, and $c$.\n\nSince you are not working in a simple library, but in the Library of Magic, you can only use one spell in the form of a query to check the presence of books in their place:\n\n  * \"xor l r\" \u2014 Bitwise XOR query with parameters $l$ and $r$. Let $k$ be the number of such tomes in the library whose numbers are greater than or equal to $l$ and less than or equal to $r$. You will receive the result of the computation $v_1 \\oplus v_2 \\oplus ... \\oplus v_k$, where $v_1 ... v_k$ are the numbers on the spines of these tomes, and $\\oplus$ denotes the operation of [bitwise exclusive OR](http://tiny.cc/xor_wiki_eng). \n\nSince your magical abilities as a librarian are severely limited, you can make no more than $150$ queries.\n\nInput Format:\nThe first line of input contains an integer $t$ ($1 \\le t \\le 300$) \u2014 the number of test cases.\n\nThe first line of each test case contains a single integer $n$ ($3 \\leq n \\leq 10^{18}$) \u2014 the number of types of tomes.\n\nOutput Format:\n\n\nTags:\n['binary search', 'bitmasks', 'constructive algorithms', 'divide and conquer', 'flows', 'geometry', 'interactive', 'number theory']\n\nTime Limit: 2000 ms\nMemory Limit: 256 MB\n",
        "tests": [
            {
                "input": "2\n6\n\n0\n\n2\n\n3\n\n5\n\n3",
                "output": "xor 1 1\n\nxor 2 2\n\nxor 3 3\n\nxor 4 6\n\nans 2 3 5\n\nans 1 2 3"
            }
        ]
    }
]
[
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given an array nums of positive integers and an integer k.\nIn one operation, you can remove the last element of the array and add it to your collection.\nReturn the minimum number of operations needed to collect elements 1, 2, ..., k.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def minOperations(self, nums: List[int], k: int) -> int:\n```",
        "solutions": "class Solution:\n    def minOperations(self, nums: List[int], k: int) -> int:\n        is_added = [False] * k\n        count = 0\n        n = len(nums)\n        for i in range(n - 1, -1, -1):\n            if nums[i] > k or is_added[nums[i] - 1]:\n                continue\n            is_added[nums[i] - 1] = True\n            count += 1\n            if count == k:\n                return n - i\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(nums = [3,1,5,4,2], k = 2) == 4\n    assert candidate(nums = [3,1,5,4,2], k = 5) == 5\n    assert candidate(nums = [3,2,5,3,1], k = 3) == 4\n\n\ncheck(Solution().minOperations)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given a 0-indexed array nums of length n containing distinct positive integers. Return the minimum number of right shifts required to sort nums and -1 if this is not possible.\nA right shift is defined as shifting the element at index i to index (i + 1) % n, for all indices.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def minimumRightShifts(self, nums: List[int]) -> int:\n```",
        "solutions": "class Solution:\n    def minimumRightShifts(self, nums: List[int]) -> int:\n        n = len(nums)\n        i = 1\n        while i < n and nums[i - 1] < nums[i]:\n            i += 1\n        k = i + 1\n        while k < n and nums[k - 1] < nums[k] < nums[0]:\n            k += 1\n        return -1 if k < n else n - i\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(nums = [3,4,5,1,2]) == 2\n    assert candidate(nums = [1,3,5]) == 0\n    assert candidate(nums = [2,1,4]) == -1\n\n\ncheck(Solution().minimumRightShifts)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given a 1-indexed array nums. Your task is to select a complete subset from nums where every pair of selected indices multiplied is a perfect square,. i. e. if you select ai and aj, i * j must be a perfect square.\nReturn the sum of the complete subset with the maximum sum.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def maximumSum(self, nums: List[int]) -> int:\n```",
        "solutions": "class Solution:\n    def maximumSum(self, nums: List[int]) -> int:\n        n = len(nums)\n        ans = 0\n        for k in range(1, n + 1):\n            t = 0\n            j = 1\n            while k * j * j <= n:\n                t += nums[k * j * j - 1]\n                j += 1\n            ans = max(ans, t)\n        return ans\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(nums = [8,7,3,5,7,2,4,9]) == 16\n    assert candidate(nums = [8,10,3,8,1,13,7,9,4]) == 20\n\n\ncheck(Solution().maximumSum)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given a binary string s that contains at least one '1'.\nYou have to rearrange the bits in such a way that the resulting binary number is the maximum odd binary number that can be created from this combination.\nReturn a string representing the maximum odd binary number that can be created from the given combination.\nNote that the resulting string can have leading zeros.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def maximumOddBinaryNumber(self, s: str) -> str:\n```",
        "solutions": "class Solution:\n    def maximumOddBinaryNumber(self, s: str) -> str:\n        cnt = s.count(\"1\")\n        return \"1\" * (cnt - 1) + (len(s) - cnt) * \"0\" + \"1\"\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(s = \"010\") == \"001\"\n    assert candidate(s = \"0101\") == \"1001\"\n\n\ncheck(Solution().maximumOddBinaryNumber)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given four integers sx, sy, fx, fy, and a non-negative integer t.\nIn an infinite 2D grid, you start at the cell (sx, sy). Each second, you must move to any of its adjacent cells.\nReturn true if you can reach cell (fx, fy) after exactly t seconds, or false otherwise.\nA cell's adjacent cells are the 8 cells around it that share at least one corner with it. You can visit the same cell several times.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def isReachableAtTime(self, sx: int, sy: int, fx: int, fy: int, t: int) -> bool:\n```",
        "solutions": "class Solution:\n    def isReachableAtTime(self, sx: int, sy: int, fx: int, fy: int, t: int) -> bool:\n        if sx == fx and sy == fy:\n            return t != 1\n        dx = abs(sx - fx)\n        dy = abs(sy - fy)\n        return max(dx, dy) <= t\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(sx = 2, sy = 4, fx = 7, fy = 7, t = 6) == True\n    assert candidate(sx = 3, sy = 1, fx = 7, fy = 3, t = 3) == False\n\n\ncheck(Solution().isReachableAtTime)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nThere is an undirected tree with n nodes labeled from 0 to n - 1. You are given the integer n and a 2D integer array edges of length n - 1, where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree.\nYou are also given a 0-indexed integer array values of length n, where values[i] is the value associated with the ith node, and an integer k.\nA valid split of the tree is obtained by removing any set of edges, possibly empty, from the tree such that the resulting components all have values that are divisible by k, where the value of a connected component is the sum of the values of its nodes.\nReturn the maximum number of components in any valid split.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def maxKDivisibleComponents(self, n: int, edges: List[List[int]], values: List[int], k: int) -> int:\n```",
        "solutions": "class Solution:\n    def maxKDivisibleComponents(\n        self, n: int, edges: List[List[int]], values: List[int], k: int\n    ) -> int:\n        def dfs(i: int, fa: int) -> int:\n            s = values[i]\n            for j in g[i]:\n                if j != fa:\n                    s += dfs(j, i)\n            nonlocal ans\n            ans += s % k == 0\n            return s\n\n        g = [[] for _ in range(n)]\n        for a, b in edges:\n            g[a].append(b)\n            g[b].append(a)\n        ans = 0\n        dfs(0, -1)\n        return ans\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(n = 5, edges = [[0,2],[1,2],[1,3],[2,4]], values = [1,8,1,4,4], k = 6) == 2\n    assert candidate(n = 7, edges = [[0,1],[0,2],[1,3],[1,4],[2,5],[2,6]], values = [3,0,6,1,5,2,1], k = 3) == 3\n\n\ncheck(Solution().maxKDivisibleComponents)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nThere is an undirected tree with n nodes labeled from 0 to n - 1. You are given the integer n and a 2D integer array edges of length n - 1, where edges[i] = [ui, vi, wi] indicates that there is an edge between nodes ui and vi with weight wi in the tree.\nYou are also given a 2D integer array queries of length m, where queries[i] = [ai, bi]. For each query, find the minimum number of operations required to make the weight of every edge on the path from ai to bi equal. In one operation, you can choose any edge of the tree and change its weight to any value.\nNote that:\n\nQueries are independent of each other, meaning that the tree returns to its initial state on each new query.\nThe path from ai to bi is a sequence of distinct nodes starting with node ai and ending with node bi such that every two adjacent nodes in the sequence share an edge in the tree.\n\nReturn an array answer of length m where answer[i] is the answer to the ith query.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def minOperationsQueries(self, n: int, edges: List[List[int]], queries: List[List[int]]) -> List[int]:\n```",
        "solutions": "class Solution:\n    def minOperationsQueries(\n        self, n: int, edges: List[List[int]], queries: List[List[int]]\n    ) -> List[int]:\n        m = n.bit_length()\n        g = [[] for _ in range(n)]\n        f = [[0] * m for _ in range(n)]\n        p = [0] * n\n        cnt = [None] * n\n        depth = [0] * n\n        for u, v, w in edges:\n            g[u].append((v, w - 1))\n            g[v].append((u, w - 1))\n        cnt[0] = [0] * 26\n        q = deque([0])\n        while q:\n            i = q.popleft()\n            f[i][0] = p[i]\n            for j in range(1, m):\n                f[i][j] = f[f[i][j - 1]][j - 1]\n            for j, w in g[i]:\n                if j != p[i]:\n                    p[j] = i\n                    cnt[j] = cnt[i][:]\n                    cnt[j][w] += 1\n                    depth[j] = depth[i] + 1\n                    q.append(j)\n        ans = []\n        for u, v in queries:\n            x, y = u, v\n            if depth[x] < depth[y]:\n                x, y = y, x\n            for j in reversed(range(m)):\n                if depth[x] - depth[y] >= (1 << j):\n                    x = f[x][j]\n            for j in reversed(range(m)):\n                if f[x][j] != f[y][j]:\n                    x, y = f[x][j], f[y][j]\n            if x != y:\n                x = p[x]\n            mx = max(cnt[u][j] + cnt[v][j] - 2 * cnt[x][j] for j in range(26))\n            ans.append(depth[u] + depth[v] - 2 * depth[x] - mx)\n        return ans\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(n = 7, edges = [[0,1,1],[1,2,1],[2,3,1],[3,4,2],[4,5,2],[5,6,2]], queries = [[0,3],[3,6],[2,6],[0,6]]) == [0,0,1,3]\n    assert candidate(n = 8, edges = [[1,2,6],[1,3,4],[2,4,6],[2,5,3],[3,6,6],[3,0,8],[7,0,2]], queries = [[4,6],[0,4],[6,5],[7,4]]) == [1,2,2,3]\n\n\ncheck(Solution().minOperationsQueries)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given an array nums consisting of non-negative integers.\nWe define the score of subarray nums[l..r] such that l <= r as nums[l] AND nums[l + 1] AND ... AND nums[r] where AND is the bitwise AND operation.\nConsider splitting the array into one or more subarrays such that the following conditions are satisfied:\n\nEach element of the array belongs to exactly one subarray.\nThe sum of scores of the subarrays is the minimum possible.\n\nReturn the maximum number of subarrays in a split that satisfies the conditions above.\nA subarray is a contiguous part of an array.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def maxSubarrays(self, nums: List[int]) -> int:\n```",
        "solutions": "class Solution:\n    def maxSubarrays(self, nums: List[int]) -> int:\n        score, ans = -1, 1\n        for num in nums:\n            score &= num\n            if score == 0:\n                score = -1\n                ans += 1\n        return 1 if ans == 1 else ans - 1\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(nums = [1,0,2,0,1,2]) == 3\n    assert candidate(nums = [5,7,1,3]) == 1\n\n\ncheck(Solution().maxSubarrays)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nGiven an integer array num sorted in non-decreasing order.\nYou can perform the following operation any number of times:\n\nChoose two indices, i and j, where nums[i] < nums[j].\nThen, remove the elements at indices i and j from nums. The remaining elements retain their original order, and the array is re-indexed.\n\nReturn the minimum length of nums after applying the operation zero or more times.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def minLengthAfterRemovals(self, nums: List[int]) -> int:\n```",
        "solutions": "class Solution:\n    def minLengthAfterRemovals(self, nums: List[int]) -> int:\n        cnt = Counter(nums)\n        pq = [-x for x in cnt.values()]\n        heapify(pq)\n        ans = len(nums)\n        while len(pq) > 1:\n            x, y = -heappop(pq), -heappop(pq)\n            x -= 1\n            y -= 1\n            if x > 0:\n                heappush(pq, -x)\n            if y > 0:\n                heappush(pq, -y)\n            ans -= 2\n        return ans\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(nums = [1,3,4,9]) == 0\n    assert candidate(nums = [2,3,6,9]) == 0\n    assert candidate(nums = [1,1,2]) == 1\n\n\ncheck(Solution().minLengthAfterRemovals)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given a 0-indexed array nums of distinct integers.\nLet us define a 0-indexed array ans of the same length as nums in the following way:\n\nans[i] is the maximum length of a subarray nums[l..r], such that the maximum element in that subarray is equal to nums[i].\n\nReturn the array ans.\nNote that a subarray is a contiguous part of the array.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def maximumLengthOfRanges(self, nums: List[int]) -> List[int]:\n```",
        "solutions": "class Solution:\n    def maximumLengthOfRanges(self, nums: List[int]) -> List[int]:\n        n = len(nums)\n        left = [-1] * n\n        right = [n] * n\n        stk = []\n        for i, x in enumerate(nums):\n            while stk and nums[stk[-1]] <= x:\n                stk.pop()\n            if stk:\n                left[i] = stk[-1]\n            stk.append(i)\n        stk = []\n        for i in range(n - 1, -1, -1):\n            while stk and nums[stk[-1]] <= nums[i]:\n                stk.pop()\n            if stk:\n                right[i] = stk[-1]\n            stk.append(i)\n        return [r - l - 1 for l, r in zip(left, right)]\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(nums = [1,5,4,3,6]) == [1,4,2,1,5]\n    assert candidate(nums = [1,2,3,4,5]) == [1,2,3,4,5]\n\n\ncheck(Solution().maximumLengthOfRanges)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given a 0-indexed 2D integer matrix grid of size 3 * 3, representing the number of stones in each cell. The grid contains exactly 9 stones, and there can be multiple stones in a single cell.\nIn one move, you can move a single stone from its current cell to any other cell if the two cells share a side.\nReturn the minimum number of moves required to place one stone in each cell.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def minimumMoves(self, grid: List[List[int]]) -> int:\n```",
        "solutions": "class Solution:\n    def minimumMoves(self, grid: List[List[int]]) -> int:\n        q = deque([tuple(tuple(row) for row in grid)])\n        vis = set(q)\n        ans = 0\n        dirs = (-1, 0, 1, 0, -1)\n        while 1:\n            for _ in range(len(q)):\n                cur = q.popleft()\n                if all(x for row in cur for x in row):\n                    return ans\n                for i in range(3):\n                    for j in range(3):\n                        if cur[i][j] > 1:\n                            for a, b in pairwise(dirs):\n                                x, y = i + a, j + b\n                                if 0 <= x < 3 and 0 <= y < 3 and cur[x][y] < 2:\n                                    nxt = [list(row) for row in cur]\n                                    nxt[i][j] -= 1\n                                    nxt[x][y] += 1\n                                    nxt = tuple(tuple(row) for row in nxt)\n                                    if nxt not in vis:\n                                        vis.add(nxt)\n                                        q.append(nxt)\n            ans += 1\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(grid = [[1,1,0],[1,1,1],[1,2,1]]) == 3\n    assert candidate(grid = [[1,3,0],[1,0,0],[1,0,3]]) == 4\n\n\ncheck(Solution().minimumMoves)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given a 0-indexed array nums consisting of positive integers.\nThere are two types of operations that you can apply on the array any number of times:\n\nChoose two elements with equal values and delete them from the array.\nChoose three elements with equal values and delete them from the array.\n\nReturn the minimum number of operations required to make the array empty, or -1 if it is not possible.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def minOperations(self, nums: List[int]) -> int:\n```",
        "solutions": "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        count = Counter(nums)\n        ans = 0\n        for c in count.values():\n            if c == 1:\n                return -1\n            ans += (c + 2) // 3\n        return ans\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(nums = [2,3,3,2,2,4,2,3,4]) == 4\n    assert candidate(nums = [2,1,2,2,3,3]) == -1\n\n\ncheck(Solution().minOperations)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are the owner of a company that creates alloys using various types of metals. There are n different types of metals available, and you have access to k machines that can be used to create alloys. Each machine requires a specific amount of each metal type to create an alloy.\nFor the ith machine to create an alloy, it needs composition[i][j] units of metal of type j. Initially, you have stock[i] units of metal type i, and purchasing one unit of metal type i costs cost[i] coins.\nGiven integers n, k, budget, a 1-indexed 2D array composition, and 1-indexed arrays stock and cost, your goal is to maximize the number of alloys the company can create while staying within the budget of budget coins.\nAll alloys must be created with the same machine.\nReturn the maximum number of alloys that the company can create.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def maxNumberOfAlloys(self, n: int, k: int, budget: int, composition: List[List[int]], stock: List[int], cost: List[int]) -> int:\n```",
        "solutions": "class Solution:\n    def maxNumberOfAlloys(\n        self,\n        n: int,\n        k: int,\n        budget: int,\n        composition: List[List[int]],\n        stock: List[int],\n        cost: List[int],\n    ) -> int:\n        ans = 0\n        for c in composition:\n            l, r = 0, budget + stock[0]\n            while l < r:\n                mid = (l + r + 1) >> 1\n                s = sum(max(0, mid * x - y) * z for x, y, z in zip(c, stock, cost))\n                if s <= budget:\n                    l = mid\n                else:\n                    r = mid - 1\n            ans = max(ans, l)\n        return ans\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(n = 3, k = 2, budget = 15, composition = [[1,1,1],[1,1,10]], stock = [0,0,0], cost = [1,2,3]) == 2\n    assert candidate(n = 3, k = 2, budget = 15, composition = [[1,1,1],[1,1,10]], stock = [0,0,100], cost = [1,2,3]) == 5\n    assert candidate(n = 2, k = 3, budget = 10, composition = [[2,1],[1,2],[1,1]], stock = [1,1], cost = [5,5]) == 2\n\n\ncheck(Solution().maxNumberOfAlloys)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given a 0-indexed integer array nums of length n where n is the total number of students in the class. The class teacher tries to select a group of students so that all the students remain happy.\nThe ith student will become happy if one of these two conditions is met:\n\nThe student is selected and the total number of selected students is strictly greater than nums[i].\nThe student is not selected and the total number of selected students is strictly less than nums[i].\n\nReturn the number of ways to select a group of students so that everyone remains happy.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def countWays(self, nums: List[int]) -> int:\n```",
        "solutions": "class Solution:\n    def countWays(self, nums: List[int]) -> int:\n        nums.sort()\n        n = len(nums)\n        ans = 0\n        for i in range(n + 1):\n            if i and nums[i - 1] >= i:\n                continue\n            if i < n and nums[i] <= i:\n                continue\n            ans += 1\n        return ans\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(nums = [1,1]) == 2\n    assert candidate(nums = [6,0,3,3,6,7,2,7]) == 3\n\n\ncheck(Solution().countWays)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nThere is a simple directed graph with n nodes labeled from 0 to n - 1. The graph would form a tree if its edges were bi-directional.\nYou are given an integer n and a 2D integer array edges, where edges[i] = [ui, vi] represents a directed edge going from node ui to node vi.\nAn edge reversal changes the direction of an edge, i.e., a directed edge going from node ui to node vi becomes a directed edge going from node vi to node ui.\nFor every node i in the range [0, n - 1], your task is to independently calculate the minimum number of edge reversals required so it is possible to reach any other node starting from node i through a sequence of directed edges.\nReturn an integer array answer, where answer[i] is the  minimum number of edge reversals required so it is possible to reach any other node starting from node i through a sequence of directed edges.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def minEdgeReversals(self, n: int, edges: List[List[int]]) -> List[int]:\n```",
        "solutions": "class Solution:\n    def minEdgeReversals(self, n: int, edges: List[List[int]]) -> List[int]:\n        ans = [0] * n\n        g = [[] for _ in range(n)]\n        for x, y in edges:\n            g[x].append((y, 1))\n            g[y].append((x, -1))\n\n        def dfs(i: int, fa: int):\n            for j, k in g[i]:\n                if j != fa:\n                    ans[0] += int(k < 0)\n                    dfs(j, i)\n\n        dfs(0, -1)\n\n        def dfs2(i: int, fa: int):\n            for j, k in g[i]:\n                if j != fa:\n                    ans[j] = ans[i] + k\n                    dfs2(j, i)\n\n        dfs2(0, -1)\n        return ans\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(n = 4, edges = [[2,0],[2,1],[1,3]]) == [1,1,0,2]\n    assert candidate(n = 3, edges = [[1,2],[2,0]]) == [2,0,1]\n\n\ncheck(Solution().minEdgeReversals)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given a 0-indexed array of integers nums, and an integer target.\nReturn the length of the longest subsequence of nums that sums up to target. If no such subsequence exists, return -1.\nA subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def lengthOfLongestSubsequence(self, nums: List[int], target: int) -> int:\n```",
        "solutions": "class Solution:\n    def lengthOfLongestSubsequence(self, nums: List[int], target: int) -> int:\n        n = len(nums)\n        f = [[-inf] * (target + 1) for _ in range(n + 1)]\n        f[0][0] = 0\n        for i, x in enumerate(nums, 1):\n            for j in range(target + 1):\n                f[i][j] = f[i - 1][j]\n                if j >= x:\n                    f[i][j] = max(f[i][j], f[i - 1][j - x] + 1)\n        return -1 if f[n][target] <= 0 else f[n][target]\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(nums = [1,2,3,4,5], target = 9) == 3\n    assert candidate(nums = [4,1,3,2,1,5], target = 7) == 4\n    assert candidate(nums = [1,1,5,4,5], target = 3) == -1\n\n\ncheck(Solution().lengthOfLongestSubsequence)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given a 0-indexed m * n integer matrix values, representing the values of m * n different items in m different shops. Each shop has n items where the jth item in the ith shop has a value of values[i][j]. Additionally, the items in the ith shop are sorted in non-increasing order of value. That is, values[i][j] >= values[i][j + 1] for all 0 <= j < n - 1.\nOn each day, you would like to buy a single item from one of the shops. Specifically, On the dth day you can:\n\nPick any shop i.\nBuy the rightmost available item j for the price of values[i][j] * d. That is, find the greatest index j such that item j was never bought before, and buy it for the price of values[i][j] * d.\n\nNote that all items are pairwise different. For example, if you have bought item 0 from shop 1, you can still buy item 0 from any other shop.\nReturn the maximum amount of money that can be spent on buying all  m * n products.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def maxSpending(self, values: List[List[int]]) -> int:\n```",
        "solutions": "class Solution:\n    def maxSpending(self, values: List[List[int]]) -> int:\n        n = len(values[0])\n        pq = [(row[-1], i, n - 1) for i, row in enumerate(values)]\n        heapify(pq)\n        ans = d = 0\n        while pq:\n            d += 1\n            v, i, j = heappop(pq)\n            ans += v * d\n            if j:\n                heappush(pq, (values[i][j - 1], i, j - 1))\n        return ans\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(values = [[8,5,2],[6,4,1],[9,7,3]]) == 285\n    assert candidate(values = [[10,8,6,4,2],[9,7,5,3,2]]) == 386\n\n\ncheck(Solution().maxSpending)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nGiven a positive integer n, return a string representing the smallest positive integer such that the product of its digits is equal to n, or \"-1\" if no such number exists.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def smallestNumber(self, n: int) -> str:\n```",
        "solutions": "class Solution:\n    def smallestNumber(self, n: int) -> str:\n        cnt = [0] * 10\n        for i in range(9, 1, -1):\n            while n % i == 0:\n                n //= i\n                cnt[i] += 1\n        if n > 1:\n            return \"-1\"\n        ans = \"\".join(str(i) * cnt[i] for i in range(2, 10))\n        return ans if ans else \"1\"\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(n = 105) == \"357\"\n    assert candidate(n = 7) == \"7\"\n    assert candidate(n = 44) == \"-1\"\n\n\ncheck(Solution().smallestNumber)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nThere is an undirected tree with n nodes labeled from 1 to n. You are given the integer n and a 2D integer array edges of length n - 1, where edges[i] = [ui, vi] indicates that there is an edge between nodes ui and vi in the tree.\nReturn the number of valid paths in the tree.\nA path (a, b) is valid if there exists exactly one prime number among the node labels in the path from a to b.\nNote that:\n\nThe path (a, b) is a sequence of distinct nodes starting with node a and ending with node b such that every two adjacent nodes in the sequence share an edge in the tree.\nPath (a, b) and path (b, a) are considered the same and counted only once.\n\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def countPaths(self, n: int, edges: List[List[int]]) -> int:\n```",
        "solutions": "class UnionFind:\n    def __init__(self, n):\n        self.p = list(range(n))\n        self.size = [1] * n\n\n    def find(self, x):\n        if self.p[x] != x:\n            self.p[x] = self.find(self.p[x])\n        return self.p[x]\n\n    def union(self, a, b):\n        pa, pb = self.find(a), self.find(b)\n        if pa == pb:\n            return False\n        if self.size[pa] > self.size[pb]:\n            self.p[pb] = pa\n            self.size[pa] += self.size[pb]\n        else:\n            self.p[pa] = pb\n            self.size[pb] += self.size[pa]\n        return True\n\n\nmx = 10**5 + 10\nprime = [True] * (mx + 1)\nprime[0] = prime[1] = False\nfor i in range(2, mx + 1):\n    if prime[i]:\n        for j in range(i * i, mx + 1, i):\n            prime[j] = False\n\n\nclass Solution:\n    def countPaths(self, n: int, edges: List[List[int]]) -> int:\n        g = [[] for _ in range(n + 1)]\n        uf = UnionFind(n + 1)\n        for u, v in edges:\n            g[u].append(v)\n            g[v].append(u)\n            if prime[u] + prime[v] == 0:\n                uf.union(u, v)\n\n        ans = 0\n        for i in range(1, n + 1):\n            if prime[i]:\n                t = 0\n                for j in g[i]:\n                    if not prime[j]:\n                        cnt = uf.size[uf.find(j)]\n                        ans += cnt\n                        ans += t * cnt\n                        t += cnt\n        return ans\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(n = 5, edges = [[1,2],[1,3],[2,4],[2,5]]) == 4\n    assert candidate(n = 6, edges = [[1,2],[1,3],[2,4],[3,5],[3,6]]) == 6\n\n\ncheck(Solution().countPaths)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given a 0-indexed array maxHeights of n integers.\nYou are tasked with building n towers in the coordinate line. The ith tower is built at coordinate i and has a height of heights[i].\nA configuration of towers is beautiful if the following conditions hold:\n\n1 <= heights[i] <= maxHeights[i]\nheights is a mountain array.\n\nArray heights is a mountain if there exists an index i such that:\n\nFor all 0 < j <= i, heights[j - 1] <= heights[j]\nFor all i <= k < n - 1, heights[k + 1] <= heights[k]\n\nReturn the maximum possible sum of heights of a beautiful configuration of towers.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def maximumSumOfHeights(self, maxHeights: List[int]) -> int:\n```",
        "solutions": "class Solution:\n    def maximumSumOfHeights(self, maxHeights: List[int]) -> int:\n        n = len(maxHeights)\n        stk = []\n        left = [-1] * n\n        for i, x in enumerate(maxHeights):\n            while stk and maxHeights[stk[-1]] > x:\n                stk.pop()\n            if stk:\n                left[i] = stk[-1]\n            stk.append(i)\n        stk = []\n        right = [n] * n\n        for i in range(n - 1, -1, -1):\n            x = maxHeights[i]\n            while stk and maxHeights[stk[-1]] >= x:\n                stk.pop()\n            if stk:\n                right[i] = stk[-1]\n            stk.append(i)\n        f = [0] * n\n        for i, x in enumerate(maxHeights):\n            if i and x >= maxHeights[i - 1]:\n                f[i] = f[i - 1] + x\n            else:\n                j = left[i]\n                f[i] = x * (i - j) + (f[j] if j != -1 else 0)\n        g = [0] * n\n        for i in range(n - 1, -1, -1):\n            if i < n - 1 and maxHeights[i] >= maxHeights[i + 1]:\n                g[i] = g[i + 1] + maxHeights[i]\n            else:\n                j = right[i]\n                g[i] = maxHeights[i] * (j - i) + (g[j] if j != n else 0)\n        return max(a + b - c for a, b, c in zip(f, g, maxHeights))\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(maxHeights = [5,3,4,1,1]) == 13\n    assert candidate(maxHeights = [6,5,3,9,2,7]) == 22\n    assert candidate(maxHeights = [3,2,5,5,2,3]) == 18\n\n\ncheck(Solution().maximumSumOfHeights)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given an array heights of n integers representing the number of bricks in n consecutive towers. Your task is to remove some bricks to form a mountain-shaped tower arrangement. In this arrangement, the tower heights are non-decreasing, reaching a maximum peak value with one or multiple consecutive towers and then non-increasing.\nReturn the maximum possible sum of heights of a mountain-shaped tower arrangement.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def maximumSumOfHeights(self, maxHeights: List[int]) -> int:\n```",
        "solutions": "class Solution:\n    def maximumSumOfHeights(self, maxHeights: List[int]) -> int:\n        ans, n = 0, len(maxHeights)\n        for i, x in enumerate(maxHeights):\n            y = t = x\n            for j in range(i - 1, -1, -1):\n                y = min(y, maxHeights[j])\n                t += y\n            y = x\n            for j in range(i + 1, n):\n                y = min(y, maxHeights[j])\n                t += y\n            ans = max(ans, t)\n        return ans\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(maxHeights = [5,3,4,1,1]) == 13\n    assert candidate(maxHeights = [6,5,3,9,2,7]) == 22\n    assert candidate(maxHeights = [3,2,5,5,2,3]) == 18\n\n\ncheck(Solution().maximumSumOfHeights)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nThere is a directed graph consisting of n nodes numbered from 0 to n - 1 and n directed edges.\nYou are given a 0-indexed array edges where edges[i] indicates that there is an edge from node i to node edges[i].\nConsider the following process on the graph:\n\nYou start from a node x and keep visiting other nodes through edges until you reach a node that you have already visited before on this same process.\n\nReturn an array answer where answer[i] is the number of different nodes that you will visit if you perform the process starting from node i.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def countVisitedNodes(self, edges: List[int]) -> List[int]:\n```",
        "solutions": "class Solution:\n    def countVisitedNodes(self, edges: List[int]) -> List[int]:\n        n = len(edges)\n        ans = [0] * n\n        vis = [0] * n\n        for i in range(n):\n            if not ans[i]:\n                cnt, j = 0, i\n                while not vis[j]:\n                    cnt += 1\n                    vis[j] = cnt\n                    j = edges[j]\n                cycle, total = 0, cnt + ans[j]\n                if not ans[j]:\n                    cycle = cnt - vis[j] + 1\n                    total = cnt\n                j = i\n                while not ans[j]:\n                    ans[j] = max(total, cycle)\n                    total -= 1\n                    j = edges[j]\n        return ans\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(edges = [1,2,0,0]) == [3,3,3,4]\n    assert candidate(edges = [1,2,3,4,0]) == [5,5,5,5,5]\n\n\ncheck(Solution().countVisitedNodes)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given a string array words and a binary array groups both of length n, where words[i] is associated with groups[i].\nYour task is to select the longest alternating subsequence from words. A subsequence of words is alternating if for any two consecutive strings in the sequence, their corresponding elements in the binary array groups differ. Essentially, you are to choose strings such that adjacent elements have non-matching corresponding bits in the groups array.\nFormally, you need to find the longest subsequence of an array of indices [0, 1, ..., n - 1] denoted as [i0, i1, ..., ik-1], such that groups[ij] != groups[ij+1] for each 0 <= j < k - 1 and then find the words corresponding to these indices.\nReturn the selected subsequence. If there are multiple answers, return any of them.\nNote: The elements in words are distinct.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def getWordsInLongestSubsequence(self, n: int, words: List[str], groups: List[int]) -> List[str]:\n```",
        "solutions": "class Solution:\n    def getWordsInLongestSubsequence(\n        self, n: int, words: List[str], groups: List[int]\n    ) -> List[str]:\n        return [words[i] for i, x in enumerate(groups) if i == 0 or x != groups[i - 1]]\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(n = 3, words = [\"e\",\"a\",\"b\"], groups = [0,0,1]) == [\"e\",\"b\"]\n    assert candidate(n = 4, words = [\"a\",\"b\",\"c\",\"d\"], groups = [1,0,1,1]) == [\"a\",\"b\",\"c\"]\n\n\ncheck(Solution().getWordsInLongestSubsequence)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given a binary string s and a positive integer k.\nA substring of s is beautiful if the number of 1's in it is exactly k.\nLet len be the length of the shortest beautiful substring.\nReturn the lexicographically smallest beautiful substring of string s with length equal to len. If s doesn't contain a beautiful substring, return an empty string.\nA string a is lexicographically larger than a string b (of the same length) if in the first position where a and b differ, a has a character strictly larger than the corresponding character in b.\n\nFor example, \"abcd\" is lexicographically larger than \"abcc\" because the first position they differ is at the fourth character, and d is greater than c.\n\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def shortestBeautifulSubstring(self, s: str, k: int) -> str:\n```",
        "solutions": "class Solution:\n    def shortestBeautifulSubstring(self, s: str, k: int) -> str:\n        n = len(s)\n        ans = \"\"\n        for i in range(n):\n            for j in range(i + k, n + 1):\n                t = s[i:j]\n                if t.count(\"1\") == k and (\n                    not ans or j - i < len(ans) or (j - i == len(ans) and t < ans)\n                ):\n                    ans = t\n        return ans\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(s = \"100011001\", k = 3) == \"11001\"\n    assert candidate(s = \"1011\", k = 2) == \"11\"\n    assert candidate(s = \"000\", k = 1) == \"\"\n\n\ncheck(Solution().shortestBeautifulSubstring)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou have a certain number of processors, each having 4 cores. The number of tasks to be executed is four times the number of processors. Each task must be assigned to a unique core, and each core can only be used once.\nYou are given an array processorTime representing the time each processor becomes available and an array tasks representing how long each task takes to complete. Return the\u00a0minimum time needed to complete all tasks.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def minProcessingTime(self, processorTime: List[int], tasks: List[int]) -> int:\n```",
        "solutions": "class Solution:\n    def minProcessingTime(self, processorTime: List[int], tasks: List[int]) -> int:\n        processorTime.sort()\n        tasks.sort()\n        ans = 0\n        i = len(tasks) - 1\n        for t in processorTime:\n            ans = max(ans, t + tasks[i])\n            i -= 4\n        return ans\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(processorTime = [8,10], tasks = [2,2,3,1,8,7,4,5]) == 16\n    assert candidate(processorTime = [10,20], tasks = [2,3,1,2,5,8,4,3]) == 23\n\n\ncheck(Solution().minProcessingTime)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given a 0-indexed integer array nums.\nReturn the maximum value over all triplets of indices (i, j, k) such that i < j < k. If all such triplets have a negative value, return 0.\nThe value of a triplet of indices (i, j, k) is equal to (nums[i] - nums[j]) * nums[k].\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def maximumTripletValue(self, nums: List[int]) -> int:\n```",
        "solutions": "class Solution:\n    def maximumTripletValue(self, nums: List[int]) -> int:\n        ans = mx = mx_diff = 0\n        for num in nums:\n            ans = max(ans, mx_diff * num)\n            mx = max(mx, num)\n            mx_diff = max(mx_diff, mx - num)\n        return ans\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(nums = [12,6,1,2,7]) == 77\n    assert candidate(nums = [1,10,3,4,19]) == 133\n    assert candidate(nums = [1,2,3]) == 0\n\n\ncheck(Solution().maximumTripletValue)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given a 0-indexed integer array nums and a positive integer k.\nYou can do the following operation on the array any number of times:\n\nChoose any two distinct indices i and j and simultaneously update the values of nums[i] to (nums[i] AND nums[j]) and nums[j] to (nums[i] OR nums[j]). Here, OR denotes the bitwise OR operation, and AND denotes the bitwise AND operation.\n\nYou have to choose k elements from the final array and calculate the sum of their squares.\nReturn the maximum sum of squares you can achieve.\nSince the answer can be very large, return it modulo 109 + 7.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def maxSum(self, nums: List[int], k: int) -> int:\n```",
        "solutions": "class Solution:\n    def maxSum(self, nums: List[int], k: int) -> int:\n        mod = 10**9 + 7\n        cnt = [0] * 31\n        for x in nums:\n            for i in range(31):\n                if x >> i & 1:\n                    cnt[i] += 1\n        ans = 0\n        for _ in range(k):\n            x = 0\n            for i in range(31):\n                if cnt[i]:\n                    x |= 1 << i\n                    cnt[i] -= 1\n            ans = (ans + x * x) % mod\n        return ans\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(nums = [2,6,5,8], k = 2) == 261\n    assert candidate(nums = [4,5,4,7], k = 3) == 90\n\n\ncheck(Solution().maxSum)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given a 0-indexed integer array nums.\nReturn the maximum value over all triplets of indices (i, j, k) such that i < j < k. If all such triplets have a negative value, return 0.\nThe value of a triplet of indices (i, j, k) is equal to (nums[i] - nums[j]) * nums[k].\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def maximumTripletValue(self, nums: List[int]) -> int:\n```",
        "solutions": "class Solution:\n    def maximumTripletValue(self, nums: List[int]) -> int:\n        ans = mx = mx_diff = 0\n        for num in nums:\n            ans = max(ans, mx_diff * num)\n            mx = max(mx, num)\n            mx_diff = max(mx_diff, mx - num)\n        return ans\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(nums = [12,6,1,2,7]) == 77\n    assert candidate(nums = [1,10,3,4,19]) == 133\n    assert candidate(nums = [1,2,3]) == 0\n\n\ncheck(Solution().maximumTripletValue)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given an integer array nums.\nReturn the length of the longest semi-decreasing subarray of nums, and 0 if there are no such subarrays.\n\nA subarray is a contiguous non-empty sequence of elements within an array.\nA non-empty array is semi-decreasing if its first element is strictly greater than its last element.\n\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def maxSubarrayLength(self, nums: List[int]) -> int:\n```",
        "solutions": "class Solution:\n    def maxSubarrayLength(self, nums: List[int]) -> int:\n        d = defaultdict(list)\n        for i, x in enumerate(nums):\n            d[x].append(i)\n        ans, k = 0, inf\n        for x in sorted(d, reverse=True):\n            ans = max(ans, d[x][-1] - k + 1)\n            k = min(k, d[x][0])\n        return ans\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(nums = [7,6,5,4,3,2,1,6,10,11]) == 8\n    assert candidate(nums = [57,55,50,60,61,58,63,59,64,60,63]) == 6\n    assert candidate(nums = [1,2,3,4]) == 0\n\n\ncheck(Solution().maxSubarrayLength)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given a 0-indexed integer array nums.\nThe distinct count of a subarray of nums is defined as:\n\nLet nums[i..j] be a subarray of nums consisting of all the indices from i to j such that 0 <= i <= j < nums.length. Then the number of distinct values in nums[i..j] is called the distinct count of nums[i..j].\n\nReturn the sum of the squares of distinct counts of all subarrays of nums.\nA subarray is a contiguous non-empty sequence of elements within an array.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def sumCounts(self, nums: List[int]) -> int:\n```",
        "solutions": "class Solution:\n    def sumCounts(self, nums: List[int]) -> int:\n        ans, n = 0, len(nums)\n        for i in range(n):\n            s = set()\n            for j in range(i, n):\n                s.add(nums[j])\n                ans += len(s) * len(s)\n        return ans\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(nums = [1,2,1]) == 15\n    assert candidate(nums = [2,2]) == 3\n\n\ncheck(Solution().sumCounts)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given a 0-indexed integer array nums having length n, an integer indexDifference, and an integer valueDifference.\nYour task is to find two indices i and j, both in the range [0, n - 1], that satisfy the following conditions:\n\nabs(i - j) >= indexDifference, and\nabs(nums[i] - nums[j]) >= valueDifference\n\nReturn an integer array answer, where answer = [i, j] if there are two such indices, and answer = [-1, -1] otherwise. If there are multiple choices for the two indices, return any of them.\nNote: i and j may be equal.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def findIndices(self, nums: List[int], indexDifference: int, valueDifference: int) -> List[int]:\n```",
        "solutions": "class Solution:\n    def findIndices(\n        self, nums: List[int], indexDifference: int, valueDifference: int\n    ) -> List[int]:\n        mi = mx = 0\n        for i in range(indexDifference, len(nums)):\n            j = i - indexDifference\n            if nums[j] < nums[mi]:\n                mi = j\n            if nums[j] > nums[mx]:\n                mx = j\n            if nums[i] - nums[mi] >= valueDifference:\n                return [mi, i]\n            if nums[mx] - nums[i] >= valueDifference:\n                return [mx, i]\n        return [-1, -1]\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(nums = [5,1,4,1], indexDifference = 2, valueDifference = 4) == [0,3]\n    assert candidate(nums = [2,1], indexDifference = 0, valueDifference = 0) == [0,0]\n    assert candidate(nums = [1,2,3], indexDifference = 2, valueDifference = 4) == [-1,-1]\n\n\ncheck(Solution().findIndices)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given a 0-indexed integer array nums having length n, an integer indexDifference, and an integer valueDifference.\nYour task is to find two indices i and j, both in the range [0, n - 1], that satisfy the following conditions:\n\nabs(i - j) >= indexDifference, and\nabs(nums[i] - nums[j]) >= valueDifference\n\nReturn an integer array answer, where answer = [i, j] if there are two such indices, and answer = [-1, -1] otherwise. If there are multiple choices for the two indices, return any of them.\nNote: i and j may be equal.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def findIndices(self, nums: List[int], indexDifference: int, valueDifference: int) -> List[int]:\n```",
        "solutions": "class Solution:\n    def findIndices(\n        self, nums: List[int], indexDifference: int, valueDifference: int\n    ) -> List[int]:\n        mi = mx = 0\n        for i in range(indexDifference, len(nums)):\n            j = i - indexDifference\n            if nums[j] < nums[mi]:\n                mi = j\n            if nums[j] > nums[mx]:\n                mx = j\n            if nums[i] - nums[mi] >= valueDifference:\n                return [mi, i]\n            if nums[mx] - nums[i] >= valueDifference:\n                return [mx, i]\n        return [-1, -1]\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(nums = [5,1,4,1], indexDifference = 2, valueDifference = 4) == [0,3]\n    assert candidate(nums = [2,1], indexDifference = 0, valueDifference = 0) == [0,0]\n    assert candidate(nums = [1,2,3], indexDifference = 2, valueDifference = 4) == [-1,-1]\n\n\ncheck(Solution().findIndices)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given two arrays nums1 and nums2 consisting of positive integers.\nYou have to replace all the 0's in both arrays with strictly positive integers such that the sum of elements of both arrays becomes equal.\nReturn the minimum equal sum you can obtain, or -1 if it is impossible.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def minSum(self, nums1: List[int], nums2: List[int]) -> int:\n```",
        "solutions": "class Solution:\n    def minSum(self, nums1: List[int], nums2: List[int]) -> int:\n        s1 = sum(nums1) + nums1.count(0)\n        s2 = sum(nums2) + nums2.count(0)\n        if s1 > s2:\n            return self.minSum(nums2, nums1)\n        if s1 == s2:\n            return s1\n        return -1 if nums1.count(0) == 0 else s2\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(nums1 = [3,2,0,1,0], nums2 = [6,5,0]) == 12\n    assert candidate(nums1 = [2,0,2,0], nums2 = [1,4]) == -1\n\n\ncheck(Solution().minSum)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given positive integers n and m.\nDefine two integers as follows:\n\nnum1: The sum of all integers in the range [1, n] (both inclusive) that are not divisible by m.\nnum2: The sum of all integers in the range [1, n] (both inclusive) that are divisible by m.\n\nReturn the integer num1 - num2.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def differenceOfSums(self, n: int, m: int) -> int:\n```",
        "solutions": "class Solution:\n    def differenceOfSums(self, n: int, m: int) -> int:\n        return sum(i if i % m else -i for i in range(1, n + 1))\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(n = 10, m = 3) == 19\n    assert candidate(n = 5, m = 6) == 15\n    assert candidate(n = 5, m = 1) == -15\n\n\ncheck(Solution().differenceOfSums)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nAlice and Bob each have a lexicographically sorted array of strings named a and b respectively.\nThey are playing a wording game with the following rules:\n\nOn each turn, the current player should play a word from their list such that the new word is closely greater than the last played word; then it's the other player's turn.\nIf a player can't play a word on their turn, they lose.\n\nAlice starts the game by playing her lexicographically smallest word.\nGiven a and b, return true if Alice can win knowing that both players play their best, and false otherwise.\nA word w is closely greater than a word z if the following conditions are met:\n\nw is lexicographically greater than z.\nIf w1 is the first letter of w and z1 is the first letter of z, w1 should either be equal to z1 or be the letter after z1 in the alphabet.\nFor example, the word \"care\" is closely greater than \"book\" and \"car\", but is not closely greater than \"ant\" or \"cook\".\n\nA string s is lexicographically greater than a string t if in the first position where s and t differ, string s has a letter that appears later in the alphabet than the corresponding letter in t. If the first min(s.length, t.length) characters do not differ, then the longer string is the lexicographically greater one.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def canAliceWin(self, a: List[str], b: List[str]) -> bool:\n```",
        "solutions": "class Solution:\n    def canAliceWin(self, a: List[str], b: List[str]) -> bool:\n        i, j, k = 1, 0, 1\n        w = a[0]\n        while 1:\n            if k:\n                if j == len(b):\n                    return True\n                if (b[j][0] == w[0] and b[j] > w) or ord(b[j][0]) - ord(w[0]) == 1:\n                    w = b[j]\n                    k ^= 1\n                j += 1\n            else:\n                if i == len(a):\n                    return False\n                if (a[i][0] == w[0] and a[i] > w) or ord(a[i][0]) - ord(w[0]) == 1:\n                    w = a[i]\n                    k ^= 1\n                i += 1\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(a = [\"avokado\",\"dabar\"], b = [\"brazil\"]) == False\n    assert candidate(a = [\"ananas\",\"atlas\",\"banana\"], b = [\"albatros\",\"cikla\",\"nogomet\"]) == True\n    assert candidate(a = [\"hrvatska\",\"zastava\"], b = [\"bijeli\",\"galeb\"]) == True\n\n\ncheck(Solution().canAliceWin)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given a 0-indexed binary string s having an even length.\nA string is beautiful if it's possible to partition it into one or more substrings such that:\n\nEach substring has an even length.\nEach substring contains only 1's or only 0's.\n\nYou can change any character in s to 0 or 1.\nReturn the minimum number of changes required to make the string s beautiful.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def minChanges(self, s: str) -> int:\n```",
        "solutions": "class Solution:\n    def minChanges(self, s: str) -> int:\n        return sum(s[i] != s[i - 1] for i in range(1, len(s), 2))\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(s = \"1001\") == 2\n    assert candidate(s = \"10\") == 1\n    assert candidate(s = \"0000\") == 0\n\n\ncheck(Solution().minChanges)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given a 0-indexed array nums of integers.\nA triplet of indices (i, j, k) is a mountain if:\n\ni < j < k\nnums[i] < nums[j] and nums[k] < nums[j]\n\nReturn the minimum possible sum of a mountain triplet of nums. If no such triplet exists, return -1.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def minimumSum(self, nums: List[int]) -> int:\n```",
        "solutions": "class Solution:\n    def minimumSum(self, nums: List[int]) -> int:\n        n = len(nums)\n        right = [inf] * (n + 1)\n        for i in range(n - 1, -1, -1):\n            right[i] = min(right[i + 1], nums[i])\n        ans = left = inf\n        for i, x in enumerate(nums):\n            if left < x and right[i + 1] < x:\n                ans = min(ans, left + x + right[i + 1])\n            left = min(left, x)\n        return -1 if ans == inf else ans\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(nums = [8,6,1,5,3]) == 9\n    assert candidate(nums = [5,4,8,7,10,2]) == 13\n    assert candidate(nums = [6,5,4,3,4,5]) == -1\n\n\ncheck(Solution().minimumSum)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nGiven an integer array nums and an integer k, you can perform the following operation on the array any number of times:\n\nSelect two adjacent elements of the array like x and y, such that x * y <= k, and replace both of them with a single element with value x * y (e.g. in one operation the array [1, 2, 2, 3] with k = 5 can become [1, 4, 3] or [2, 2, 3], but can't become [1, 2, 6]).\n\nReturn the minimum possible length of nums after any number of operations.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def minArrayLength(self, nums: List[int], k: int) -> int:\n```",
        "solutions": "class Solution:\n    def minArrayLength(self, nums: List[int], k: int) -> int:\n        ans, y = 1, nums[0]\n        for x in nums[1:]:\n            if x == 0:\n                return 1\n            if x * y <= k:\n                y *= x\n            else:\n                y = x\n                ans += 1\n        return ans\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(nums = [2,3,3,7,3,5], k = 20) == 3\n    assert candidate(nums = [3,3,3,3], k = 6) == 4\n\n\ncheck(Solution().minArrayLength)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given a 0-indexed integer array nums having length n, and an integer k.\nYou can perform the following increment operation any number of times (including zero):\n\nChoose an index i in the range [0, n - 1], and increase nums[i] by 1.\n\nAn array is considered beautiful if, for any subarray with a size of 3 or more, its maximum element is greater than or equal to k.\nReturn an integer denoting the minimum number of increment operations needed to make nums beautiful.\nA subarray is a contiguous non-empty sequence of elements within an array.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def minIncrementOperations(self, nums: List[int], k: int) -> int:\n```",
        "solutions": "class Solution:\n    def minIncrementOperations(self, nums: List[int], k: int) -> int:\n        f = g = h = 0\n        for x in nums:\n            f, g, h = g, h, min(f, g, h) + max(k - x, 0)\n        return min(f, g, h)\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(nums = [2,3,0,0,2], k = 4) == 3\n    assert candidate(nums = [0,1,3,3], k = 5) == 2\n    assert candidate(nums = [1,1,2], k = 1) == 0\n\n\ncheck(Solution().minIncrementOperations)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given a 0-indexed array heights of positive integers, where heights[i] represents the height of the ith building.\nIf a person is in building i, they can move to any other building j if and only if i < j and heights[i] < heights[j].\nYou are also given another array queries where queries[i] = [ai, bi]. On the ith query, Alice is in building ai while Bob is in building bi.\nReturn an array ans where ans[i] is the index of the leftmost building where Alice and Bob can meet on the ith query. If Alice and Bob cannot move to a common building on query i, set ans[i] to -1.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def leftmostBuildingQueries(self, heights: List[int], queries: List[List[int]]) -> List[int]:\n```",
        "solutions": "class BinaryIndexedTree:\n    __slots__ = [\"n\", \"c\"]\n\n    def __init__(self, n: int):\n        self.n = n\n        self.c = [inf] * (n + 1)\n\n    def update(self, x: int, v: int):\n        while x <= self.n:\n            self.c[x] = min(self.c[x], v)\n            x += x & -x\n\n    def query(self, x: int) -> int:\n        mi = inf\n        while x:\n            mi = min(mi, self.c[x])\n            x -= x & -x\n        return -1 if mi == inf else mi\n\n\nclass Solution:\n    def leftmostBuildingQueries(\n        self, heights: List[int], queries: List[List[int]]\n    ) -> List[int]:\n        n, m = len(heights), len(queries)\n        for i in range(m):\n            queries[i] = [min(queries[i]), max(queries[i])]\n        j = n - 1\n        s = sorted(set(heights))\n        ans = [-1] * m\n        tree = BinaryIndexedTree(n)\n        for i in sorted(range(m), key=lambda i: -queries[i][1]):\n            l, r = queries[i]\n            while j > r:\n                k = n - bisect_left(s, heights[j]) + 1\n                tree.update(k, j)\n                j -= 1\n            if l == r or heights[l] < heights[r]:\n                ans[i] = r\n            else:\n                k = n - bisect_left(s, heights[l])\n                ans[i] = tree.query(k)\n        return ans\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(heights = [6,4,8,5,2,7], queries = [[0,1],[0,3],[2,4],[3,4],[2,2]]) == [2,5,-1,5,2]\n    assert candidate(heights = [5,3,8,2,6,1,4,6], queries = [[0,7],[3,5],[5,2],[3,0],[1,6]]) == [7,6,-1,4,6]\n\n\ncheck(Solution().leftmostBuildingQueries)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nGiven a 1-indexed integer array prices, where prices[i] is the price of a particular stock on the ith day, your task is to select some of the elements of prices such that your selection is linear.\nA selection indexes, where indexes is a 1-indexed integer array of length k which is a subsequence of the array [1, 2, ..., n], is linear if:\n\nFor every 1 < j <= k, prices[indexes[j]] - prices[indexes[j - 1]] == indexes[j] - indexes[j - 1].\n\nA subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.\nThe score of a selection indexes, is equal to the sum of the following array: [prices[indexes[1]], prices[indexes[2]], ..., prices[indexes[k]].\nReturn the maximum score that a linear selection can have.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def maxScore(self, prices: List[int]) -> int:\n```",
        "solutions": "class Solution:\n    def maxScore(self, prices: List[int]) -> int:\n        cnt = Counter()\n        for i, x in enumerate(prices):\n            cnt[x - i] += x\n        return max(cnt.values())\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(prices = [1,5,3,7,8]) == 20\n    assert candidate(prices = [5,6,7,8,9]) == 35\n\n\ncheck(Solution().maxScore)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given an integer array nums, and an integer k. Let's introduce\u00a0K-or operation by extending the standard bitwise OR. In K-or, a bit position in the result is set to 1\u00a0if at least k numbers in nums have a 1 in that position.\nReturn the K-or of nums.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def findKOr(self, nums: List[int], k: int) -> int:\n```",
        "solutions": "class Solution:\n    def findKOr(self, nums: List[int], k: int) -> int:\n        ans = 0\n        for i in range(32):\n            cnt = sum(x >> i & 1 for x in nums)\n            if cnt >= k:\n                ans |= 1 << i\n        return ans\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(nums = [7,12,9,8,9,15], k = 4) == 9\n    assert candidate(nums = [2,12,1,11,4,5], k = 6) == 0\n    assert candidate(nums = [10,8,5,9,11,6,8], k = 1) == 15\n\n\ncheck(Solution().findKOr)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given a 0-indexed integer array nums.\nA subsequence of nums having length k and consisting of indices i0\u00a0<\u00a0i1 <\u00a0... < ik-1 is balanced if the following holds:\n\nnums[ij] - nums[ij-1] >= ij - ij-1, for every j in the range [1, k - 1].\n\nA subsequence of nums having length 1 is considered balanced.\nReturn an integer denoting the maximum possible sum of elements in a balanced subsequence of nums.\nA subsequence of an array is a new non-empty array that is formed from the original array by deleting some (possibly none) of the elements without disturbing the relative positions of the remaining elements.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def maxBalancedSubsequenceSum(self, nums: List[int]) -> int:\n```",
        "solutions": "class BinaryIndexedTree:\n    def __init__(self, n: int):\n        self.n = n\n        self.c = [-inf] * (n + 1)\n\n    def update(self, x: int, v: int):\n        while x <= self.n:\n            self.c[x] = max(self.c[x], v)\n            x += x & -x\n\n    def query(self, x: int) -> int:\n        mx = -inf\n        while x:\n            mx = max(mx, self.c[x])\n            x -= x & -x\n        return mx\n\n\nclass Solution:\n    def maxBalancedSubsequenceSum(self, nums: List[int]) -> int:\n        arr = [x - i for i, x in enumerate(nums)]\n        s = sorted(set(arr))\n        tree = BinaryIndexedTree(len(s))\n        for i, x in enumerate(nums):\n            j = bisect_left(s, x - i) + 1\n            v = max(tree.query(j), 0) + x\n            tree.update(j, v)\n        return tree.query(len(s))\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(nums = [3,3,5,6]) == 14\n    assert candidate(nums = [5,-1,-3,8]) == 13\n    assert candidate(nums = [-2,-1]) == -1\n\n\ncheck(Solution().maxBalancedSubsequenceSum)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given a 0-indexed array nums of integers.\nA triplet of indices (i, j, k) is a mountain if:\n\ni < j < k\nnums[i] < nums[j] and nums[k] < nums[j]\n\nReturn the minimum possible sum of a mountain triplet of nums. If no such triplet exists, return -1.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def minimumSum(self, nums: List[int]) -> int:\n```",
        "solutions": "class Solution:\n    def minimumSum(self, nums: List[int]) -> int:\n        n = len(nums)\n        right = [inf] * (n + 1)\n        for i in range(n - 1, -1, -1):\n            right[i] = min(right[i + 1], nums[i])\n        ans = left = inf\n        for i, x in enumerate(nums):\n            if left < x and right[i + 1] < x:\n                ans = min(ans, left + x + right[i + 1])\n            left = min(left, x)\n        return -1 if ans == inf else ans\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(nums = [8,6,1,5,3]) == 9\n    assert candidate(nums = [5,4,8,7,10,2]) == 13\n    assert candidate(nums = [6,5,4,3,4,5]) == -1\n\n\ncheck(Solution().minimumSum)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nGiven the 0-indexed arrays prices and profits of length n. There are n items in an store where the ith item has a price of prices[i] and a profit of profits[i].\nWe have to pick three items with the following condition:\n\nprices[i] < prices[j] < prices[k] where i < j < k.\n\nIf we pick items with indices i, j and k satisfying the above condition, the profit would be profits[i] + profits[j] + profits[k].\nReturn the maximum profit we can get, and -1 if it's not possible to pick three items with the given condition.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def maxProfit(self, prices: List[int], profits: List[int]) -> int:\n```",
        "solutions": "class Solution:\n    def maxProfit(self, prices: List[int], profits: List[int]) -> int:\n        n = len(prices)\n        ans = -1\n        for j, x in enumerate(profits):\n            left = right = 0\n            for i in range(j):\n                if prices[i] < prices[j] and left < profits[i]:\n                    left = profits[i]\n            for k in range(j + 1, n):\n                if prices[j] < prices[k] and right < profits[k]:\n                    right = profits[k]\n            if left and right:\n                ans = max(ans, left + x + right)\n        return ans\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(prices = [10,2,3,4], profits = [100,2,7,10]) == 19\n    assert candidate(prices = [1,2,3,4,5], profits = [1,5,3,4,6]) == 15\n    assert candidate(prices = [4,3,2,1], profits = [33,20,19,87]) == -1\n\n\ncheck(Solution().maxProfit)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nThere are n teams numbered from 0 to n - 1 in a tournament.\nGiven a 0-indexed 2D boolean matrix grid of size n * n. For all i, j that 0 <= i, j <= n - 1 and i != j team i is stronger than team j if grid[i][j] == 1, otherwise, team j is stronger than team i.\nTeam a will be the champion of the tournament if there is no team b that is stronger than team a.\nReturn the team that will be the champion of the tournament.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def findChampion(self, grid: List[List[int]]) -> int:\n```",
        "solutions": "class Solution:\n    def findChampion(self, grid: List[List[int]]) -> int:\n        for i, row in enumerate(grid):\n            if all(x == 1 for j, x in enumerate(row) if i != j):\n                return i\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(grid = [[0,1],[0,0]]) == 0\n    assert candidate(grid = [[0,0,1],[1,0,1],[0,0,0]]) == 1\n\n\ncheck(Solution().findChampion)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nThere are n teams numbered from 0 to n - 1 in a tournament; each team is also a node in a DAG.\nYou are given the integer n and a 0-indexed 2D integer array edges of length m representing the DAG, where edges[i] = [ui, vi] indicates that there is a directed edge from team ui to team vi in the graph.\nA directed edge from a to b in the graph means that team a is stronger than team b and team b is weaker than team a.\nTeam a will be the champion of the tournament if there is no team b that is stronger than team a.\nReturn the team that will be the champion of the tournament if there is a unique champion, otherwise, return -1.\nNotes\n\nA cycle is a series of nodes a1, a2, ..., an, an+1 such that node a1 is the same node as node an+1, the nodes a1, a2, ..., an are distinct, and there is a directed edge from the node ai to node ai+1 for every i in the range [1, n].\nA DAG is a directed graph that does not have any cycle.\n\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def findChampion(self, n: int, edges: List[List[int]]) -> int:\n```",
        "solutions": "class Solution:\n    def findChampion(self, n: int, edges: List[List[int]]) -> int:\n        indeg = [0] * n\n        for _, v in edges:\n            indeg[v] += 1\n        return -1 if indeg.count(0) != 1 else indeg.index(0)\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(n = 3, edges = [[0,1],[1,2]]) == 0\n    assert candidate(n = 4, edges = [[0,2],[1,3],[1,2]]) == -1\n\n\ncheck(Solution().findChampion)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nThere is an undirected tree with n nodes labeled from 0 to n - 1, and rooted at node 0. You are given\u00a0a 2D integer array edges of length n - 1, where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree.\nYou are also given a 0-indexed integer array values of length n, where values[i] is the value associated with the ith node.\nYou start with a score of 0. In one operation, you can:\n\nPick any node i.\nAdd values[i] to your score.\nSet values[i] to 0.\n\nA tree is healthy if the sum of values on the path from the root to any leaf node is different than zero.\nReturn the maximum score you can obtain after performing these operations on the tree any number of times so that it remains healthy.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def maximumScoreAfterOperations(self, edges: List[List[int]], values: List[int]) -> int:\n```",
        "solutions": "class Solution:\n    def maximumScoreAfterOperations(\n        self, edges: List[List[int]], values: List[int]\n    ) -> int:\n        def dfs(i: int, fa: int = -1) -> (int, int):\n            a = b = 0\n            leaf = True\n            for j in g[i]:\n                if j != fa:\n                    leaf = False\n                    aa, bb = dfs(j, i)\n                    a += aa\n                    b += bb\n            if leaf:\n                return values[i], 0\n            return values[i] + a, max(values[i] + b, a)\n\n        g = [[] for _ in range(len(values))]\n        for a, b in edges:\n            g[a].append(b)\n            g[b].append(a)\n        return dfs(0)[1]\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(edges = [[0,1],[0,2],[0,3],[2,4],[4,5]], values = [5,2,5,2,1,1]) == 11\n    assert candidate(edges = [[0,1],[0,2],[1,3],[1,4],[2,5],[2,6]], values = [20,10,9,7,4,3,5]) == 40\n\n\ncheck(Solution().maximumScoreAfterOperations)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nGiven three integers a, b, and n, return the maximum value of (a XOR x) * (b XOR x) where 0 <= x < 2n.\nSince the answer may be too large, return it modulo 109 + 7.\nNote that XOR is the bitwise XOR operation.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def maximumXorProduct(self, a: int, b: int, n: int) -> int:\n```",
        "solutions": "class Solution:\n    def maximumXorProduct(self, a: int, b: int, n: int) -> int:\n        mod = 10**9 + 7\n        ax, bx = (a >> n) << n, (b >> n) << n\n        for i in range(n - 1, -1, -1):\n            x = a >> i & 1\n            y = b >> i & 1\n            if x == y:\n                ax |= 1 << i\n                bx |= 1 << i\n            elif ax > bx:\n                bx |= 1 << i\n            else:\n                ax |= 1 << i\n        return ax * bx % mod\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(a = 12, b = 5, n = 4) == 98\n    assert candidate(a = 6, b = 7 , n = 5) == 930\n    assert candidate(a = 1, b = 6, n = 3) == 12\n\n\ncheck(Solution().maximumXorProduct)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given a 0-indexed integer array nums. A pair of integers x and y is called a strong pair if it satisfies the condition:\n\n|x - y| <= min(x, y)\n\nYou need to select two integers from nums such that they form a strong pair and their bitwise XOR is the maximum among all strong pairs in the array.\nReturn the maximum XOR value out of all possible strong pairs in the array nums.\nNote that you can pick the same integer twice to form a pair.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def maximumStrongPairXor(self, nums: List[int]) -> int:\n```",
        "solutions": "class Solution:\n    def maximumStrongPairXor(self, nums: List[int]) -> int:\n        return max(x ^ y for x in nums for y in nums if abs(x - y) <= min(x, y))\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(nums = [1,2,3,4,5]) == 7\n    assert candidate(nums = [10,100]) == 0\n    assert candidate(nums = [5,6,25,30]) == 7\n\n\ncheck(Solution().maximumStrongPairXor)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given a 0-indexed array of strings words and a character x.\nReturn an array of indices representing the words that contain the character x.\nNote that the returned array may be in any order.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def findWordsContaining(self, words: List[str], x: str) -> List[int]:\n```",
        "solutions": "class Solution:\n    def findWordsContaining(self, words: List[str], x: str) -> List[int]:\n        return [i for i, w in enumerate(words) if x in w]\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(words = [\"leet\",\"code\"], x = \"e\") == [0,1]\n    assert candidate(words = [\"abc\",\"bcd\",\"aaaa\",\"cbc\"], x = \"a\") == [0,2]\n    assert candidate(words = [\"abc\",\"bcd\",\"aaaa\",\"cbc\"], x = \"z\") == []\n\n\ncheck(Solution().findWordsContaining)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nThere are n balls on a table, each ball has a color black or white.\nYou are given a 0-indexed binary string s of length n, where 1 and 0 represent black and white balls, respectively.\nIn each step, you can choose two adjacent balls and swap them.\nReturn the minimum number of steps to group all the black balls to the right and all the white balls to the left.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def minimumSteps(self, s: str) -> int:\n```",
        "solutions": "class Solution:\n    def minimumSteps(self, s: str) -> int:\n        n = len(s)\n        ans = cnt = 0\n        for i in range(n - 1, -1, -1):\n            if s[i] == '1':\n                cnt += 1\n                ans += n - i - cnt\n        return ans\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(s = \"101\") == 1\n    assert candidate(s = \"100\") == 2\n    assert candidate(s = \"0111\") == 0\n\n\ncheck(Solution().minimumSteps)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given a 0-indexed integer array nums. A pair of integers x and y is called a strong pair if it satisfies the condition:\n\n|x - y| <= min(x, y)\n\nYou need to select two integers from nums such that they form a strong pair and their bitwise XOR is the maximum among all strong pairs in the array.\nReturn the maximum XOR value out of all possible strong pairs in the array nums.\nNote that you can pick the same integer twice to form a pair.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def maximumStrongPairXor(self, nums: List[int]) -> int:\n```",
        "solutions": "class Trie:\n    __slots__ = (\"children\", \"cnt\")\n\n    def __init__(self):\n        self.children: List[Trie | None] = [None, None]\n        self.cnt = 0\n\n    def insert(self, x: int):\n        node = self\n        for i in range(20, -1, -1):\n            v = x >> i & 1\n            if node.children[v] is None:\n                node.children[v] = Trie()\n            node = node.children[v]\n            node.cnt += 1\n\n    def search(self, x: int) -> int:\n        node = self\n        ans = 0\n        for i in range(20, -1, -1):\n            v = x >> i & 1\n            if node.children[v ^ 1] and node.children[v ^ 1].cnt:\n                ans |= 1 << i\n                node = node.children[v ^ 1]\n            else:\n                node = node.children[v]\n        return ans\n\n    def remove(self, x: int):\n        node = self\n        for i in range(20, -1, -1):\n            v = x >> i & 1\n            node = node.children[v]\n            node.cnt -= 1\n\n\nclass Solution:\n    def maximumStrongPairXor(self, nums: List[int]) -> int:\n        nums.sort()\n        tree = Trie()\n        ans = i = 0\n        for y in nums:\n            tree.insert(y)\n            while y > nums[i] * 2:\n                tree.remove(nums[i])\n                i += 1\n            ans = max(ans, tree.search(y))\n        return ans\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(nums = [1,2,3,4,5]) == 7\n    assert candidate(nums = [10,100]) == 0\n    assert candidate(nums = [500,520,2500,3000]) == 1020\n\n\ncheck(Solution().maximumStrongPairXor)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given two integers n and m which represent the size of a 1-indexed grid. You are also given an integer k, a 1-indexed integer array source and a 1-indexed integer array dest, where source and dest are in the form [x, y] representing a cell on the given grid.\nYou can move through the grid in the following way:\n\nYou can go from cell [x1, y1] to cell [x2, y2] if either x1 == x2 or y1 == y2.\nNote that you can't move to the cell you are already in e.g. x1 == x2 and y1 == y2.\n\nReturn the number of ways you can reach dest from source by moving through the grid exactly k times.\nSince the answer may be very large, return it modulo 109 + 7.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def numberOfWays(self, n: int, m: int, k: int, source: List[int], dest: List[int]) -> int:\n```",
        "solutions": "class Solution:\n    def numberOfWays(\n        self, n: int, m: int, k: int, source: List[int], dest: List[int]\n    ) -> int:\n        mod = 10**9 + 7\n        a, b, c, d = 1, 0, 0, 0\n        for _ in range(k):\n            aa = ((n - 1) * b + (m - 1) * c) % mod\n            bb = (a + (n - 2) * b + (m - 1) * d) % mod\n            cc = (a + (m - 2) * c + (n - 1) * d) % mod\n            dd = (b + c + (n - 2) * d + (m - 2) * d) % mod\n            a, b, c, d = aa, bb, cc, dd\n        if source[0] == dest[0]:\n            return a if source[1] == dest[1] else c\n        return b if source[1] == dest[1] else d\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(n = 3, m = 2, k = 2, source = [1,1], dest = [2,2]) == 2\n    assert candidate(n = 3, m = 4, k = 3, source = [1,2], dest = [2,3]) == 9\n\n\ncheck(Solution().numberOfWays)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given a 0-indexed string s having an even length n.\nYou are also given a 0-indexed 2D integer array, queries, where queries[i] = [ai, bi, ci, di].\nFor each query i, you are allowed to perform the following operations:\n\nRearrange the characters within the substring s[ai:bi], where 0 <= ai <= bi < n / 2.\nRearrange the characters within the substring s[ci:di], where n / 2 <= ci <= di < n.\n\nFor each query, your task is to determine whether it is possible to make s a palindrome by performing the operations.\nEach query is answered independently of the others.\nReturn a 0-indexed array answer, where answer[i] == true if it is possible to make s a palindrome by performing operations specified by the ith query, and false otherwise.\n\nA substring is a contiguous sequence of characters within a string.\ns[x:y] represents the substring consisting of characters from the index x to index y in s, both inclusive.\n\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def canMakePalindromeQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\n```",
        "solutions": "class Solution:\n    def canMakePalindromeQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\n        def count(pre: List[List[int]], i: int, j: int) -> List[int]:\n            return [x - y for x, y in zip(pre[j + 1], pre[i])]\n\n        def sub(cnt1: List[int], cnt2: List[int]) -> List[int]:\n            res = []\n            for x, y in zip(cnt1, cnt2):\n                if x - y < 0:\n                    return []\n                res.append(x - y)\n            return res\n\n        def check(\n            pre1: List[List[int]], pre2: List[List[int]], a: int, b: int, c: int, d: int\n        ) -> bool:\n            if diff[a] > 0 or diff[m] - diff[max(b, d) + 1] > 0:\n                return False\n            if d <= b:\n                return count(pre1, a, b) == count(pre2, a, b)\n            if b < c:\n                return (\n                    diff[c] - diff[b + 1] == 0\n                    and count(pre1, a, b) == count(pre2, a, b)\n                    and count(pre1, c, d) == count(pre2, c, d)\n                )\n            cnt1 = sub(count(pre1, a, b), count(pre2, a, c - 1))\n            cnt2 = sub(count(pre2, c, d), count(pre1, b + 1, d))\n            return bool(cnt1) and bool(cnt2) and cnt1 == cnt2\n\n        n = len(s)\n        m = n // 2\n        t = s[m:][::-1]\n        s = s[:m]\n        pre1 = [[0] * 26 for _ in range(m + 1)]\n        pre2 = [[0] * 26 for _ in range(m + 1)]\n        diff = [0] * (m + 1)\n        for i, (c1, c2) in enumerate(zip(s, t), 1):\n            pre1[i] = pre1[i - 1][:]\n            pre2[i] = pre2[i - 1][:]\n            pre1[i][ord(c1) - ord(\"a\")] += 1\n            pre2[i][ord(c2) - ord(\"a\")] += 1\n            diff[i] = diff[i - 1] + int(c1 != c2)\n        ans = []\n        for a, b, c, d in queries:\n            c, d = n - 1 - d, n - 1 - c\n            ok = (\n                check(pre1, pre2, a, b, c, d)\n                if a <= c\n                else check(pre2, pre1, c, d, a, b)\n            )\n            ans.append(ok)\n        return ans\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(s = \"abcabc\", queries = [[1,1,3,5],[0,2,5,5]]) == [True,True]\n    assert candidate(s = \"abbcdecbba\", queries = [[0,2,7,9]]) == [False]\n    assert candidate(s = \"acbcab\", queries = [[1,2,4,5]]) == [True]\n\n\ncheck(Solution().canMakePalindromeQueries)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nGiven the 0-indexed arrays prices and profits of length n. There are n items in an store where the ith item has a price of prices[i] and a profit of profits[i].\nWe have to pick three items with the following condition:\n\nprices[i] < prices[j] < prices[k] where i < j < k.\n\nIf we pick items with indices i, j and k satisfying the above condition, the profit would be profits[i] + profits[j] + profits[k].\nReturn the maximum profit we can get, and -1 if it's not possible to pick three items with the given condition.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def maxProfit(self, prices: List[int], profits: List[int]) -> int:\n```",
        "solutions": "class BinaryIndexedTree:\n    def __init__(self, n: int):\n        self.n = n\n        self.c = [0] * (n + 1)\n\n    def update(self, x: int, v: int):\n        while x <= self.n:\n            self.c[x] = max(self.c[x], v)\n            x += x & -x\n\n    def query(self, x: int) -> int:\n        mx = 0\n        while x:\n            mx = max(mx, self.c[x])\n            x -= x & -x\n        return mx\n\n\nclass Solution:\n    def maxProfit(self, prices: List[int], profits: List[int]) -> int:\n        n = len(prices)\n        left = [0] * n\n        right = [0] * n\n\n        m = max(prices)\n        tree1 = BinaryIndexedTree(m + 1)\n        tree2 = BinaryIndexedTree(m + 1)\n\n        for i, x in enumerate(prices):\n            left[i] = tree1.query(x - 1)\n            tree1.update(x, profits[i])\n        for i in range(n - 1, -1, -1):\n            x = m + 1 - prices[i]\n            right[i] = tree2.query(x - 1)\n            tree2.update(x, profits[i])\n\n        return max(\n            (l + x + r for l, x, r in zip(left, profits, right) if l and r), default=-1\n        )\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(prices = [10,2,3,4], profits = [100,2,7,10]) == 19\n    assert candidate(prices = [1,2,3,4,5], profits = [1,5,3,4,6]) == 15\n    assert candidate(prices = [4,3,2,1], profits = [33,20,19,87]) == -1\n\n\ncheck(Solution().maxProfit)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given two integer arrays nums1 and nums2 of sizes n and m, respectively. Calculate the following values:\n\nanswer1 : the number of indices i such that nums1[i] exists in nums2.\nanswer2 : the number of indices i such that nums2[i] exists in nums1.\n\nReturn [answer1,answer2].\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def findIntersectionValues(self, nums1: List[int], nums2: List[int]) -> List[int]:\n```",
        "solutions": "class Solution:\n    def findIntersectionValues(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        s1, s2 = set(nums1), set(nums2)\n        return [sum(x in s2 for x in nums1), sum(x in s1 for x in nums2)]\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(nums1 = [4,3,2,3,1], nums2 = [2,2,5,2,3,6]) == [3,4]\n    assert candidate(nums1 = [3,4,2,3], nums2 = [1,5]) == [0,0]\n\n\ncheck(Solution().findIntersectionValues)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given a string s and a positive integer k.\nLet vowels and consonants be the number of vowels and consonants in a string.\nA string is beautiful if:\n\nvowels == consonants.\n(vowels * consonants) % k == 0, in other terms the multiplication of vowels and consonants is divisible by k.\n\nReturn the number of non-empty beautiful substrings in the given string s.\nA substring is a contiguous sequence of characters in a string.\nVowel letters in English are 'a', 'e', 'i', 'o', and 'u'.\nConsonant letters in English are every letter except vowels.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def beautifulSubstrings(self, s: str, k: int) -> int:\n```",
        "solutions": "class Solution:\n    def beautifulSubstrings(self, s: str, k: int) -> int:\n        n = len(s)\n        vs = set(\"aeiou\")\n        ans = 0\n        for i in range(n):\n            vowels = 0\n            for j in range(i, n):\n                vowels += s[j] in vs\n                consonants = j - i + 1 - vowels\n                if vowels == consonants and vowels * consonants % k == 0:\n                    ans += 1\n        return ans\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(s = \"baeyh\", k = 2) == 2\n    assert candidate(s = \"abba\", k = 1) == 3\n    assert candidate(s = \"bcdf\", k = 1) == 0\n\n\ncheck(Solution().beautifulSubstrings)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given an integer array nums and a positive integer k.\nReturn the number of subarrays where the maximum element of nums appears at least k times in that subarray.\nA subarray is a contiguous sequence of elements within an array.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def countSubarrays(self, nums: List[int], k: int) -> int:\n```",
        "solutions": "class Solution:\n    def countSubarrays(self, nums: List[int], k: int) -> int:\n        mx = max(nums)\n        n = len(nums)\n        ans = cnt = j = 0\n        for x in nums:\n            while j < n and cnt < k:\n                cnt += nums[j] == mx\n                j += 1\n            if cnt < k:\n                break\n            ans += n - j + 1\n            cnt -= x == mx\n        return ans\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(nums = [1,3,2,3,3], k = 2) == 6\n    assert candidate(nums = [1,4,2,1], k = 3) == 0\n\n\ncheck(Solution().countSubarrays)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given the two integers, n and m and two integer arrays, hBars and vBars. The grid has n + 2 horizontal and m + 2 vertical bars, creating 1 x 1 unit cells. The bars are indexed starting from 1.\nYou can remove some of the bars in hBars from horizontal bars and some of the bars in vBars from vertical bars. Note that other bars are fixed and cannot be removed.\nReturn an integer denoting the maximum area of a square-shaped hole in the grid, after removing some bars (possibly none).\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def maximizeSquareHoleArea(self, n: int, m: int, hBars: List[int], vBars: List[int]) -> int:\n```",
        "solutions": "class Solution:\n    def maximizeSquareHoleArea(\n        self, n: int, m: int, hBars: List[int], vBars: List[int]\n    ) -> int:\n        def f(nums: List[int]) -> int:\n            nums.sort()\n            ans = cnt = 1\n            for i in range(1, len(nums)):\n                if nums[i] == nums[i - 1] + 1:\n                    cnt += 1\n                    ans = max(ans, cnt)\n                else:\n                    cnt = 1\n            return ans + 1\n\n        return min(f(hBars), f(vBars)) ** 2\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(n = 2, m = 1, hBars = [2,3], vBars = [2]) == 4\n    assert candidate(n = 1, m = 1, hBars = [2], vBars = [2]) == 4\n    assert candidate(n = 2, m = 3, hBars = [2,3], vBars = [2,3,4]) == 9\n\n\ncheck(Solution().maximizeSquareHoleArea)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given an m x n integer matrix mat and an integer k. The matrix rows are 0-indexed.\nThe following proccess happens k times:\n\nEven-indexed rows (0, 2, 4, ...) are cyclically shifted to the left.\n\n\n\nOdd-indexed rows (1, 3, 5, ...) are cyclically shifted to the right.\n\n\nReturn true if the final modified matrix after k steps is identical to the original matrix, and false otherwise.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def areSimilar(self, mat: List[List[int]], k: int) -> bool:\n```",
        "solutions": "class Solution:\n    def areSimilar(self, mat: List[List[int]], k: int) -> bool:\n        n = len(mat[0])\n        for i, row in enumerate(mat):\n            for j, x in enumerate(row):\n                if i % 2 == 1 and x != mat[i][(j + k) % n]:\n                    return False\n                if i % 2 == 0 and x != mat[i][(j - k + n) % n]:\n                    return False\n        return True\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(mat = [[1,2,1,2],[5,5,5,5],[6,3,6,3]], k = 2) == True\n    assert candidate(mat = [[2,2],[2,2]], k = 3) == True\n    assert candidate(mat = [[1,2]], k = 1) == False\n\n\ncheck(Solution().areSimilar)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nThere is a company with n branches across the country, some of which are connected by roads. Initially, all branches are reachable from each other by traveling some roads.\nThe company has realized that they are spending an excessive amount of time traveling between their branches. As a result, they have decided to close down some of these branches (possibly none). However, they want to ensure that the remaining branches have a distance of at most maxDistance from each other.\nThe distance between two branches is the minimum total traveled length needed to reach one branch from another.\nYou are given integers n, maxDistance, and a 0-indexed 2D array roads, where roads[i] = [ui, vi, wi] represents the undirected road between branches ui and vi with length wi.\nReturn the number of possible sets of closing branches, so that any branch has a distance of at most maxDistance from any other.\nNote that, after closing a branch, the company will no longer have access to any roads connected to it.\nNote that, multiple roads are allowed.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def numberOfSets(self, n: int, maxDistance: int, roads: List[List[int]]) -> int:\n```",
        "solutions": "class Solution:\n    def numberOfSets(self, n: int, maxDistance: int, roads: List[List[int]]) -> int:\n        ans = 0\n        for mask in range(1 << n):\n            g = [[inf] * n for _ in range(n)]\n            for u, v, w in roads:\n                if mask >> u & 1 and mask > v & 1:\n                    g[u][v] = min(g[u][v], w)\n                    g[v][u] = min(g[v][u], w)\n            for k in range(n):\n                if mask >> k & 1:\n                    g[k][k] = 0\n                    for i in range(n):\n                        for j in range(n):\n                            # g[i][j] = min(g[i][j], g[i][k] + g[k][j])\n                            if g[i][k] + g[k][j] < g[i][j]:\n                                g[i][j] = g[i][k] + g[k][j]\n            if all(\n                g[i][j] <= maxDistance\n                for i in range(n)\n                for j in range(n)\n                if mask >> i & 1 and mask >> j & 1\n            ):\n                ans += 1\n        return ans\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(n = 3, maxDistance = 5, roads = [[0,1,2],[1,2,10],[0,2,10]]) == 5\n    assert candidate(n = 3, maxDistance = 5, roads = [[0,1,20],[0,1,10],[1,2,2],[0,2,2]]) == 7\n    assert candidate(n = 1, maxDistance = 10, roads = []) == 2\n\n\ncheck(Solution().numberOfSets)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given an undirected tree with n nodes labeled from 0 to n - 1, and rooted at node 0. You are given a 2D integer array edges of length n - 1, where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree.\nYou are also given a 0-indexed integer array cost of length n, where cost[i] is the cost assigned to the ith node.\nYou need to place some coins on every node of the tree. The number of coins to be placed at node i can be calculated as:\n\nIf size of the subtree of node i is less than 3, place 1 coin.\nOtherwise, place an amount of coins equal to the maximum product of cost values assigned to 3 distinct nodes in the subtree of node i. If this product is negative, place 0 coins.\n\nReturn an array coin of size n such that coin[i] is the number of coins placed at node i.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def placedCoins(self, edges: List[List[int]], cost: List[int]) -> List[int]:\n```",
        "solutions": "class Solution:\n    def placedCoins(self, edges: List[List[int]], cost: List[int]) -> List[int]:\n        def dfs(a: int, fa: int) -> List[int]:\n            res = [cost[a]]\n            for b in g[a]:\n                if b != fa:\n                    res.extend(dfs(b, a))\n            res.sort()\n            if len(res) >= 3:\n                ans[a] = max(res[-3] * res[-2] * res[-1], res[0] * res[1] * res[-1], 0)\n            if len(res) > 5:\n                res = res[:2] + res[-3:]\n            return res\n\n        n = len(cost)\n        g = [[] for _ in range(n)]\n        for a, b in edges:\n            g[a].append(b)\n            g[b].append(a)\n        ans = [1] * n\n        dfs(0, -1)\n        return ans\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(edges = [[0,1],[0,2],[0,3],[0,4],[0,5]], cost = [1,2,3,4,5,6]) == [120,1,1,1,1,1]\n    assert candidate(edges = [[0,1],[0,2],[1,3],[1,4],[1,5],[2,6],[2,7],[2,8]], cost = [1,4,2,3,5,7,8,-4,2]) == [280,140,32,1,1,1,1,1,1]\n    assert candidate(edges = [[0,1],[0,2]], cost = [1,2,-2]) == [0,1,1]\n\n\ncheck(Solution().placedCoins)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given a 0-indexed array of positive integers nums and a positive integer limit.\nIn one operation, you can choose any two indices i and j and swap nums[i] and nums[j] if |nums[i] - nums[j]| <= limit.\nReturn the lexicographically smallest array that can be obtained by performing the operation any number of times.\nAn array a is lexicographically smaller than an array b if in the first position where a and b differ, array a has an element that is less than the corresponding element in b. For example, the array [2,10,3] is lexicographically smaller than the array [10,2,3] because they differ at index 0 and 2 < 10.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def lexicographicallySmallestArray(self, nums: List[int], limit: int) -> List[int]:\n```",
        "solutions": "class Solution:\n    def lexicographicallySmallestArray(self, nums: List[int], limit: int) -> List[int]:\n        n = len(nums)\n        arr = sorted(zip(nums, range(n)))\n        ans = [0] * n\n        i = 0\n        while i < n:\n            j = i + 1\n            while j < n and arr[j][0] - arr[j - 1][0] <= limit:\n                j += 1\n            idx = sorted(k for _, k in arr[i:j])\n            for k, (x, _) in zip(idx, arr[i:j]):\n                ans[k] = x\n            i = j\n        return ans\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(nums = [1,5,3,9,8], limit = 2) == [1,3,5,8,9]\n    assert candidate(nums = [1,7,6,18,2,1], limit = 3) == [1,6,7,18,1,2]\n    assert candidate(nums = [1,7,28,19,10], limit = 3) == [1,7,28,19,10]\n\n\ncheck(Solution().lexicographicallySmallestArray)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given a 0-indexed integer array batteryPercentages having length n, denoting the battery percentages of n 0-indexed devices.\nYour task is to test each device i in order from 0 to n - 1, by performing the following test operations:\n\nIf batteryPercentages[i] is greater than 0:\n\n\t\nIncrement the count of tested devices.\nDecrease the battery percentage of all devices with indices j in the range [i + 1, n - 1] by 1, ensuring their battery percentage never goes below 0, i.e, batteryPercentages[j] = max(0, batteryPercentages[j] - 1).\nMove to the next device.\n\n\nOtherwise, move to the next device without performing any test.\n\nReturn an integer denoting the number of devices that will be tested after performing the test operations in order.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def countTestedDevices(self, batteryPercentages: List[int]) -> int:\n```",
        "solutions": "class Solution:\n    def countTestedDevices(self, batteryPercentages: List[int]) -> int:\n        ans = 0\n        for x in batteryPercentages:\n            ans += x > ans\n        return ans\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(batteryPercentages = [1,1,2,1,3]) == 3\n    assert candidate(batteryPercentages = [0,1,2]) == 2\n\n\ncheck(Solution().countTestedDevices)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given a 0-indexed array mountain. Your task is to find all the peaks in the mountain array.\nReturn an array that consists of indices of peaks in the given array in any order.\nNotes:\n\nA peak is defined as an element that is strictly greater than its neighboring elements.\nThe first and last elements of the array are not a peak.\n\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def findPeaks(self, mountain: List[int]) -> List[int]:\n```",
        "solutions": "class Solution:\n    def findPeaks(self, mountain: List[int]) -> List[int]:\n        return [\n            i\n            for i in range(1, len(mountain) - 1)\n            if mountain[i - 1] < mountain[i] > mountain[i + 1]\n        ]\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(mountain = [2,4,4]) == []\n    assert candidate(mountain = [1,4,3,8,5]) == [1,3]\n\n\ncheck(Solution().findPeaks)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given a string word and an integer k.\nA substring s of word is complete if:\n\nEach character in s occurs exactly k times.\nThe difference between two adjacent characters is at most 2. That is, for any two adjacent characters c1 and c2 in s, the absolute difference in their positions in the alphabet is at most 2.\n\nReturn the number of complete substrings of word.\nA substring is a non-empty contiguous sequence of characters in a string.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def countCompleteSubstrings(self, word: str, k: int) -> int:\n```",
        "solutions": "class Solution:\n    def countCompleteSubstrings(self, word: str, k: int) -> int:\n        def f(s: str) -> int:\n            m = len(s)\n            ans = 0\n            for i in range(1, 27):\n                l = i * k\n                if l > m:\n                    break\n                cnt = Counter(s[:l])\n                freq = Counter(cnt.values())\n                ans += freq[k] == i\n                for j in range(l, m):\n                    freq[cnt[s[j]]] -= 1\n                    cnt[s[j]] += 1\n                    freq[cnt[s[j]]] += 1\n\n                    freq[cnt[s[j - l]]] -= 1\n                    cnt[s[j - l]] -= 1\n                    freq[cnt[s[j - l]]] += 1\n\n                    ans += freq[k] == i\n            return ans\n\n        n = len(word)\n        ans = i = 0\n        while i < n:\n            j = i + 1\n            while j < n and abs(ord(word[j]) - ord(word[j - 1])) <= 2:\n                j += 1\n            ans += f(word[i:j])\n            i = j\n        return ans\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(word = \"igigee\", k = 2) == 3\n    assert candidate(word = \"aaabbbccc\", k = 3) == 6\n\n\ncheck(Solution().countCompleteSubstrings)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given an integer array nums and an integer k.\nThe frequency of an element x is the number of times it occurs in an array.\nAn array is called good if the frequency of each element in this array is less than or equal to k.\nReturn the length of the longest good subarray of nums.\nA subarray is a contiguous non-empty sequence of elements within an array.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def maxSubarrayLength(self, nums: List[int], k: int) -> int:\n```",
        "solutions": "class Solution:\n    def maxSubarrayLength(self, nums: List[int], k: int) -> int:\n        cnt = defaultdict(int)\n        ans = j = 0\n        for i, x in enumerate(nums):\n            cnt[x] += 1\n            while cnt[x] > k:\n                cnt[nums[j]] -= 1\n                j += 1\n            ans = max(ans, i - j + 1)\n        return ans\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(nums = [1,2,3,1,2,3,1,2], k = 2) == 6\n    assert candidate(nums = [1,2,1,2,1,2,1,2], k = 1) == 2\n    assert candidate(nums = [5,5,5,5,5,5,5], k = 4) == 4\n\n\ncheck(Solution().maxSubarrayLength)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given a 0-indexed integer array nums of even length and there is also an empty array arr. Alice and Bob decided to play a game where in every round Alice and Bob will do one move. The rules of the game are as follows:\n\nEvery round, first Alice will remove the minimum element from nums, and then Bob does the same.\nNow, first Bob will append the removed element in the array arr, and then Alice does the same.\nThe game continues until nums becomes empty.\n\nReturn the resulting array arr.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def numberGame(self, nums: List[int]) -> List[int]:\n```",
        "solutions": "class Solution:\n    def numberGame(self, nums: List[int]) -> List[int]:\n        heapify(nums)\n        ans = []\n        while nums:\n            a, b = heappop(nums), heappop(nums)\n            ans.append(b)\n            ans.append(a)\n        return ans\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(nums = [5,4,2,3]) == [3,2,5,4]\n    assert candidate(nums = [2,5]) == [5,2]\n\n\ncheck(Solution().numberGame)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given a 0-indexed 2D integer matrix grid of size n * n with values in the range [1, n2]. Each integer appears exactly once except a which appears twice and b which is missing. The task is to find the repeating and missing numbers a and b.\nReturn a 0-indexed integer array ans of size 2 where ans[0] equals to a and ans[1] equals to b.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def findMissingAndRepeatedValues(self, grid: List[List[int]]) -> List[int]:\n```",
        "solutions": "class Solution:\n    def findMissingAndRepeatedValues(self, grid: List[List[int]]) -> List[int]:\n        n = len(grid)\n        cnt = [0] * (n * n + 1)\n        for row in grid:\n            for v in row:\n                cnt[v] += 1\n        ans = [0] * 2\n        for i in range(1, n * n + 1):\n            if cnt[i] == 2:\n                ans[0] = i\n            if cnt[i] == 0:\n                ans[1] = i\n        return ans\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(grid = [[1,3],[2,2]]) == [2,4]\n    assert candidate(grid = [[9,1,7],[8,9,2],[3,4,6]]) == [9,5]\n\n\ncheck(Solution().findMissingAndRepeatedValues)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given two 0-indexed integer arrays nums1 and nums2 of even length n.\nYou must remove n / 2 elements from nums1 and n / 2 elements from nums2. After the removals, you insert the remaining elements of nums1 and nums2 into a set s.\nReturn the maximum possible size of the set s.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def maximumSetSize(self, nums1: List[int], nums2: List[int]) -> int:\n```",
        "solutions": "class Solution:\n    def maximumSetSize(self, nums1: List[int], nums2: List[int]) -> int:\n        s1 = set(nums1)\n        s2 = set(nums2)\n        n = len(nums1)\n        a = min(len(s1 - s2), n // 2)\n        b = min(len(s2 - s1), n // 2)\n        return min(a + b + len(s1 & s2), n)\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(nums1 = [1,2,1,2], nums2 = [1,1,1,1]) == 2\n    assert candidate(nums1 = [1,2,3,4,5,6], nums2 = [2,3,2,3,2,3]) == 5\n    assert candidate(nums1 = [1,1,2,2,3,3], nums2 = [4,4,5,5,6,6]) == 6\n\n\ncheck(Solution().maximumSetSize)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given a 0-indexed integer array nums having length n.\nYou are allowed to perform a special move any number of times (including zero) on nums. In one special move you perform the following steps in order:\n\nChoose an index i in the range [0, n - 1], and a positive integer x.\nAdd |nums[i] - x| to the total cost.\nChange the value of nums[i] to x.\n\nA palindromic number is a positive integer that remains the same when its digits are reversed. For example, 121, 2552 and 65756 are palindromic numbers whereas 24, 46, 235 are not palindromic numbers.\nAn array is considered equalindromic if all the elements in the array are equal to an integer y, where y is a palindromic number less than 109.\nReturn an integer denoting the minimum possible total cost to make nums equalindromic by performing any number of special moves.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def minimumCost(self, nums: List[int]) -> int:\n```",
        "solutions": "ps = []\nfor i in range(1, 10**5 + 1):\n    s = str(i)\n    t1 = s[::-1]\n    t2 = s[:-1][::-1]\n    ps.append(int(s + t1))\n    ps.append(int(s + t2))\nps.sort()\n\n\nclass Solution:\n    def minimumCost(self, nums: List[int]) -> int:\n        def f(x: int) -> int:\n            return sum(abs(v - x) for v in nums)\n\n        nums.sort()\n        i = bisect_left(ps, nums[len(nums) // 2])\n        return min(f(ps[j]) for j in range(i - 1, i + 2) if 0 <= j < len(ps))\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(nums = [1,2,3,4,5]) == 6\n    assert candidate(nums = [10,12,13,14,15]) == 11\n    assert candidate(nums = [22,33,22,33,22]) == 22\n\n\ncheck(Solution().minimumCost)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given a 0-indexed string word.\nIn one operation, you can pick any index i of word and change word[i] to any lowercase English letter.\nReturn the minimum number of operations needed to remove all adjacent almost-equal characters from word.\nTwo characters a and b are almost-equal if a == b or a and b are adjacent in the alphabet.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def removeAlmostEqualCharacters(self, word: str) -> int:\n```",
        "solutions": "class Solution:\n    def removeAlmostEqualCharacters(self, word: str) -> int:\n        ans = 0\n        i, n = 1, len(word)\n        while i < n:\n            if abs(ord(word[i]) - ord(word[i - 1])) < 2:\n                ans += 1\n                i += 2\n            else:\n                i += 1\n        return ans\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(word = \"aaaaa\") == 2\n    assert candidate(word = \"abddez\") == 2\n    assert candidate(word = \"zyxyxyz\") == 3\n\n\ncheck(Solution().removeAlmostEqualCharacters)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given a 0-indexed integer array coins, representing the values of the coins available, and an integer target.\nAn integer x is obtainable if there exists a subsequence of coins that sums to x.\nReturn the minimum number of coins of any value that need to be added to the array so that every integer in the range [1, target] is obtainable.\nA subsequence of an array is a new non-empty array that is formed from the original array by deleting some (possibly none) of the elements without disturbing the relative positions of the remaining elements.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def minimumAddedCoins(self, coins: List[int], target: int) -> int:\n```",
        "solutions": "class Solution:\n    def minimumAddedCoins(self, coins: List[int], target: int) -> int:\n        coins.sort()\n        s = 1\n        ans = i = 0\n        while s <= target:\n            if i < len(coins) and coins[i] <= s:\n                s += coins[i]\n                i += 1\n            else:\n                s <<= 1\n                ans += 1\n        return ans\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(coins = [1,4,10], target = 19) == 2\n    assert candidate(coins = [1,4,10,5,7,19], target = 19) == 1\n    assert candidate(coins = [1,1,1], target = 20) == 3\n\n\ncheck(Solution().minimumAddedCoins)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given two 0-indexed strings source and target, both of length n and consisting of lowercase English letters. You are also given two 0-indexed character arrays original and changed, and an integer array cost, where cost[i] represents the cost of changing the character original[i] to the character changed[i].\nYou start with the string source. In one operation, you can pick a character x from the string and change it to the character y at a cost of z if there exists any index j such that cost[j] == z, original[j] == x, and changed[j] == y.\nReturn the minimum cost to convert the string source to the string target using any number of operations. If it is impossible to convert source to target, return -1.\nNote that there may exist indices i, j such that original[j] == original[i] and changed[j] == changed[i].\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:\n```",
        "solutions": "class Solution:\n    def minimumCost(\n        self,\n        source: str,\n        target: str,\n        original: List[str],\n        changed: List[str],\n        cost: List[int],\n    ) -> int:\n        g = [[inf] * 26 for _ in range(26)]\n        for i in range(26):\n            g[i][i] = 0\n        for x, y, z in zip(original, changed, cost):\n            x = ord(x) - ord('a')\n            y = ord(y) - ord('a')\n            g[x][y] = min(g[x][y], z)\n        for k in range(26):\n            for i in range(26):\n                for j in range(26):\n                    g[i][j] = min(g[i][j], g[i][k] + g[k][j])\n        ans = 0\n        for a, b in zip(source, target):\n            if a != b:\n                x, y = ord(a) - ord('a'), ord(b) - ord('a')\n                if g[x][y] >= inf:\n                    return -1\n                ans += g[x][y]\n        return ans\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(source = \"abcd\", target = \"acbe\", original = [\"a\",\"b\",\"c\",\"c\",\"e\",\"d\"], changed = [\"b\",\"c\",\"b\",\"e\",\"b\",\"e\"], cost = [2,5,5,1,2,20]) == 28\n    assert candidate(source = \"aaaa\", target = \"bbbb\", original = [\"a\",\"c\"], changed = [\"c\",\"b\"], cost = [1,2]) == 12\n    assert candidate(source = \"abcd\", target = \"abce\", original = [\"a\"], changed = [\"e\"], cost = [10000]) == -1\n\n\ncheck(Solution().minimumCost)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given a 0-indexed array of integers nums.\nA prefix nums[0..i] is sequential if, for all 1 <= j <= i, nums[j] = nums[j - 1] + 1. In particular, the prefix consisting only of nums[0] is sequential.\nReturn the smallest integer x missing from nums such that x is greater than or equal to the sum of the longest sequential prefix.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def missingInteger(self, nums: List[int]) -> int:\n```",
        "solutions": "class Solution:\n    def missingInteger(self, nums: List[int]) -> int:\n        s, j = nums[0], 1\n        while j < len(nums) and nums[j] == nums[j - 1] + 1:\n            s += nums[j]\n            j += 1\n        vis = set(nums)\n        for x in count(s):\n            if x not in vis:\n                return x\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(nums = [1,2,3,2,5]) == 6\n    assert candidate(nums = [3,4,5,1,12,14,13]) == 15\n\n\ncheck(Solution().missingInteger)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nEach character of the English alphabet has been mapped to a digit as shown below.\n\nA string is divisible if the sum of the mapped values of its characters is divisible by its length.\nGiven a string s, return the number of divisible substrings of s.\nA substring is a contiguous non-empty sequence of characters within a string.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def countDivisibleSubstrings(self, word: str) -> int:\n```",
        "solutions": "class Solution:\n    def countDivisibleSubstrings(self, word: str) -> int:\n        d = [\"ab\", \"cde\", \"fgh\", \"ijk\", \"lmn\", \"opq\", \"rst\", \"uvw\", \"xyz\"]\n        mp = {}\n        for i, s in enumerate(d, 1):\n            for c in s:\n                mp[c] = i\n        ans = 0\n        n = len(word)\n        for i in range(n):\n            s = 0\n            for j in range(i, n):\n                s += mp[word[j]]\n                ans += s % (j - i + 1) == 0\n        return ans\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(word = \"asdf\") == 6\n    assert candidate(word = \"bdh\") == 4\n    assert candidate(word = \"abcd\") == 6\n\n\ncheck(Solution().countDivisibleSubstrings)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given an integer array nums of size n where n is a multiple of 3 and a positive integer k.\nDivide the array nums into n / 3 arrays of size 3 satisfying the following condition:\n\nThe difference between any two elements in one array is less than or equal to k.\n\nReturn a 2D array containing the arrays. If it is impossible to satisfy the conditions, return an empty array. And if there are multiple answers, return any of them.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def divideArray(self, nums: List[int], k: int) -> List[List[int]]:\n```",
        "solutions": "class Solution:\n    def divideArray(self, nums: List[int], k: int) -> List[List[int]]:\n        nums.sort()\n        ans = []\n        n = len(nums)\n        for i in range(0, n, 3):\n            t = nums[i : i + 3]\n            if t[2] - t[0] > k:\n                return []\n            ans.append(t)\n        return ans\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(nums = [1,3,4,8,7,9,3,5,1], k = 2) == [[1,1,3],[3,4,5],[7,8,9]]\n    assert candidate(nums = [1,3,3,2,7,3], k = 3) == []\n\n\ncheck(Solution().divideArray)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given an array nums consisting of positive integers.\nReturn the total frequencies of elements in nums\u00a0such that those elements all have the maximum frequency.\nThe frequency of an element is the number of occurrences of that element in the array.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def maxFrequencyElements(self, nums: List[int]) -> int:\n```",
        "solutions": "class Solution:\n    def maxFrequencyElements(self, nums: List[int]) -> int:\n        cnt = Counter(nums)\n        mx = max(cnt.values())\n        return sum(x for x in cnt.values() if x == mx)\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(nums = [1,2,2,3,1,4]) == 4\n    assert candidate(nums = [1,2,3,4,5]) == 5\n\n\ncheck(Solution().maxFrequencyElements)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given a 0-indexed integer array nums containing positive integers.\nYour task is to minimize the length of nums by performing the following operations any number of times (including zero):\n\nSelect two distinct indices i and j from nums, such that nums[i] > 0 and nums[j] > 0.\nInsert the result of nums[i] % nums[j] at the end of nums.\nDelete the elements at indices i and j from nums.\n\nReturn an integer denoting the minimum length of nums after performing the operation any number of times.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def minimumArrayLength(self, nums: List[int]) -> int:\n```",
        "solutions": "class Solution:\n    def minimumArrayLength(self, nums: List[int]) -> int:\n        mi = min(nums)\n        if any(x % mi for x in nums):\n            return 1\n        return (nums.count(mi) + 1) // 2\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(nums = [1,4,3,1]) == 1\n    assert candidate(nums = [5,5,5,10,5]) == 2\n    assert candidate(nums = [2,3,4]) == 1\n\n\ncheck(Solution().minimumArrayLength)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given a 0-indexed string s, a string a, a string b, and an integer k.\nAn index i is beautiful if:\n\n0 <= i <= s.length - a.length\ns[i..(i + a.length - 1)] == a\nThere exists an index j such that:\n\t\n0 <= j <= s.length - b.length\ns[j..(j + b.length - 1)] == b\n|j - i| <= k\n\n\n\nReturn the array that contains beautiful indices in sorted order from smallest to largest.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def beautifulIndices(self, s: str, a: str, b: str, k: int) -> List[int]:\n```",
        "solutions": "class Solution:\n    def beautifulIndices(self, s: str, a: str, b: str, k: int) -> List[int]:\n        def build_prefix_function(pattern):\n            prefix_function = [0] * len(pattern)\n            j = 0\n            for i in range(1, len(pattern)):\n                while j > 0 and pattern[i] != pattern[j]:\n                    j = prefix_function[j - 1]\n                if pattern[i] == pattern[j]:\n                    j += 1\n                prefix_function[i] = j\n            return prefix_function\n\n        def kmp_search(pattern, text, prefix_function):\n            occurrences = []\n            j = 0\n            for i in range(len(text)):\n                while j > 0 and text[i] != pattern[j]:\n                    j = prefix_function[j - 1]\n                if text[i] == pattern[j]:\n                    j += 1\n                if j == len(pattern):\n                    occurrences.append(i - j + 1)\n                    j = prefix_function[j - 1]\n            return occurrences\n\n        prefix_a = build_prefix_function(a)\n        prefix_b = build_prefix_function(b)\n\n        resa = kmp_search(a, s, prefix_a)\n        resb = kmp_search(b, s, prefix_b)\n\n        res = []\n        print(resa, resb)\n        i = 0\n        j = 0\n        while i < len(resa):\n            while j < len(resb):\n                if abs(resb[j] - resa[i]) <= k:\n                    res.append(resa[i])\n                    break\n                elif j + 1 < len(resb) and abs(resb[j + 1] - resa[i]) < abs(\n                    resb[j] - resa[i]\n                ):\n                    j += 1\n                else:\n                    break\n            i += 1\n        return res\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(s = \"isawsquirrelnearmysquirrelhouseohmy\", a = \"my\", b = \"squirrel\", k = 15) == [16,33]\n    assert candidate(s = \"abcd\", a = \"a\", b = \"a\", k = 4) == [0]\n\n\ncheck(Solution().beautifulIndices)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given an array of positive integers nums.\nYou have to check if it is possible to select two or more elements in the array such that the bitwise OR of the selected elements has at least one trailing zero in its binary representation.\nFor example, the binary representation of 5, which is \"101\", does not have any trailing zeros, whereas the binary representation of 4, which is \"100\", has two trailing zeros.\nReturn true if it is possible to select two or more elements whose bitwise OR has trailing zeros, return false otherwise.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def hasTrailingZeros(self, nums: List[int]) -> bool:\n```",
        "solutions": "class Solution:\n    def hasTrailingZeros(self, nums: List[int]) -> bool:\n        return sum(x & 1 ^ 1 for x in nums) >= 2\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(nums = [1,2,3,4,5]) == True\n    assert candidate(nums = [2,4,8,16]) == True\n    assert candidate(nums = [1,3,5,7,9]) == False\n\n\ncheck(Solution().hasTrailingZeros)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given a 0-indexed string s, and a 2D array of integers queries, where queries[i] = [li, ri] indicates a substring of s starting from the index li and ending at the index ri (both inclusive), i.e. s[li..ri].\nReturn an array ans where ans[i] is the number of same-end substrings of queries[i].\nA 0-indexed string t of length n is called same-end if it has the same character at both of its ends, i.e., t[0] == t[n - 1].\nA substring is a contiguous non-empty sequence of characters within a string.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def sameEndSubstringCount(self, s: str, queries: List[List[int]]) -> List[int]:\n```",
        "solutions": "class Solution:\n    def sameEndSubstringCount(self, s: str, queries: List[List[int]]) -> List[int]:\n        n = len(s)\n        cs = set(s)\n        cnt = {c: [0] * (n + 1) for c in cs}\n        for i, a in enumerate(s, 1):\n            for c in cs:\n                cnt[c][i] = cnt[c][i - 1]\n            cnt[a][i] += 1\n        ans = []\n        for l, r in queries:\n            t = r - l + 1\n            for c in cs:\n                x = cnt[c][r + 1] - cnt[c][l]\n                t += x * (x - 1) // 2\n            ans.append(t)\n        return ans\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(s = \"abcaab\", queries = [[0,0],[1,4],[2,5],[0,5]]) == [1,5,5,10]\n    assert candidate(s = \"abcd\", queries = [[0,3]]) == [4]\n\n\ncheck(Solution().sameEndSubstringCount)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given a 0-indexed array of positive integers nums.\nA subarray of nums is called incremovable if nums becomes strictly increasing on removing the subarray. For example, the subarray [3, 4] is an incremovable subarray of [5, 3, 4, 6, 7] because removing this subarray changes the array [5, 3, 4, 6, 7] to [5, 6, 7] which is strictly increasing.\nReturn the total number of incremovable subarrays of nums.\nNote that an empty array is considered strictly increasing.\nA subarray is a contiguous non-empty sequence of elements within an array.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def incremovableSubarrayCount(self, nums: List[int]) -> int:\n```",
        "solutions": "class Solution:\n    def incremovableSubarrayCount(self, nums: List[int]) -> int:\n        i, n = 0, len(nums)\n        while i + 1 < n and nums[i] < nums[i + 1]:\n            i += 1\n        if i == n - 1:\n            return n * (n + 1) // 2\n        ans = i + 2\n        j = n - 1\n        while j:\n            while i >= 0 and nums[i] >= nums[j]:\n                i -= 1\n            ans += i + 2\n            if nums[j - 1] >= nums[j]:\n                break\n            j -= 1\n        return ans\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(nums = [1,2,3,4]) == 10\n    assert candidate(nums = [6,5,7,8]) == 7\n    assert candidate(nums = [8,7,6,6]) == 3\n\n\ncheck(Solution().incremovableSubarrayCount)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nThere is a large (m - 1) x (n - 1) rectangular field with corners at (1, 1) and (m, n) containing some horizontal and vertical fences given in arrays hFences and vFences respectively.\nHorizontal fences are from the coordinates (hFences[i], 1) to (hFences[i], n) and vertical fences are from the coordinates (1, vFences[i]) to (m, vFences[i]).\nReturn the maximum area of a square field that can be formed by removing some fences (possibly none) or -1 if it is impossible to make a square field.\nSince the answer may be large, return it modulo 109 + 7.\nNote: The field is surrounded by two horizontal fences from the coordinates (1, 1) to (1, n) and (m, 1) to (m, n) and two vertical fences from the coordinates (1, 1) to (m, 1) and (1, n) to (m, n). These fences cannot be removed.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def maximizeSquareArea(self, m: int, n: int, hFences: List[int], vFences: List[int]) -> int:\n```",
        "solutions": "class Solution:\n    def maximizeSquareArea(\n        self, m: int, n: int, hFences: List[int], vFences: List[int]\n    ) -> int:\n        def f(nums: List[int], k: int) -> Set[int]:\n            nums.extend([1, k])\n            nums.sort()\n            return {b - a for a, b in combinations(nums, 2)}\n\n        mod = 10**9 + 7\n        hs = f(hFences, m)\n        vs = f(vFences, n)\n        ans = max(hs & vs, default=0)\n        return ans**2 % mod if ans else -1\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(m = 4, n = 3, hFences = [2,3], vFences = [2]) == 4\n    assert candidate(m = 6, n = 7, hFences = [2], vFences = [4]) == -1\n\n\ncheck(Solution().maximizeSquareArea)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given a 2D 0-indexed integer array dimensions.\nFor all indices i, 0 <= i < dimensions.length, dimensions[i][0] represents the length and dimensions[i][1] represents the width of the rectangle i.\nReturn the area of the rectangle having the longest diagonal. If there are multiple rectangles with the longest diagonal, return the area of the rectangle having the maximum area.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def areaOfMaxDiagonal(self, dimensions: List[List[int]]) -> int:\n```",
        "solutions": "class Solution:\n    def areaOfMaxDiagonal(self, dimensions: List[List[int]]) -> int:\n        ans = mx = 0\n        for l, w in dimensions:\n            t = l**2 + w**2\n            if mx < t:\n                mx = t\n                ans = l * w\n            elif mx == t:\n                ans = max(ans, l * w)\n        return ans\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(dimensions = [[9,3],[8,6]]) == 48\n    assert candidate(dimensions = [[3,4],[4,3]]) == 12\n\n\ncheck(Solution().areaOfMaxDiagonal)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given a 0-indexed array of positive integers nums.\nA subarray of nums is called incremovable if nums becomes strictly increasing on removing the subarray. For example, the subarray [3, 4] is an incremovable subarray of [5, 3, 4, 6, 7] because removing this subarray changes the array [5, 3, 4, 6, 7] to [5, 6, 7] which is strictly increasing.\nReturn the total number of incremovable subarrays of nums.\nNote that an empty array is considered strictly increasing.\nA subarray is a contiguous non-empty sequence of elements within an array.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def incremovableSubarrayCount(self, nums: List[int]) -> int:\n```",
        "solutions": "class Solution:\n    def incremovableSubarrayCount(self, nums: List[int]) -> int:\n        i, n = 0, len(nums)\n        while i + 1 < n and nums[i] < nums[i + 1]:\n            i += 1\n        if i == n - 1:\n            return n * (n + 1) // 2\n        ans = i + 2\n        j = n - 1\n        while j:\n            while i >= 0 and nums[i] >= nums[j]:\n                i -= 1\n            ans += i + 2\n            if nums[j - 1] >= nums[j]:\n                break\n            j -= 1\n        return ans\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(nums = [1,2,3,4]) == 10\n    assert candidate(nums = [6,5,7,8]) == 7\n    assert candidate(nums = [8,7,6,6]) == 3\n\n\ncheck(Solution().incremovableSubarrayCount)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nGiven a 0-indexed integer array nums and an integer d, return the number of triplets (i, j, k) such that i < j < k and (nums[i] + nums[j] + nums[k]) % d == 0.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def divisibleTripletCount(self, nums: List[int], d: int) -> int:\n```",
        "solutions": "class Solution:\n    def divisibleTripletCount(self, nums: List[int], d: int) -> int:\n        cnt = defaultdict(int)\n        ans, n = 0, len(nums)\n        for j in range(n):\n            for k in range(j + 1, n):\n                x = (d - (nums[j] + nums[k]) % d) % d\n                ans += cnt[x]\n            cnt[nums[j] % d] += 1\n        return ans\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(nums = [3,3,4,7,8], d = 5) == 3\n    assert candidate(nums = [3,3,3,3], d = 3) == 4\n    assert candidate(nums = [3,3,3,3], d = 6) == 0\n\n\ncheck(Solution().divisibleTripletCount)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given a 0-indexed integer array nums and an integer k.\nIn one operation, you can pick any index i of nums such that 0 <= i < nums.length - 1 and replace nums[i] and nums[i + 1] with a single occurrence of nums[i] & nums[i + 1], where & represents the bitwise AND operator.\nReturn the minimum possible value of the bitwise OR of the remaining elements of nums after applying at most k operations.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def minOrAfterOperations(self, nums: List[int], k: int) -> int:\n```",
        "solutions": "class Solution:\n    def minOrAfterOperations(self, nums: List[int], k: int) -> int:\n        ans = 0\n        rans = 0\n        for i in range(29, -1, -1):\n            test = ans + (1 << i)\n            cnt = 0\n            val = 0\n            for num in nums:\n                if val == 0:\n                    val = test & num\n                else:\n                    val &= test & num\n                if val:\n                    cnt += 1\n            if cnt > k:\n                rans += 1 << i\n            else:\n                ans += 1 << i\n        return rans\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(nums = [3,5,3,2,7], k = 2) == 3\n    assert candidate(nums = [7,3,15,14,2,8], k = 4) == 2\n    assert candidate(nums = [10,7,10,3,9,14,9,4], k = 1) == 15\n\n\ncheck(Solution().minOrAfterOperations)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given an array of integers nums of length n.\nThe cost of an array is the value of its first element. For example, the cost of [1,2,3] is 1 while the cost of [3,4,1] is 3.\nYou need to divide nums into 3 disjoint contiguous subarrays.\nReturn the minimum possible sum of the cost of these subarrays.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def minimumCost(self, nums: List[int]) -> int:\n```",
        "solutions": "class Solution:\n    def minimumCost(self, nums: List[int]) -> int:\n        a, b, c = nums[0], inf, inf\n        for x in nums[1:]:\n            if x < b:\n                c, b = b, x\n            elif x < c:\n                c = x\n        return a + b + c\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(nums = [1,2,3,12]) == 6\n    assert candidate(nums = [5,4,3]) == 12\n    assert candidate(nums = [10,3,1,1]) == 12\n\n\ncheck(Solution().minimumCost)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given an array nums of length n and a positive integer k.\nA subarray of nums is called good if the absolute difference between its first and last element is exactly k, in other words, the subarray nums[i..j] is good if |nums[i] - nums[j]| == k.\nReturn the maximum sum of a good subarray of nums. If there are no good subarrays, return 0.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def maximumSubarraySum(self, nums: List[int], k: int) -> int:\n```",
        "solutions": "class Solution:\n    def maximumSubarraySum(self, nums: List[int], k: int) -> int:\n        ans = -inf\n        p = {nums[0]: 0}\n        s, n = 0, len(nums)\n        for i, x in enumerate(nums):\n            s += x\n            if x - k in p:\n                ans = max(ans, s - p[x - k])\n            if x + k in p:\n                ans = max(ans, s - p[x + k])\n            if i + 1 < n and (nums[i + 1] not in p or p[nums[i + 1]] > s):\n                p[nums[i + 1]] = s\n        return 0 if ans == -inf else ans\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(nums = [1,2,3,4,5,6], k = 1) == 11\n    assert candidate(nums = [-1,3,2,4,5], k = 3) == 11\n    assert candidate(nums = [-1,-2,-3,-4], k = 2) == -6\n\n\ncheck(Solution().maximumSubarraySum)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given a string s that consists of lowercase English letters.\nA string is called special if it is made up of only a single character. For example, the string \"abc\" is not special, whereas the strings \"ddd\", \"zz\", and \"f\" are special.\nReturn the length of the longest special substring of s which occurs at least thrice, or -1 if no special substring occurs at least thrice.\nA substring is a contiguous non-empty sequence of characters within a string.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def maximumLength(self, s: str) -> int:\n```",
        "solutions": "class Solution:\n    def maximumLength(self, s: str) -> int:\n        def check(x: int) -> bool:\n            cnt = defaultdict(int)\n            i = 0\n            while i < n:\n                j = i + 1\n                while j < n and s[j] == s[i]:\n                    j += 1\n                cnt[s[i]] += max(0, j - i - x + 1)\n                i = j\n            return max(cnt.values()) >= 3\n\n        n = len(s)\n        l, r = 0, n\n        while l < r:\n            mid = (l + r + 1) >> 1\n            if check(mid):\n                l = mid\n            else:\n                r = mid - 1\n        return -1 if l == 0 else l\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(s = \"aaaa\") == 2\n    assert candidate(s = \"abcdef\") == -1\n    assert candidate(s = \"abcaba\") == 1\n\n\ncheck(Solution().maximumLength)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given a string s that consists of lowercase English letters.\nA string is called special if it is made up of only a single character. For example, the string \"abc\" is not special, whereas the strings \"ddd\", \"zz\", and \"f\" are special.\nReturn the length of the longest special substring of s which occurs at least thrice, or -1 if no special substring occurs at least thrice.\nA substring is a contiguous non-empty sequence of characters within a string.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def maximumLength(self, s: str) -> int:\n```",
        "solutions": "class Solution:\n    def maximumLength(self, s: str) -> int:\n        def check(x: int) -> bool:\n            cnt = defaultdict(int)\n            i = 0\n            while i < n:\n                j = i + 1\n                while j < n and s[j] == s[i]:\n                    j += 1\n                cnt[s[i]] += max(0, j - i - x + 1)\n                i = j\n            return max(cnt.values()) >= 3\n\n        n = len(s)\n        l, r = 0, n\n        while l < r:\n            mid = (l + r + 1) >> 1\n            if check(mid):\n                l = mid\n            else:\n                r = mid - 1\n        return -1 if l == 0 else l\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(s = \"aaaa\") == 2\n    assert candidate(s = \"abcdef\") == -1\n    assert candidate(s = \"abcaba\") == 1\n\n\ncheck(Solution().maximumLength)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are at a fruit market with different types of exotic fruits on display.\nYou are given a 1-indexed array prices, where prices[i] denotes the number of coins needed to purchase the ith fruit.\nThe fruit market has the following offer:\n\nIf you purchase the ith fruit at prices[i] coins, you can get the next i fruits for free.\n\nNote that even if you can take fruit j for free, you can still purchase it for prices[j] coins to receive a new offer.\nReturn the minimum number of coins needed to acquire all the fruits.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def minimumCoins(self, prices: List[int]) -> int:\n```",
        "solutions": "class Solution:\n    def minimumCoins(self, prices: List[int]) -> int:\n        n = len(prices)\n        q = deque()\n        for i in range(n, 0, -1):\n            while q and q[0] > i * 2 + 1:\n                q.popleft()\n            if i <= (n - 1) // 2:\n                prices[i - 1] += prices[q[0] - 1]\n            while q and prices[q[-1] - 1] >= prices[i - 1]:\n                q.pop()\n            q.append(i)\n        return prices[0]\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(prices = [3,1,2]) == 4\n    assert candidate(prices = [1,10,1,1]) == 2\n\n\ncheck(Solution().minimumCoins)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given a 0-indexed integer array nums of size n, and a 0-indexed integer array pattern of size m consisting of integers -1, 0, and 1.\nA subarray nums[i..j] of size m + 1 is said to match the pattern if the following conditions hold for each element pattern[k]:\n\nnums[i + k + 1] > nums[i + k] if pattern[k] == 1.\nnums[i + k + 1] == nums[i + k] if pattern[k] == 0.\nnums[i + k + 1] < nums[i + k] if pattern[k] == -1.\n\nReturn the count of subarrays in nums that match the pattern.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def countMatchingSubarrays(self, nums: List[int], pattern: List[int]) -> int:\n```",
        "solutions": "class Solution:\n    def countMatchingSubarrays(self, nums: List[int], pattern: List[int]) -> int:\n        def f(a: int, b: int) -> int:\n            return 0 if a == b else (1 if a < b else -1)\n\n        ans = 0\n        for i in range(len(nums) - len(pattern)):\n            ans += all(\n                f(nums[i + k], nums[i + k + 1]) == p for k, p in enumerate(pattern)\n            )\n        return ans\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(nums = [1,2,3,4,5,6], pattern = [1,1]) == 4\n    assert candidate(nums = [1,4,4,1,3,5,5,3], pattern = [1,0,-1]) == 2\n\n\ncheck(Solution().countMatchingSubarrays)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nThere is a 1-indexed 8 x 8 chessboard containing 3 pieces.\nYou are given 6 integers a, b, c, d, e, and f where:\n\n(a, b) denotes the position of the white rook.\n(c, d) denotes the position of the white bishop.\n(e, f) denotes the position of the black queen.\n\nGiven that you can only move the white pieces, return the minimum number of moves required to capture the black queen.\nNote that:\n\nRooks can move any number of squares either vertically or horizontally, but cannot jump over other pieces.\nBishops can move any number of squares diagonally, but cannot jump over other pieces.\nA rook or a bishop can capture the queen if it is located in a square that they can move to.\nThe queen does not move.\n\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def minMovesToCaptureTheQueen(self, a: int, b: int, c: int, d: int, e: int, f: int) -> int:\n```",
        "solutions": "class Solution:\n    def minMovesToCaptureTheQueen(\n        self, a: int, b: int, c: int, d: int, e: int, f: int\n    ) -> int:\n        def check(dirs, sx, sy, bx, by) -> bool:\n            for dx, dy in pairwise(dirs):\n                for k in range(1, 8):\n                    x = sx + dx * k\n                    y = sy + dy * k\n                    if not (1 <= x <= 8 and 1 <= y <= 8) or (x, y) == (bx, by):\n                        break\n                    if (x, y) == (e, f):\n                        return True\n            return False\n\n        dirs1 = (-1, 0, 1, 0, -1)\n        dirs2 = (-1, 1, 1, -1, -1)\n        return 1 if check(dirs1, a, b, c, d) or check(dirs2, c, d, a, b) else 2\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(a = 1, b = 1, c = 8, d = 8, e = 2, f = 3) == 2\n    assert candidate(a = 5, b = 3, c = 3, d = 4, e = 5, f = 2) == 1\n\n\ncheck(Solution().minMovesToCaptureTheQueen)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given three positive integers n, x, and y.\nIn a city, there exist houses numbered 1 to n connected by n streets. There is a street connecting the house numbered i with the house numbered i + 1 for all 1 <= i <= n - 1 . An additional street connects the house numbered x with the house numbered y.\nFor each k, such that 1 <= k <= n, you need to find the number of pairs of houses (house1, house2) such that the minimum number of streets that need to be traveled to reach house2 from house1 is k.\nReturn a 1-indexed array result of length n where result[k] represents the total number of pairs of houses such that the minimum streets required to reach one house from the other is k.\nNote that x and y can be equal.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def countOfPairs(self, n: int, x: int, y: int) -> List[int]:\n```",
        "solutions": "class Solution:\n    def countOfPairs(self, n: int, x: int, y: int) -> List[int]:\n        x, y = x - 1, y - 1\n        ans = [0] * n\n        for i in range(n):\n            for j in range(i + 1, n):\n                a = j - i\n                b = abs(i - x) + 1 + abs(j - y)\n                c = abs(i - y) + 1 + abs(j - x)\n                ans[min(a, b, c) - 1] += 2\n        return ans\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(n = 3, x = 1, y = 3) == [6,0,0]\n    assert candidate(n = 5, x = 2, y = 4) == [10,8,2,0,0]\n    assert candidate(n = 4, x = 1, y = 1) == [6,4,2,0]\n\n\ncheck(Solution().countOfPairs)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given m x n grid image which represents a grayscale image, where image[i][j] represents a pixel with intensity in the range [0..255]. You are also given a non-negative integer threshold.\nTwo pixels are adjacent if they share an edge.\nA region is a 3 x 3 subgrid where the absolute difference in intensity between any two adjacent pixels is less than or equal to threshold.\nAll pixels in a region belong to that region, note that a pixel can belong to multiple regions.\nYou need to calculate a m x n grid result, where result[i][j] is the average intensity of the regions to which image[i][j] belongs, rounded down to the nearest integer. If image[i][j] belongs to multiple regions, result[i][j] is the average of the rounded-down average intensities of these regions, rounded down to the nearest integer. If image[i][j] does not belong to any region, result[i][j] is equal to image[i][j].\nReturn the grid result.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def resultGrid(self, image: List[List[int]], threshold: int) -> List[List[int]]:\n```",
        "solutions": "class Solution:\n    def resultGrid(self, image: List[List[int]], threshold: int) -> List[List[int]]:\n        n, m = len(image), len(image[0])\n        ans = [[0] * m for _ in range(n)]\n        ct = [[0] * m for _ in range(n)]\n        for i in range(n - 2):\n            for j in range(m - 2):\n                region = True\n                for k in range(3):\n                    for l in range(2):\n                        region &= (\n                            abs(image[i + k][j + l] - image[i + k][j + l + 1])\n                            <= threshold\n                        )\n                for k in range(2):\n                    for l in range(3):\n                        region &= (\n                            abs(image[i + k][j + l] - image[i + k + 1][j + l])\n                            <= threshold\n                        )\n\n                if region:\n                    tot = 0\n                    for k in range(3):\n                        for l in range(3):\n                            tot += image[i + k][j + l]\n                    for k in range(3):\n                        for l in range(3):\n                            ct[i + k][j + l] += 1\n                            ans[i + k][j + l] += tot // 9\n\n        for i in range(n):\n            for j in range(m):\n                if ct[i][j] == 0:\n                    ans[i][j] = image[i][j]\n                else:\n                    ans[i][j] //= ct[i][j]\n\n        return ans\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(image = [[5,6,7,10],[8,9,10,10],[11,12,13,10]], threshold = 3) == [[9,9,9,9],[9,9,9,9],[9,9,9,9]]\n    assert candidate(image = [[10,20,30],[15,25,35],[20,30,40],[25,35,45]], threshold = 12) == [[25,25,25],[27,27,27],[27,27,27],[30,30,30]]\n    assert candidate(image = [[5,6,7],[8,9,10],[11,12,13]], threshold = 1) == [[5,6,7],[8,9,10],[11,12,13]]\n\n\ncheck(Solution().resultGrid)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given two distinct prime numbers primeOne and primeTwo.\nAlice and Bob are visiting a market. The market has an infinite number of items, for any positive integer x there exists an item whose price is x. Alice wants to buy some items from the market to gift to Bob. She has an infinite number of coins in the denomination primeOne and primeTwo. She wants to know the most expensive item she can not buy to gift to Bob.\nReturn the price of the most expensive item which Alice can not gift to Bob.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def mostExpensiveItem(self, primeOne: int, primeTwo: int) -> int:\n```",
        "solutions": "class Solution:\n    def mostExpensiveItem(self, primeOne: int, primeTwo: int) -> int:\n        return primeOne * primeTwo - primeOne - primeTwo\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(primeOne = 2, primeTwo = 5) == 3\n    assert candidate(primeOne = 5, primeTwo = 7) == 23\n\n\ncheck(Solution().mostExpensiveItem)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given a string word containing distinct lowercase English letters.\nTelephone keypads have keys mapped with distinct collections of lowercase English letters, which can be used to form words by pushing them. For example, the key 2 is mapped with [\"a\",\"b\",\"c\"], we need to push the key one time to type \"a\", two times to type \"b\", and three times to type \"c\" .\nIt is allowed to remap the keys numbered 2 to 9 to distinct collections of letters. The keys can be remapped to any amount of letters, but each letter must be mapped to exactly one key. You need to find the minimum number of times the keys will be pushed to type the string word.\nReturn the minimum number of pushes needed to type word after remapping the keys.\nAn example mapping of letters to keys on a telephone keypad is given below. Note that 1, *, #, and 0 do not map to any letters.\n\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def minimumPushes(self, word: str) -> int:\n```",
        "solutions": "class Solution:\n    def minimumPushes(self, word: str) -> int:\n        n = len(word)\n        ans, k = 0, 1\n        for _ in range(n // 8):\n            ans += k * 8\n            k += 1\n        ans += k * (n % 8)\n        return ans\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(word = \"abcde\") == 5\n    assert candidate(word = \"xycdefghij\") == 12\n\n\ncheck(Solution().minimumPushes)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given a string word containing lowercase English letters.\nTelephone keypads have keys mapped with distinct collections of lowercase English letters, which can be used to form words by pushing them. For example, the key 2 is mapped with [\"a\",\"b\",\"c\"], we need to push the key one time to type \"a\", two times to type \"b\", and three times to type \"c\" .\nIt is allowed to remap the keys numbered 2 to 9 to distinct collections of letters. The keys can be remapped to any amount of letters, but each letter must be mapped to exactly one key. You need to find the minimum number of times the keys will be pushed to type the string word.\nReturn the minimum number of pushes needed to type word after remapping the keys.\nAn example mapping of letters to keys on a telephone keypad is given below. Note that 1, *, #, and 0 do not map to any letters.\n\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def minimumPushes(self, word: str) -> int:\n```",
        "solutions": "class Solution:\n    def minimumPushes(self, word: str) -> int:\n        cnt = Counter(word)\n        ans = 0\n        for i, x in enumerate(sorted(cnt.values(), reverse=True)):\n            ans += (i // 8 + 1) * x\n        return ans\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(word = \"abcde\") == 5\n    assert candidate(word = \"xyzxyzxyzxyz\") == 12\n    assert candidate(word = \"aabbccddeeffgghhiiiiii\") == 24\n\n\ncheck(Solution().minimumPushes)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given a 2D array points of size n x 2 representing integer coordinates of some points on a 2D-plane, where points[i] = [xi, yi].\nWe define the right direction as positive x-axis (increasing x-coordinate) and the left direction as negative x-axis (decreasing x-coordinate). Similarly, we define the up direction as positive y-axis (increasing y-coordinate) and the down direction as negative y-axis (decreasing y-coordinate)\nYou have to place n people, including Alice and Bob, at these points such that there is exactly one person at every point. Alice wants to be alone with Bob, so Alice will build a rectangular fence with Alice's position as the upper left corner and Bob's position as the lower right corner of the fence (Note that the fence might not enclose any area, i.e. it can be a line). If any person other than Alice and Bob is either inside the fence or on the fence, Alice will be sad.\nReturn the number of pairs of points where you can place Alice and Bob, such that Alice does not become sad on building the fence.\nNote that Alice can only build a fence with Alice's position as the upper left corner, and Bob's position as the lower right corner. For example, Alice cannot build either of the fences in the picture below with four corners (1, 1), (1, 3), (3, 1), and (3, 3), because:\n\nWith Alice at (3, 3) and Bob at (1, 1), Alice's position is not the upper left corner and Bob's position is not the lower right corner of the fence.\nWith Alice at (1, 3) and Bob at (1, 1), Bob's position is not the lower right corner of the fence.\n\n\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def numberOfPairs(self, points: List[List[int]]) -> int:\n```",
        "solutions": "class Solution:\n    def numberOfPairs(self, points: List[List[int]]) -> int:\n        points.sort(key=lambda x: (x[0], -x[1]))\n        ans = 0\n        for i, (_, y1) in enumerate(points):\n            max_y = -inf\n            for _, y2 in points[i + 1 :]:\n                if max_y < y2 <= y1:\n                    max_y = y2\n                    ans += 1\n        return ans\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(points = [[1,1],[2,2],[3,3]]) == 0\n    assert candidate(points = [[6,2],[4,4],[2,6]]) == 2\n    assert candidate(points = [[3,1],[1,3],[1,1]]) == 2\n\n\ncheck(Solution().numberOfPairs)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given a 2D array points of size n x 2 representing integer coordinates of some points on a 2D plane, where points[i] = [xi, yi].\nCount the number of pairs of points (A, B), where\n\nA is on the upper left side of B, and\nthere are no other points in the rectangle (or line) they make (including the border).\n\nReturn the count.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def numberOfPairs(self, points: List[List[int]]) -> int:\n```",
        "solutions": "class Solution:\n    def numberOfPairs(self, points: List[List[int]]) -> int:\n        points.sort(key=lambda x: (x[0], -x[1]))\n        ans = 0\n        for i, (_, y1) in enumerate(points):\n            max_y = -inf\n            for _, y2 in points[i + 1 :]:\n                if max_y < y2 <= y1:\n                    max_y = y2\n                    ans += 1\n        return ans\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(points = [[1,1],[2,2],[3,3]]) == 0\n    assert candidate(points = [[6,2],[4,4],[2,6]]) == 2\n    assert candidate(points = [[3,1],[1,3],[1,1]]) == 2\n\n\ncheck(Solution().numberOfPairs)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nAlice and Bob are playing a turn-based game on a circular field surrounded by flowers. The circle represents the field, and there are x flowers in the clockwise direction between Alice and Bob, and y flowers in the anti-clockwise direction between them.\nThe game proceeds as follows:\n\nAlice takes the first turn.\nIn each turn, a player must choose either the clockwise or anti-clockwise direction and pick one flower from that side.\nAt the end of the turn, if there are no flowers left at all, the current player captures their opponent and wins the game.\n\nGiven two integers, n and m, the task is to compute the number of possible pairs (x, y) that satisfy the conditions:\n\nAlice must win the game according to the described rules.\nThe number of flowers x in the clockwise direction must be in the range [1,n].\nThe number of flowers y in the anti-clockwise direction must be in the range [1,m].\n\nReturn the number of possible pairs (x, y) that satisfy the conditions mentioned in the statement.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def flowerGame(self, n: int, m: int) -> int:\n```",
        "solutions": "class Solution:\n    def flowerGame(self, n: int, m: int) -> int:\n        a1 = (n + 1) // 2\n        b1 = (m + 1) // 2\n        a2 = n // 2\n        b2 = m // 2\n        return a1 * b2 + a2 * b1\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(n = 3, m = 2) == 3\n    assert candidate(n = 1, m = 1) == 0\n\n\ncheck(Solution().flowerGame)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given a 0-indexed integer array nums of size n, and a 0-indexed integer array pattern of size m consisting of integers -1, 0, and 1.\nA subarray nums[i..j] of size m + 1 is said to match the pattern if the following conditions hold for each element pattern[k]:\n\nnums[i + k + 1] > nums[i + k] if pattern[k] == 1.\nnums[i + k + 1] == nums[i + k] if pattern[k] == 0.\nnums[i + k + 1] < nums[i + k] if pattern[k] == -1.\n\nReturn the count of subarrays in nums that match the pattern.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def countMatchingSubarrays(self, nums: List[int], pattern: List[int]) -> int:\n```",
        "solutions": "def partial(s):\n    g, pi = 0, [0] * len(s)\n    for i in range(1, len(s)):\n        while g and (s[g] != s[i]):\n            g = pi[g - 1]\n        pi[i] = g = g + (s[g] == s[i])\n    return pi\n\n\ndef match(s, pat):\n    pi = partial(pat)\n    g, idx = 0, []\n    for i in range(len(s)):\n        while g and pat[g] != s[i]:\n            g = pi[g - 1]\n        g += pat[g] == s[i]\n        if g == len(pi):\n            idx.append(i + 1 - g)\n            g = pi[g - 1]\n    return idx\n\n\ndef string_find(s, pat):\n    pi = partial(pat)\n    g = 0\n    for i in range(len(s)):\n        while g and pat[g] != s[i]:\n            g = pi[g - 1]\n        g += pat[g] == s[i]\n        if g == len(pi):\n            return True\n    return False\n\n\nclass Solution:\n    def countMatchingSubarrays(self, nums: List[int], pattern: List[int]) -> int:\n        s = []\n        for i in range(1, len(nums)):\n            if nums[i] > nums[i - 1]:\n                s.append(1)\n            elif nums[i] == nums[i - 1]:\n                s.append(0)\n            else:\n                s.append(-1)\n        return len(match(s, pattern))\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(nums = [1,2,3,4,5,6], pattern = [1,1]) == 4\n    assert candidate(nums = [1,4,4,1,3,5,5,3], pattern = [1,0,-1]) == 2\n\n\ncheck(Solution().countMatchingSubarrays)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given a 0-indexed string word and an integer k.\nAt every second, you must perform the following operations:\n\nRemove the first k characters of word.\nAdd any k characters to the end of word.\n\nNote that you do not necessarily need to add the same characters that you removed. However, you must perform both operations at every second.\nReturn the minimum time greater than zero required for word to revert to its initial state.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def minimumTimeToInitialState(self, word: str, k: int) -> int:\n```",
        "solutions": "class Hashing:\n    __slots__ = [\"mod\", \"h\", \"p\"]\n\n    def __init__(self, s: str, base: int, mod: int):\n        self.mod = mod\n        self.h = [0] * (len(s) + 1)\n        self.p = [1] * (len(s) + 1)\n        for i in range(1, len(s) + 1):\n            self.h[i] = (self.h[i - 1] * base + ord(s[i - 1])) % mod\n            self.p[i] = (self.p[i - 1] * base) % mod\n\n    def query(self, l: int, r: int) -> int:\n        return (self.h[r] - self.h[l - 1] * self.p[r - l + 1]) % self.mod\n\n\nclass Solution:\n    def minimumTimeToInitialState(self, word: str, k: int) -> int:\n        hashing = Hashing(word, 13331, 998244353)\n        n = len(word)\n        for i in range(k, n, k):\n            if hashing.query(1, n - i) == hashing.query(i + 1, n):\n                return i // k\n        return (n + k - 1) // k\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(word = \"abacaba\", k = 3) == 2\n    assert candidate(word = \"abacaba\", k = 4) == 1\n    assert candidate(word = \"abcbabcd\", k = 2) == 4\n\n\ncheck(Solution().minimumTimeToInitialState)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given a 0-indexed string word and an integer k.\nAt every second, you must perform the following operations:\n\nRemove the first k characters of word.\nAdd any k characters to the end of word.\n\nNote that you do not necessarily need to add the same characters that you removed. However, you must perform both operations at every second.\nReturn the minimum time greater than zero required for word to revert to its initial state.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def minimumTimeToInitialState(self, word: str, k: int) -> int:\n```",
        "solutions": "class Solution:\n    def minimumTimeToInitialState(self, word: str, k: int) -> int:\n        n = len(word)\n        for i in range(k, n, k):\n            if word[i:] == word[:-i]:\n                return i // k\n        return (n + k - 1) // k\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(word = \"abacaba\", k = 3) == 2\n    assert candidate(word = \"abacaba\", k = 4) == 1\n    assert candidate(word = \"abcbabcd\", k = 2) == 4\n\n\ncheck(Solution().minimumTimeToInitialState)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given an array of positive integers nums.\nYou need to select a subset of nums which satisfies the following condition:\n\nYou can place the selected elements in a 0-indexed array such that it follows the pattern: [x, x2, x4, ..., xk/2, xk, xk/2, ..., x4, x2, x] (Note that k can be be any non-negative power of 2). For example, [2, 4, 16, 4, 2] and [3, 9, 3] follow the pattern while [2, 4, 8, 4, 2] does not.\n\nReturn the maximum number of elements in a subset that satisfies these conditions.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def maximumLength(self, nums: List[int]) -> int:\n```",
        "solutions": "class Solution:\n    def maximumLength(self, nums: List[int]) -> int:\n        cnt = Counter(nums)\n        ans = cnt[1] - (cnt[1] % 2 ^ 1)\n        del cnt[1]\n        for x in cnt:\n            t = 0\n            while cnt[x] > 1:\n                x = x * x\n                t += 2\n            t += 1 if cnt[x] else -1\n            ans = max(ans, t)\n        return ans\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(nums = [5,4,1,2,2]) == 3\n    assert candidate(nums = [1,3,2,4]) == 1\n\n\ncheck(Solution().maximumLength)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given a 2D integer array edges representing a tree with n nodes, numbered from 0 to n - 1, rooted at node 0, where edges[i] = [ui, vi] means there is an edge between the nodes vi and ui.\nYou are also given a 0-indexed integer array colors of size n, where colors[i] is the color assigned to node i.\nWe want to find a node v such that every node in the subtree of v has the same color.\nReturn the size of such subtree with the maximum number of nodes possible.\n\u00a0\n\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def maximumSubtreeSize(self, edges: List[List[int]], colors: List[int]) -> int:\n```",
        "solutions": "class Solution:\n    def maximumSubtreeSize(self, edges: List[List[int]], colors: List[int]) -> int:\n        def dfs(a: int, fa: int) -> bool:\n            ok = True\n            for b in g[a]:\n                if b != fa:\n                    t = dfs(b, a)\n                    ok = ok and colors[a] == colors[b] and t\n                    size[a] += size[b]\n            if ok:\n                nonlocal ans\n                ans = max(ans, size[a])\n            return ok\n\n        n = len(edges) + 1\n        g = [[] for _ in range(n)]\n        size = [1] * n\n        for a, b in edges:\n            g[a].append(b)\n            g[b].append(a)\n        ans = 0\n        dfs(0, -1)\n        return ans\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(edges = [[0,1],[0,2],[0,3]], colors = [1,1,2,3]) == 1\n    assert candidate(edges = [[0,1],[0,2],[0,3]], colors = [1,1,1,1]) == 4\n    assert candidate(edges = [[0,1],[0,2],[2,3],[2,4]], colors = [1,2,3,3,3]) == 3\n\n\ncheck(Solution().maximumSubtreeSize)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given a 0-indexed string array words.\nLet's define a boolean function isPrefixAndSuffix that takes two strings, str1 and str2:\n\nisPrefixAndSuffix(str1, str2) returns true if str1 is both a prefix and a suffix of str2, and false otherwise.\n\nFor example, isPrefixAndSuffix(\"aba\", \"ababa\") is true because \"aba\" is a prefix of \"ababa\" and also a suffix, but isPrefixAndSuffix(\"abc\", \"abcd\") is false.\nReturn an integer denoting the number of index pairs (i, j) such that i < j, and isPrefixAndSuffix(words[i], words[j]) is true.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def countPrefixSuffixPairs(self, words: List[str]) -> int:\n```",
        "solutions": "class Node:\n    __slots__ = [\"children\", \"cnt\"]\n\n    def __init__(self):\n        self.children = {}\n        self.cnt = 0\n\n\nclass Solution:\n    def countPrefixSuffixPairs(self, words: List[str]) -> int:\n        ans = 0\n        trie = Node()\n        for s in words:\n            node = trie\n            for p in zip(s, reversed(s)):\n                if p not in node.children:\n                    node.children[p] = Node()\n                node = node.children[p]\n                ans += node.cnt\n            node.cnt += 1\n        return ans\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(words = [\"a\",\"aba\",\"ababa\",\"aa\"]) == 4\n    assert candidate(words = [\"pa\",\"papa\",\"ma\",\"mama\"]) == 2\n    assert candidate(words = [\"abab\",\"ab\"]) == 0\n\n\ncheck(Solution().countPrefixSuffixPairs)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given a 0-indexed string array words.\nLet's define a boolean function isPrefixAndSuffix that takes two strings, str1 and str2:\n\nisPrefixAndSuffix(str1, str2) returns true if str1 is both a prefix and a suffix of str2, and false otherwise.\n\nFor example, isPrefixAndSuffix(\"aba\", \"ababa\") is true because \"aba\" is a prefix of \"ababa\" and also a suffix, but isPrefixAndSuffix(\"abc\", \"abcd\") is false.\nReturn an integer denoting the number of index pairs (i, j) such that i < j, and isPrefixAndSuffix(words[i], words[j]) is true.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def countPrefixSuffixPairs(self, words: List[str]) -> int:\n```",
        "solutions": "class Solution:\n    def countPrefixSuffixPairs(self, words: List[str]) -> int:\n        ans = 0\n        for i, s in enumerate(words):\n            for t in words[i + 1 :]:\n                ans += t.endswith(s) and t.startswith(s)\n        return ans\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(words = [\"a\",\"aba\",\"ababa\",\"aa\"]) == 4\n    assert candidate(words = [\"pa\",\"papa\",\"ma\",\"mama\"]) == 2\n    assert candidate(words = [\"abab\",\"ab\"]) == 0\n\n\ncheck(Solution().countPrefixSuffixPairs)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given three positive integers n, x, and y.\nIn a city, there exist houses numbered 1 to n connected by n streets. There is a street connecting the house numbered i with the house numbered i + 1 for all 1 <= i <= n - 1 . An additional street connects the house numbered x with the house numbered y.\nFor each k, such that 1 <= k <= n, you need to find the number of pairs of houses (house1, house2) such that the minimum number of streets that need to be traveled to reach house2 from house1 is k.\nReturn a 1-indexed array result of length n where result[k] represents the total number of pairs of houses such that the minimum streets required to reach one house from the other is k.\nNote that x and y can be equal.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def countOfPairs(self, n: int, x: int, y: int) -> List[int]:\n```",
        "solutions": "class Solution:\n    def countOfPairs(self, n: int, x: int, y: int) -> List[int]:\n        if abs(x - y) <= 1:\n            return [2 * x for x in reversed(range(n))]\n        cycle_len = abs(x - y) + 1\n        n2 = n - cycle_len + 2\n        res = [2 * x for x in reversed(range(n2))]\n        while len(res) < n:\n            res.append(0)\n        res2 = [cycle_len * 2] * (cycle_len >> 1)\n        if not cycle_len & 1:\n            res2[-1] = cycle_len\n        res2[0] -= 2\n        for i in range(len(res2)):\n            res[i] += res2[i]\n        if x > y:\n            x, y = y, x\n        tail1 = x - 1\n        tail2 = n - y\n        for tail in (tail1, tail2):\n            if not tail:\n                continue\n            i_mx = tail + (cycle_len >> 1)\n            val_mx = 4 * min((cycle_len - 3) >> 1, tail)\n            i_mx2 = i_mx - (1 - (cycle_len & 1))\n            res3 = [val_mx] * i_mx\n            res3[0] = 0\n            res3[1] = 0\n            if not cycle_len & 1:\n                res3[-1] = 0\n            for i, j in enumerate(range(4, val_mx, 4)):\n                res3[i + 2] = j\n                res3[i_mx2 - i - 1] = j\n            for i in range(1, tail + 1):\n                res3[i] += 2\n            if not cycle_len & 1:\n                mn = cycle_len >> 1\n                for i in range(mn, mn + tail):\n                    res3[i] += 2\n            for i in range(len(res3)):\n                res[i] += res3[i]\n        return res\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(n = 3, x = 1, y = 3) == [6,0,0]\n    assert candidate(n = 5, x = 2, y = 4) == [10,8,2,0,0]\n    assert candidate(n = 4, x = 1, y = 1) == [6,4,2,0]\n\n\ncheck(Solution().countOfPairs)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nAn ant is on a boundary. It sometimes goes left and sometimes right.\nYou are given an array of non-zero integers nums. The ant starts reading nums from the first element of it to its end. At each step, it moves according to the value of the current element:\n\nIf nums[i] < 0, it moves left by -nums[i] units.\nIf nums[i] > 0, it moves right by nums[i] units.\n\nReturn the number of times the ant returns to the boundary.\nNotes:\n\nThere is an infinite space on both sides of the boundary.\nWe check whether the ant is on the boundary only after it has moved |nums[i]| units. In other words, if the ant crosses the boundary during its movement, it does not count.\n\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def returnToBoundaryCount(self, nums: List[int]) -> int:\n```",
        "solutions": "class Solution:\n    def returnToBoundaryCount(self, nums: List[int]) -> int:\n        return sum(s == 0 for s in accumulate(nums))\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(nums = [2,3,-5]) == 1\n    assert candidate(nums = [3,2,-3,-4]) == 0\n\n\ncheck(Solution().returnToBoundaryCount)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given an array of integers nums with length n, and a positive odd integer k.\nSelect exactly k disjoint subarrays sub1, sub2, ..., subk from nums such that the last element of subi appears before the first element of sub{i+1} for all 1 <= i <= k-1. The goal is to maximize their combined strength.\nThe strength of the selected subarrays is defined as:\nstrength = k * sum(sub1)- (k - 1) * sum(sub2) + (k - 2) * sum(sub3) - ... - 2 * sum(sub{k-1}) + sum(subk)\nwhere sum(subi) is the sum of the elements in the i-th subarray.\nReturn the maximum possible strength that can be obtained from selecting exactly k disjoint subarrays from nums.\nNote that the chosen subarrays don't need to cover the entire array.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def maximumStrength(self, nums: List[int], k: int) -> int:\n```",
        "solutions": "class Solution:\n    def maximumStrength(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        f = [[[-inf, -inf] for _ in range(k + 1)] for _ in range(n + 1)]\n        f[0][0][0] = 0\n        for i, x in enumerate(nums, 1):\n            for j in range(k + 1):\n                sign = 1 if j & 1 else -1\n                f[i][j][0] = max(f[i - 1][j][0], f[i - 1][j][1])\n                f[i][j][1] = max(f[i][j][1], f[i - 1][j][1] + sign * x * (k - j + 1))\n                if j:\n                    f[i][j][1] = max(\n                        f[i][j][1], max(f[i - 1][j - 1]) + sign * x * (k - j + 1)\n                    )\n        return max(f[n][k])\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(nums = [1,2,3,-1,2], k = 3) == 22\n    assert candidate(nums = [12,-2,-2,-2,-2], k = 5) == 64\n    assert candidate(nums = [-1,-2,-3], k = 1) == -1\n\n\ncheck(Solution().maximumStrength)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given a 0-indexed array nums and a 0-indexed array queries.\nYou can do the following operation at the beginning at most once:\n\nReplace nums with a subsequence of nums.\n\nWe start processing queries in the given order; for each query, we do the following:\n\nIf the first and the last element of nums is less than queries[i], the processing of queries ends.\nOtherwise, we choose either the first or the last element of nums if it is greater than or equal to queries[i], and we remove the chosen element from nums.\n\nReturn the maximum number of queries that can be processed by doing the operation optimally.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def maximumProcessableQueries(self, nums: List[int], queries: List[int]) -> int:\n```",
        "solutions": "class Solution:\n    def maximumProcessableQueries(self, nums: List[int], queries: List[int]) -> int:\n        n = len(nums)\n        f = [[0] * n for _ in range(n)]\n        m = len(queries)\n        for i in range(n):\n            for j in range(n - 1, i - 1, -1):\n                if i:\n                    f[i][j] = max(\n                        f[i][j], f[i - 1][j] + (nums[i - 1] >= queries[f[i - 1][j]])\n                    )\n                if j + 1 < n:\n                    f[i][j] = max(\n                        f[i][j], f[i][j + 1] + (nums[j + 1] >= queries[f[i][j + 1]])\n                    )\n                if f[i][j] == m:\n                    return m\n        return max(f[i][i] + (nums[i] >= queries[f[i][i]]) for i in range(n))\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(nums = [1,2,3,4,5], queries = [1,2,3,4,6]) == 4\n    assert candidate(nums = [2,3,2], queries = [2,2,3]) == 3\n    assert candidate(nums = [3,4,3], queries = [4,3,2]) == 2\n\n\ncheck(Solution().maximumProcessableQueries)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given an integer array nums of even length. You have to split the array into two parts nums1 and nums2 such that:\n\nnums1.length == nums2.length == nums.length / 2.\nnums1 should contain distinct elements.\nnums2 should also contain distinct elements.\n\nReturn true if it is possible to split the array, and false otherwise.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def isPossibleToSplit(self, nums: List[int]) -> bool:\n```",
        "solutions": "class Solution:\n    def isPossibleToSplit(self, nums: List[int]) -> bool:\n        return max(Counter(nums).values()) < 3\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(nums = [1,1,2,2,3,4]) == True\n    assert candidate(nums = [1,1,1,1]) == False\n\n\ncheck(Solution().isPossibleToSplit)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nThere exist n rectangles in a 2D plane with edges parallel to the x and y axis. You are given two 2D integer arrays\u00a0bottomLeft and topRight\u00a0where bottomLeft[i] = [a_i, b_i] and topRight[i] = [c_i, d_i] represent\u00a0the bottom-left and top-right coordinates of the ith rectangle, respectively.\nYou need to find the maximum area of a square that can fit inside the intersecting region of at least two rectangles. Return 0 if such a square does not exist.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def largestSquareArea(self, bottomLeft: List[List[int]], topRight: List[List[int]]) -> int:\n```",
        "solutions": "class Solution:\n    def largestSquareArea(\n        self, bottomLeft: List[List[int]], topRight: List[List[int]]\n    ) -> int:\n        ans = 0\n        for ((x1, y1), (x2, y2)), ((x3, y3), (x4, y4)) in combinations(\n            zip(bottomLeft, topRight), 2\n        ):\n            w = min(x2, x4) - max(x1, x3)\n            h = min(y2, y4) - max(y1, y3)\n            e = min(w, h)\n            if e > 0:\n                ans = max(ans, e * e)\n        return ans\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(bottomLeft = [[1,1],[2,2],[3,1]], topRight = [[3,3],[4,4],[6,6]]) == 1\n    assert candidate(bottomLeft = [[1,1],[2,2],[1,2]], topRight = [[3,3],[4,4],[3,4]]) == 1\n    assert candidate(bottomLeft = [[1,1],[3,3],[3,1]], topRight = [[2,2],[4,4],[4,2]]) == 0\n\n\ncheck(Solution().largestSquareArea)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given a binary array nums of length n, a positive integer k and a non-negative integer maxChanges.\nAlice plays a game, where the goal is for Alice to pick up k ones from nums using the minimum number of moves. When the game starts, Alice picks up any index aliceIndex in the range [0, n - 1] and stands there. If nums[aliceIndex] == 1 , Alice picks up the one and nums[aliceIndex] becomes 0(this does not count as a move). After this, Alice can make any number of moves (including zero) where in each move Alice must perform exactly one of the following actions:\n\nSelect any index j != aliceIndex such that nums[j] == 0 and set nums[j] = 1. This action can be performed at most maxChanges times.\nSelect any two adjacent indices x and y (|x - y| == 1) such that nums[x] == 1, nums[y] == 0, then swap their values (set nums[y] = 1 and nums[x] = 0). If y == aliceIndex, Alice picks up the one after this move and nums[y] becomes 0.\n\nReturn the minimum number of moves required by Alice to pick exactly k ones.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def minimumMoves(self, nums: List[int], k: int, maxChanges: int) -> int:\n```",
        "solutions": "class Solution:\n    def minimumMoves(self, nums: List[int], k: int, maxChanges: int) -> int:\n        n = len(nums)\n        cnt = [0] * (n + 1)\n        s = [0] * (n + 1)\n        for i, x in enumerate(nums, 1):\n            cnt[i] = cnt[i - 1] + x\n            s[i] = s[i - 1] + i * x\n        ans = inf\n        max = lambda x, y: x if x > y else y\n        min = lambda x, y: x if x < y else y\n        for i, x in enumerate(nums, 1):\n            t = 0\n            need = k - x\n            for j in (i - 1, i + 1):\n                if need > 0 and 1 <= j <= n and nums[j - 1] == 1:\n                    need -= 1\n                    t += 1\n            c = min(need, maxChanges)\n            need -= c\n            t += c * 2\n            if need <= 0:\n                ans = min(ans, t)\n                continue\n            l, r = 2, max(i - 1, n - i)\n            while l <= r:\n                mid = (l + r) >> 1\n                l1, r1 = max(1, i - mid), max(0, i - 2)\n                l2, r2 = min(n + 1, i + 2), min(n, i + mid)\n                c1 = cnt[r1] - cnt[l1 - 1]\n                c2 = cnt[r2] - cnt[l2 - 1]\n                if c1 + c2 >= need:\n                    t1 = c1 * i - (s[r1] - s[l1 - 1])\n                    t2 = s[r2] - s[l2 - 1] - c2 * i\n                    ans = min(ans, t + t1 + t2)\n                    r = mid - 1\n                else:\n                    l = mid + 1\n        return ans\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(nums = [1,1,0,0,0,1,1,0,0,1], k = 3, maxChanges = 1) == 3\n    assert candidate(nums = [0,0,0,0], k = 2, maxChanges = 3) == 4\n\n\ncheck(Solution().minimumMoves)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given a positive integer k. Initially, you have an array nums = [1].\nYou can perform any of the following operations on the array any number of times (possibly zero):\n\nChoose any element in the array and increase its value by 1.\nDuplicate any element in the array and add it to the end of the array.\n\nReturn the minimum number of operations required to make the sum of elements of the final array greater than or equal to k.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def minOperations(self, k: int) -> int:\n```",
        "solutions": "class Solution:\n    def minOperations(self, k: int) -> int:\n        ans = k\n        for a in range(k):\n            x = a + 1\n            b = (k + x - 1) // x - 1\n            ans = min(ans, a + b)\n        return ans\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(k = 11) == 5\n    assert candidate(k = 1) == 0\n\n\ncheck(Solution().minOperations)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given two arrays with positive integers arr1 and arr2.\nA prefix of a positive integer is an integer formed by one or more of its digits, starting from its leftmost digit. For example, 123 is a prefix of the integer 12345, while 234 is not.\nA common prefix of two integers a and b is an integer c, such that c is a prefix of both a and b. For example, 5655359 and 56554 have common prefixes 565 and 5655 while 1223 and 43456 do not have a common prefix.\nYou need to find the length of the longest common prefix between all pairs of integers (x, y) such that x belongs to arr1 and y belongs to arr2.\nReturn the length of the longest common prefix among all pairs. If no common prefix exists among them, return 0.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def longestCommonPrefix(self, arr1: List[int], arr2: List[int]) -> int:\n```",
        "solutions": "class Solution:\n    def longestCommonPrefix(self, arr1: List[int], arr2: List[int]) -> int:\n        s = set()\n        for x in arr1:\n            while x:\n                s.add(x)\n                x //= 10\n        ans = 0\n        for x in arr2:\n            while x:\n                if x in s:\n                    ans = max(ans, len(str(x)))\n                    break\n                x //= 10\n        return ans\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(arr1 = [1,10,100], arr2 = [1000]) == 3\n    assert candidate(arr1 = [1,2,3], arr2 = [4,4,4]) == 0\n\n\ncheck(Solution().longestCommonPrefix)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nGiven a 0-indexed m x n integer matrix matrix, create a new 0-indexed matrix called answer. Make answer equal to matrix, then replace each element with the value -1 with the maximum element in its respective column.\nReturn the matrix answer.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def modifiedMatrix(self, matrix: List[List[int]]) -> List[List[int]]:\n```",
        "solutions": "class Solution:\n    def modifiedMatrix(self, matrix: List[List[int]]) -> List[List[int]]:\n        m, n = len(matrix), len(matrix[0])\n        for j in range(n):\n            mx = max(matrix[i][j] for i in range(m))\n            for i in range(m):\n                if matrix[i][j] == -1:\n                    matrix[i][j] = mx\n        return matrix\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(matrix = [[1,2,-1],[4,-1,6],[7,8,9]]) == [[1,2,9],[4,8,6],[7,8,9]]\n    assert candidate(matrix = [[3,-1],[5,2]]) == [[3,2],[5,2]]\n\n\ncheck(Solution().modifiedMatrix)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given an array apple of size n and an array capacity of size m.\nThere are n packs where the ith pack contains apple[i] apples. There are m boxes as well, and the ith box has a capacity of capacity[i] apples.\nReturn the minimum number of boxes you need to select to redistribute these n packs of apples into boxes.\nNote that, apples from the same pack can be distributed into different boxes.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def minimumBoxes(self, apple: List[int], capacity: List[int]) -> int:\n```",
        "solutions": "class Solution:\n    def minimumBoxes(self, apple: List[int], capacity: List[int]) -> int:\n        capacity.sort(reverse=True)\n        s = sum(apple)\n        for i, c in enumerate(capacity, 1):\n            s -= c\n            if s <= 0:\n                return i\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(apple = [1,3,2], capacity = [4,3,1,5,2]) == 2\n    assert candidate(apple = [5,5,5], capacity = [2,4,2,7]) == 4\n\n\ncheck(Solution().minimumBoxes)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given a 0-indexed n x n grid where n is odd, and grid[r][c] is 0, 1, or 2.\nWe say that a cell belongs to the Letter Y if it belongs to one of the following:\n\nThe diagonal starting at the top-left cell and ending at the center cell of the grid.\nThe diagonal starting at the top-right cell and ending at the center cell of the grid.\nThe vertical line starting at the center cell and ending at the bottom border of the grid.\n\nThe Letter Y is written on the grid if and only if:\n\nAll values at cells belonging to the Y are equal.\nAll values at cells not belonging to the Y are equal.\nThe values at cells belonging to the Y are different from the values at cells not belonging to the Y.\n\nReturn the minimum number of operations needed to write the letter Y on the grid given that in one operation you can change the value at any cell to 0, 1, or 2.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def minimumOperationsToWriteY(self, grid: List[List[int]]) -> int:\n```",
        "solutions": "class Solution:\n    def minimumOperationsToWriteY(self, grid: List[List[int]]) -> int:\n        n = len(grid)\n        cnt1 = Counter()\n        cnt2 = Counter()\n        for i, row in enumerate(grid):\n            for j, x in enumerate(row):\n                a = i == j and i <= n // 2\n                b = i + j == n - 1 and i <= n // 2\n                c = j == n // 2 and i >= n // 2\n                if a or b or c:\n                    cnt1[x] += 1\n                else:\n                    cnt2[x] += 1\n        return min(\n            n * n - cnt1[i] - cnt2[j] for i in range(3) for j in range(3) if i != j\n        )\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(grid = [[1,2,2],[1,1,0],[0,1,0]]) == 3\n    assert candidate(grid = [[0,1,0,1,0],[2,1,0,1,2],[2,2,2,0,1],[2,2,2,2,2],[2,1,2,2,2]]) == 12\n\n\ncheck(Solution().minimumOperationsToWriteY)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given two integers numBottles and numExchange.\nnumBottles represents the number of full water bottles that you initially have. In one operation, you can perform one of the following operations:\n\nDrink any number of full water bottles turning them into empty bottles.\nExchange numExchange empty bottles with one full water bottle. Then, increase numExchange by one.\n\nNote that you cannot exchange multiple batches of empty bottles for the same value of numExchange. For example, if numBottles == 3 and numExchange == 1, you cannot exchange 3 empty water bottles for 3 full bottles.\nReturn the maximum number of water bottles you can drink.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def maxBottlesDrunk(self, numBottles: int, numExchange: int) -> int:\n```",
        "solutions": "class Solution:\n    def maxBottlesDrunk(self, numBottles: int, numExchange: int) -> int:\n        ans = numBottles\n        while numBottles >= numExchange:\n            numBottles -= numExchange\n            numExchange += 1\n            ans += 1\n            numBottles += 1\n        return ans\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(numBottles = 13, numExchange = 6) == 15\n    assert candidate(numBottles = 10, numExchange = 3) == 13\n\n\ncheck(Solution().maxBottlesDrunk)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given a string s and a character c. Return the total number of substrings of s that start and end with c.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def countSubstrings(self, s: str, c: str) -> int:\n```",
        "solutions": "class Solution:\n    def countSubstrings(self, s: str, c: str) -> int:\n        cnt = s.count(c)\n        return cnt + cnt * (cnt - 1) // 2\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(s = \"abada\", c = \"a\") == 6\n    assert candidate(s = \"zzz\", c = \"z\") == 6\n\n\ncheck(Solution().countSubstrings)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given a 0-indexed integer matrix grid and an integer k.\nReturn the number of submatrices that contain the top-left element of the grid, and have a sum less than or equal to k.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def countSubmatrices(self, grid: List[List[int]], k: int) -> int:\n```",
        "solutions": "class Solution:\n    def countSubmatrices(self, grid: List[List[int]], k: int) -> int:\n        s = [[0] * (len(grid[0]) + 1) for _ in range(len(grid) + 1)]\n        ans = 0\n        for i, row in enumerate(grid, 1):\n            for j, x in enumerate(row, 1):\n                s[i][j] = s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + x\n                ans += s[i][j] <= k\n        return ans\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(grid = [[7,6,3],[6,6,1]], k = 18) == 4\n    assert candidate(grid = [[7,2,9],[1,5,0],[2,6,6]], k = 20) == 6\n\n\ncheck(Solution().countSubmatrices)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given an array points representing integer coordinates of some points on a 2D plane, where points[i] = [xi, yi].\nThe distance between two points is defined as their Manhattan distance.\nReturn the minimum possible value for maximum distance between any two points by removing exactly one point.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def minimumDistance(self, points: List[List[int]]) -> int:\n```",
        "solutions": "from sortedcontainers import SortedList\n\n\nclass Solution:\n    def minimumDistance(self, points: List[List[int]]) -> int:\n        sl1 = SortedList()\n        sl2 = SortedList()\n        for x, y in points:\n            sl1.add(x + y)\n            sl2.add(x - y)\n        ans = inf\n        for x, y in points:\n            sl1.remove(x + y)\n            sl2.remove(x - y)\n            ans = min(ans, max(sl1[-1] - sl1[0], sl2[-1] - sl2[0]))\n            sl1.add(x + y)\n            sl2.add(x - y)\n        return ans\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(points = [[3,10],[5,15],[10,2],[4,4]]) == 12\n    assert candidate(points = [[1,1],[1,1],[1,1]]) == 0\n\n\ncheck(Solution().minimumDistance)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given a string s and an integer k.\nDefine a function distance(s1, s2) between two strings s1 and s2 of the same length n as:\n\nThe sum of the minimum distance between s1[i] and s2[i] when the characters from 'a' to 'z' are placed in a cyclic order, for all i in the range [0, n - 1].\n\nFor example, distance(\"ab\", \"cd\") == 4, and distance(\"a\", \"z\") == 1.\nYou can change any letter of s to any other lowercase English letter, any number of times.\nReturn a string denoting the lexicographically smallest string t you can get after some changes, such that distance(s, t) <= k.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def getSmallestString(self, s: str, k: int) -> str:\n```",
        "solutions": "class Solution:\n    def getSmallestString(self, s: str, k: int) -> str:\n        cs = list(s)\n        for i, c1 in enumerate(s):\n            for c2 in ascii_lowercase:\n                if c2 >= c1:\n                    break\n                d = min(ord(c1) - ord(c2), 26 - ord(c1) + ord(c2))\n                if d <= k:\n                    cs[i] = c2\n                    k -= d\n                    break\n        return \"\".join(cs)\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(s = \"zbbz\", k = 3) == \"aaaz\"\n    assert candidate(s = \"xaxcd\", k = 4) == \"aawcd\"\n    assert candidate(s = \"lol\", k = 0) == \"lol\"\n\n\ncheck(Solution().getSmallestString)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given a 1-indexed array of distinct integers nums of length n.\nYou need to distribute all the elements of nums between two arrays arr1 and arr2 using n operations. In the first operation, append nums[1] to arr1. In the second operation, append nums[2] to arr2. Afterwards, in the ith operation:\n\nIf the last element of arr1 is greater than the last element of arr2, append nums[i] to arr1. Otherwise, append nums[i] to arr2.\n\nThe array result is formed by concatenating the arrays arr1 and arr2. For example, if arr1 == [1,2,3] and arr2 == [4,5,6], then result = [1,2,3,4,5,6].\nReturn the array result.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def resultArray(self, nums: List[int]) -> List[int]:\n```",
        "solutions": "class Solution:\n    def resultArray(self, nums: List[int]) -> List[int]:\n        arr1 = [nums[0]]\n        arr2 = [nums[1]]\n        for x in nums[2:]:\n            if arr1[-1] > arr2[-1]:\n                arr1.append(x)\n            else:\n                arr2.append(x)\n        return arr1 + arr2\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(nums = [2,1,3]) == [2,3,1]\n    assert candidate(nums = [5,4,3,8]) == [5,3,4,8]\n\n\ncheck(Solution().resultArray)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nThere is an undirected weighted graph with n vertices labeled from 0 to n - 1.\nYou are given the integer n and an array edges, where edges[i] = [ui, vi, wi] indicates that there is an edge between vertices ui and vi with a weight of wi.\nA walk on a graph is a sequence of vertices and edges. The walk starts and ends with a vertex, and each edge connects the vertex that comes before it and the vertex that comes after it. It's important to note that a walk may visit the same edge or vertex more than once.\nThe cost of a walk starting at node u and ending at node v is defined as the bitwise AND of the weights of the edges traversed during the walk. In other words, if the sequence of edge weights encountered during the walk is w0, w1, w2, ..., wk, then the cost is calculated as w0 & w1 & w2 & ... & wk, where & denotes the bitwise AND operator.\nYou are also given a 2D array query, where query[i] = [si, ti]. For each query, you need to find the minimum cost of the walk starting at vertex si and ending at vertex ti. If there exists no such walk, the answer is -1.\nReturn the array answer, where answer[i] denotes the minimum cost of a walk for query i.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def minimumCost(self, n: int, edges: List[List[int]], query: List[List[int]]) -> List[int]:\n```",
        "solutions": "class UnionFind:\n    def __init__(self, n):\n        self.p = list(range(n))\n        self.size = [1] * n\n\n    def find(self, x):\n        if self.p[x] != x:\n            self.p[x] = self.find(self.p[x])\n        return self.p[x]\n\n    def union(self, a, b):\n        pa, pb = self.find(a), self.find(b)\n        if pa == pb:\n            return False\n        if self.size[pa] > self.size[pb]:\n            self.p[pb] = pa\n            self.size[pa] += self.size[pb]\n        else:\n            self.p[pa] = pb\n            self.size[pb] += self.size[pa]\n        return True\n\n\nclass Solution:\n    def minimumCost(\n        self, n: int, edges: List[List[int]], query: List[List[int]]\n    ) -> List[int]:\n        g = [-1] * n\n        uf = UnionFind(n)\n        for u, v, _ in edges:\n            uf.union(u, v)\n        for u, _, w in edges:\n            root = uf.find(u)\n            g[root] &= w\n\n        def f(u: int, v: int) -> int:\n            if u == v:\n                return 0\n            a, b = uf.find(u), uf.find(v)\n            return g[a] if a == b else -1\n\n        return [f(s, t) for s, t in query]\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(n = 5, edges = [[0,1,7],[1,3,7],[1,2,1]], query = [[0,3],[3,4]]) == [1,-1]\n    assert candidate(n = 3, edges = [[0,2,7],[0,1,15],[1,2,6],[1,2,1]], query = [[1,2]]) == [0]\n\n\ncheck(Solution().minimumCost)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nGiven a string s, return the maximum length of a substring\u00a0such that it contains at most two occurrences of each character.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def maximumLengthSubstring(self, s: str) -> int:\n```",
        "solutions": "class Solution:\n    def maximumLengthSubstring(self, s: str) -> int:\n        cnt = Counter()\n        ans = i = 0\n        for j, c in enumerate(s):\n            cnt[c] += 1\n            while cnt[c] > 2:\n                cnt[s[i]] -= 1\n                i += 1\n            ans = max(ans, j - i + 1)\n        return ans\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate( s = \"bcbbbcba\") ==  4\n    assert candidate( s = \"aaaa\") ==  2\n\n\ncheck(Solution().maximumLengthSubstring)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given a 1-indexed array of integers nums of length n.\nWe define a function greaterCount such that greaterCount(arr, val) returns the number of elements in arr that are strictly greater than val.\nYou need to distribute all the elements of nums between two arrays arr1 and arr2 using n operations. In the first operation, append nums[1] to arr1. In the second operation, append nums[2] to arr2. Afterwards, in the ith operation:\n\nIf greaterCount(arr1, nums[i]) > greaterCount(arr2, nums[i]), append nums[i] to arr1.\nIf greaterCount(arr1, nums[i]) < greaterCount(arr2, nums[i]), append nums[i] to arr2.\nIf greaterCount(arr1, nums[i]) == greaterCount(arr2, nums[i]), append nums[i] to the array with a lesser number of elements.\nIf there is still a tie, append nums[i] to arr1.\n\nThe array result is formed by concatenating the arrays arr1 and arr2. For example, if arr1 == [1,2,3] and arr2 == [4,5,6], then result = [1,2,3,4,5,6].\nReturn the integer array result.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def resultArray(self, nums: List[int]) -> List[int]:\n```",
        "solutions": "class BinaryIndexedTree:\n    __slots__ = \"n\", \"c\"\n\n    def __init__(self, n: int):\n        self.n = n\n        self.c = [0] * (n + 1)\n\n    def update(self, x: int, delta: int) -> None:\n        while x <= self.n:\n            self.c[x] += delta\n            x += x & -x\n\n    def query(self, x: int) -> int:\n        s = 0\n        while x:\n            s += self.c[x]\n            x -= x & -x\n        return s\n\n\nclass Solution:\n    def resultArray(self, nums: List[int]) -> List[int]:\n        st = sorted(set(nums))\n        m = len(st)\n        tree1 = BinaryIndexedTree(m + 1)\n        tree2 = BinaryIndexedTree(m + 1)\n        tree1.update(bisect_left(st, nums[0]) + 1, 1)\n        tree2.update(bisect_left(st, nums[1]) + 1, 1)\n        arr1 = [nums[0]]\n        arr2 = [nums[1]]\n        for x in nums[2:]:\n            i = bisect_left(st, x) + 1\n            a = len(arr1) - tree1.query(i)\n            b = len(arr2) - tree2.query(i)\n            if a > b:\n                arr1.append(x)\n                tree1.update(i, 1)\n            elif a < b:\n                arr2.append(x)\n                tree2.update(i, 1)\n            elif len(arr1) <= len(arr2):\n                arr1.append(x)\n                tree1.update(i, 1)\n            else:\n                arr2.append(x)\n                tree2.update(i, 1)\n        return arr1 + arr2\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(nums = [2,1,3,3]) == [2,3,1,3]\n    assert candidate(nums = [5,14,3,1,2]) == [5,3,1,2,14]\n    assert candidate(nums = [3,3,3,3]) == [3,3,3,3]\n\n\ncheck(Solution().resultArray)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given an array happiness of length n, and a positive integer k.\nThere are n children standing in a queue, where the ith child has happiness value happiness[i]. You want to select k children from these n children in k turns.\nIn each turn, when you select a child, the happiness value of all the children that have not been selected till now decreases by 1. Note that the happiness value cannot become negative and gets decremented only if it is positive.\nReturn the maximum sum of the happiness values of the selected children you can achieve by selecting k children.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def maximumHappinessSum(self, happiness: List[int], k: int) -> int:\n```",
        "solutions": "class Solution:\n    def maximumHappinessSum(self, happiness: List[int], k: int) -> int:\n        happiness.sort(reverse=True)\n        ans = 0\n        for i, x in enumerate(happiness[:k]):\n            x -= i\n            ans += max(x, 0)\n        return ans\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(happiness = [1,2,3], k = 2) == 4\n    assert candidate(happiness = [1,1,1,1], k = 2) == 1\n    assert candidate(happiness = [2,3,4,5], k = 1) == 5\n\n\ncheck(Solution().maximumHappinessSum)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nGiven a string s, find any substring of length 2 which is also present in the reverse of s.\nReturn true if such a substring exists, and false otherwise.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def isSubstringPresent(self, s: str) -> bool:\n```",
        "solutions": "class Solution:\n    def isSubstringPresent(self, s: str) -> bool:\n        st = {(a, b) for a, b in pairwise(s[::-1])}\n        return any((a, b) in st for a, b in pairwise(s))\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(s = \"leetcode\") == True\n    assert candidate(s = \"abcba\") == True\n    assert candidate(s = \"abcd\") == False\n\n\ncheck(Solution().isSubstringPresent)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given an array arr of size n consisting of non-empty strings.\nFind a string array answer of size n such that:\n\nanswer[i] is the shortest substring of arr[i] that does not occur as a substring in any other string in arr. If multiple such substrings exist, answer[i] should be the lexicographically smallest. And if no such substring exists, answer[i] should be an empty string.\n\nReturn the array answer.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def shortestSubstrings(self, arr: List[str]) -> List[str]:\n```",
        "solutions": "class Solution:\n    def shortestSubstrings(self, arr: List[str]) -> List[str]:\n        ans = [\"\"] * len(arr)\n        for i, s in enumerate(arr):\n            m = len(s)\n            for j in range(1, m + 1):\n                for l in range(m - j + 1):\n                    sub = s[l : l + j]\n                    if not ans[i] or ans[i] > sub:\n                        if all(k == i or sub not in t for k, t in enumerate(arr)):\n                            ans[i] = sub\n                if ans[i]:\n                    break\n        return ans\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(arr = [\"cab\",\"ad\",\"bad\",\"c\"]) == [\"ab\",\"\",\"ba\",\"\"]\n    assert candidate(arr = [\"abc\",\"bcd\",\"abcd\"]) == [\"\",\"\",\"abcd\"]\n\n\ncheck(Solution().shortestSubstrings)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given a string word and an integer k.\nWe consider word to be k-special if |freq(word[i]) - freq(word[j])| <= k for all indices i and j in the string.\nHere, freq(x) denotes the frequency of the character x in word, and |y| denotes the absolute value of y.\nReturn the minimum number of characters you need to delete to make word k-special.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def minimumDeletions(self, word: str, k: int) -> int:\n```",
        "solutions": "class Solution:\n    def minimumDeletions(self, word: str, k: int) -> int:\n        def f(v: int) -> int:\n            ans = 0\n            for x in nums:\n                if x < v:\n                    ans += x\n                elif x > v + k:\n                    ans += x - v - k\n            return ans\n\n        nums = Counter(word).values()\n        return min(f(v) for v in range(len(word) + 1))\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(word = \"aabcaba\", k = 0) == 3\n    assert candidate(word = \"dabdcbdcdcd\", k = 2) == 2\n    assert candidate(word = \"aaabaaa\", k = 2) == 1\n\n\ncheck(Solution().minimumDeletions)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given a string s representing a 12-hour format time where some of the digits (possibly none) are replaced with a \"?\".\n12-hour times are formatted as \"HH:MM\", where HH is between 00 and 11, and MM is between 00 and 59. The earliest 12-hour time is 00:00, and the latest is 11:59.\nYou have to replace all the \"?\" characters in s with digits such that the time we obtain by the resulting string is a valid 12-hour format time and is the latest possible.\nReturn the resulting string.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def findLatestTime(self, s: str) -> str:\n```",
        "solutions": "class Solution:\n    def findLatestTime(self, s: str) -> str:\n        for h in range(11, -1, -1):\n            for m in range(59, -1, -1):\n                t = f\"{h:02d}:{m:02d}\"\n                if all(a == b for a, b in zip(s, t) if a != \"?\"):\n                    return t\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate( s = \"1?:?4\") ==  \"11:54\"\n    assert candidate( s = \"0?:5?\") ==  \"09:59\"\n\n\ncheck(Solution().findLatestTime)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nThe problem involves tracking the frequency of IDs in a collection that changes over time. You have two integer arrays, nums and freq, of equal length n. Each element in nums represents an ID, and the corresponding element in freq indicates how many times that ID should be added to or removed from the collection at each step.\n\nAddition of IDs: If freq[i] is positive, it means freq[i] IDs with the value nums[i] are added to the collection at step i.\nRemoval of IDs: If freq[i] is negative, it means -freq[i] IDs with the value nums[i] are removed from the collection at step i.\n\nReturn an array ans of length n, where ans[i] represents the count of the most frequent ID in the collection after the ith\u00a0step. If the collection is empty at any step, ans[i] should be 0 for that step.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def mostFrequentIDs(self, nums: List[int], freq: List[int]) -> List[int]:\n```",
        "solutions": "class Solution:\n    def mostFrequentIDs(self, nums: List[int], freq: List[int]) -> List[int]:\n        cnt = Counter()\n        lazy = Counter()\n        ans = []\n        pq = []\n        for x, f in zip(nums, freq):\n            lazy[cnt[x]] += 1\n            cnt[x] += f\n            heappush(pq, -cnt[x])\n            while pq and lazy[-pq[0]] > 0:\n                lazy[-pq[0]] -= 1\n                heappop(pq)\n            ans.append(0 if not pq else -pq[0])\n        return ans\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(nums = [2,3,2,1], freq = [3,2,-3,1]) == [3,3,2,2]\n    assert candidate(nums = [5,5,3], freq = [2,-2,1]) == [2,0,1]\n\n\ncheck(Solution().mostFrequentIDs)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nAn integer divisible by the sum of its digits is said to be a Harshad number. You are given an integer x. Return the sum of the digits of x if x is a Harshad number, otherwise, return -1.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def sumOfTheDigitsOfHarshadNumber(self, x: int) -> int:\n```",
        "solutions": "class Solution:\n    def sumOfTheDigitsOfHarshadNumber(self, x: int) -> int:\n        s, y = 0, x\n        while y:\n            s += y % 10\n            y //= 10\n        return s if x % s == 0 else -1\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate( x = 18) ==  9\n    assert candidate( x = 23) ==  -1\n\n\ncheck(Solution().sumOfTheDigitsOfHarshadNumber)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given an array of integers nums. Return the length of the longest subarray of nums which is either strictly increasing or strictly decreasing.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def longestMonotonicSubarray(self, nums: List[int]) -> int:\n```",
        "solutions": "class Solution:\n    def longestMonotonicSubarray(self, nums: List[int]) -> int:\n        ans = t = 1\n        for i, x in enumerate(nums[1:]):\n            if nums[i] < x:\n                t += 1\n                ans = max(ans, t)\n            else:\n                t = 1\n        t = 1\n        for i, x in enumerate(nums[1:]):\n            if nums[i] > x:\n                t += 1\n                ans = max(ans, t)\n            else:\n                t = 1\n        return ans\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(nums = [1,4,3,3,2]) == 2\n    assert candidate(nums = [3,3,3,3]) == 1\n    assert candidate(nums = [3,2,1]) == 3\n\n\ncheck(Solution().longestMonotonicSubarray)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given an integer array nums.\nReturn an integer that is the maximum distance between the indices of two (not necessarily different) prime numbers in nums.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def maximumPrimeDifference(self, nums: List[int]) -> int:\n```",
        "solutions": "class Solution:\n    def maximumPrimeDifference(self, nums: List[int]) -> int:\n        def is_prime(x: int) -> bool:\n            if x < 2:\n                return False\n            return all(x % i for i in range(2, int(sqrt(x)) + 1))\n\n        for i, x in enumerate(nums):\n            if is_prime(x):\n                for j in range(len(nums) - 1, i - 1, -1):\n                    if is_prime(nums[j]):\n                        return j - i\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate( nums = [4,2,9,5,3]) ==  3\n    assert candidate( nums = [4,8,2,8]) ==  0\n\n\ncheck(Solution().maximumPrimeDifference)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given a binary array nums.\nWe call a subarray alternating if no two adjacent elements in the subarray have the same value.\nReturn the number of alternating subarrays in nums.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def countAlternatingSubarrays(self, nums: List[int]) -> int:\n```",
        "solutions": "class Solution:\n    def countAlternatingSubarrays(self, nums: List[int]) -> int:\n        ans = s = 1\n        for a, b in pairwise(nums):\n            s = s + 1 if a != b else 1\n            ans += s\n        return ans\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate( nums = [0,1,1,1]) ==  5\n    assert candidate( nums = [1,0,1,0]) ==  10\n\n\ncheck(Solution().countAlternatingSubarrays)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given two arrays of strings wordsContainer and wordsQuery.\nFor each wordsQuery[i], you need to find a string from wordsContainer that has the longest common suffix with wordsQuery[i]. If there are two or more strings in wordsContainer that share the longest common suffix, find the string that is the smallest in length. If there are two or more such strings that have the same smallest length, find the one that occurred earlier in wordsContainer.\nReturn an array of integers ans, where ans[i] is the index of the string in wordsContainer that has the longest common suffix with wordsQuery[i].\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def stringIndices(self, wordsContainer: List[str], wordsQuery: List[str]) -> List[int]:\n```",
        "solutions": "class Trie:\n    __slots__ = (\"children\", \"length\", \"idx\")\n\n    def __init__(self):\n        self.children = [None] * 26\n        self.length = inf\n        self.idx = inf\n\n    def insert(self, w: str, i: int):\n        node = self\n        if node.length > len(w):\n            node.length = len(w)\n            node.idx = i\n        for c in w[::-1]:\n            idx = ord(c) - ord(\"a\")\n            if node.children[idx] is None:\n                node.children[idx] = Trie()\n            node = node.children[idx]\n            if node.length > len(w):\n                node.length = len(w)\n                node.idx = i\n\n    def query(self, w: str) -> int:\n        node = self\n        for c in w[::-1]:\n            idx = ord(c) - ord(\"a\")\n            if node.children[idx] is None:\n                break\n            node = node.children[idx]\n        return node.idx\n\n\nclass Solution:\n    def stringIndices(\n        self, wordsContainer: List[str], wordsQuery: List[str]\n    ) -> List[int]:\n        trie = Trie()\n        for i, w in enumerate(wordsContainer):\n            trie.insert(w, i)\n        return [trie.query(w) for w in wordsQuery]\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(wordsContainer = [\"abcd\",\"bcd\",\"xbcd\"], wordsQuery = [\"cd\",\"bcd\",\"xyz\"]) == [1,1,1]\n    assert candidate(wordsContainer = [\"abcdefgh\",\"poiuygh\",\"ghghgh\"], wordsQuery = [\"gh\",\"acbfgh\",\"acbfegh\"]) == [2,0,2]\n\n\ncheck(Solution().stringIndices)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nIn a mystic dungeon, n magicians are standing in a line. Each magician has an attribute that gives you energy. Some magicians can give you negative energy, which means taking energy from you.\nYou have been cursed in such a way that after absorbing energy from magician i, you will be instantly transported to magician (i + k). This process will be repeated until you reach the magician where (i + k) does not exist.\nIn other words, you will choose a starting point and then teleport with k jumps until you reach the end of the magicians' sequence, absorbing all the energy during the journey.\nYou are given an array energy and an integer k. Return the maximum possible energy you can gain.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def maximumEnergy(self, energy: List[int], k: int) -> int:\n```",
        "solutions": "class Solution:\n    def maximumEnergy(self, energy: List[int], k: int) -> int:\n        ans = -inf\n        n = len(energy)\n        for i in range(n - k, n):\n            j, s = i, 0\n            while j >= 0:\n                s += energy[j]\n                ans = max(ans, s)\n                j -= k\n        return ans\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate( energy = [5,2,-10,-5,1], k = 3) ==  3\n    assert candidate( energy = [-2,-3,-1], k = 2) ==  -1\n\n\ncheck(Solution().maximumEnergy)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given a string word of size n, and an integer k such that k divides n.\nIn one operation, you can pick any two indices i and j, that are divisible by k, then replace the substring of length k starting at i with the substring of length k starting at j. That is, replace the substring word[i..i + k - 1] with the substring word[j..j + k - 1].\nReturn the minimum number of operations required to make word k-periodic.\nWe say that word is k-periodic if there is some string s of length k such that word can be obtained by concatenating s an arbitrary number of times. For example, if word == \u201cababab\u201d, then word is 2-periodic for s = \"ab\".\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def minimumOperationsToMakeKPeriodic(self, word: str, k: int) -> int:\n```",
        "solutions": "class Solution:\n    def minimumOperationsToMakeKPeriodic(self, word: str, k: int) -> int:\n        n = len(word)\n        return n // k - max(Counter(word[i : i + k] for i in range(0, n, k)).values())\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(word = \"leetcodeleet\", k = 4) == 1\n    assert candidate(word = \"leetcoleet\", k = 2) == 3\n\n\ncheck(Solution().minimumOperationsToMakeKPeriodic)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given an undirected weighted graph of n nodes numbered from 0 to n - 1. The graph consists of m edges represented by a 2D array edges, where edges[i] = [ai, bi, wi] indicates that there is an edge between nodes ai and bi with weight wi.\nConsider all the shortest paths from node 0 to node n - 1 in the graph. You need to find a boolean array answer where answer[i] is true if the edge edges[i] is part of at least one shortest path. Otherwise, answer[i] is false.\nReturn the array answer.\nNote that the graph may not be connected.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def findAnswer(self, n: int, edges: List[List[int]]) -> List[bool]:\n```",
        "solutions": "class Solution:\n    def findAnswer(self, n: int, edges: List[List[int]]) -> List[bool]:\n        g = defaultdict(list)\n        for i, (a, b, w) in enumerate(edges):\n            g[a].append((b, w, i))\n            g[b].append((a, w, i))\n        dist = [inf] * n\n        dist[0] = 0\n        q = [(0, 0)]\n        while q:\n            da, a = heappop(q)\n            if da > dist[a]:\n                continue\n            for b, w, _ in g[a]:\n                if dist[b] > dist[a] + w:\n                    dist[b] = dist[a] + w\n                    heappush(q, (dist[b], b))\n        m = len(edges)\n        ans = [False] * m\n        if dist[n - 1] == inf:\n            return ans\n        q = deque([n - 1])\n        while q:\n            a = q.popleft()\n            for b, w, i in g[a]:\n                if dist[a] == dist[b] + w:\n                    ans[i] = True\n                    q.append(b)\n        return ans\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(n = 6, edges = [[0,1,4],[0,2,1],[1,3,2],[1,4,3],[1,5,1],[2,3,1],[3,5,3],[4,5,2]]) == [True,True,True,False,True,True,True,False]\n    assert candidate(n = 4, edges = [[2,0,1],[0,1,1],[0,3,4],[3,2,2]]) == [True,False,False,True]\n\n\ncheck(Solution().findAnswer)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given an integer array nums and a non-negative integer k. In one operation, you can increase or decrease any element by 1.\nReturn the minimum number of operations needed to make the median of nums equal to k.\nThe median of an array is defined as the middle element of the array when it is sorted in non-decreasing order. If there are two choices for a median, the larger of the two values is taken.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def minOperationsToMakeMedianK(self, nums: List[int], k: int) -> int:\n```",
        "solutions": "class Solution:\n    def minOperationsToMakeMedianK(self, nums: List[int], k: int) -> int:\n        nums.sort()\n        n = len(nums)\n        m = n >> 1\n        ans = abs(nums[m] - k)\n        if nums[m] > k:\n            for i in range(m - 1, -1, -1):\n                if nums[i] <= k:\n                    break\n                ans += nums[i] - k\n        else:\n            for i in range(m + 1, n):\n                if nums[i] >= k:\n                    break\n                ans += k - nums[i]\n        return ans\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(nums = [2,5,6,8,5], k = 4) == 2\n    assert candidate(nums = [2,5,6,8,5], k = 7) == 3\n    assert candidate(nums = [1,2,3,4,5,6], k = 4) == 0\n\n\ncheck(Solution().minOperationsToMakeMedianK)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given an m x n matrix grid consisting of positive integers. You can move from a cell in the matrix to any other cell that is either to the bottom or to the right (not necessarily adjacent). The score of a move from a cell with the value c1 to a cell with the value c2 is c2 - c1.\nYou can start at any cell, and you have to make at least one move.\nReturn the maximum total score you can achieve.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def maxScore(self, grid: List[List[int]]) -> int:\n```",
        "solutions": "class Solution:\n    def maxScore(self, grid: List[List[int]]) -> int:\n        f = [[0] * len(grid[0]) for _ in range(len(grid))]\n        ans = -inf\n        for i, row in enumerate(grid):\n            for j, x in enumerate(row):\n                mi = inf\n                if i:\n                    mi = min(mi, f[i - 1][j])\n                if j:\n                    mi = min(mi, f[i][j - 1])\n                ans = max(ans, x - mi)\n                f[i][j] = min(x, mi)\n        return ans\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(grid = [[9,5,7,3],[8,9,6,1],[6,7,14,3],[2,5,3,1]]) == 9\n    assert candidate(grid = [[4,3,2],[3,2,1]]) == -1\n\n\ncheck(Solution().maxScore)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given two integers n and x. You have to construct an array of positive integers nums of size n where for every 0 <= i < n - 1, nums[i + 1] is greater than nums[i], and the result of the bitwise AND operation between all elements of nums is x.\nReturn the minimum possible value of nums[n - 1].\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def minEnd(self, n: int, x: int) -> int:\n```",
        "solutions": "class Solution:\n    def minEnd(self, n: int, x: int) -> int:\n        n -= 1\n        ans = x\n        for i in range(31):\n            if x >> i & 1 ^ 1:\n                ans |= (n & 1) << i\n                n >>= 1\n        ans |= n << 31\n        return ans\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(n = 3, x = 4) == 6\n    assert candidate(n = 2, x = 7) == 15\n\n\ncheck(Solution().minEnd)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given a string s, which is known to be a concatenation of anagrams of some string t.\nReturn the minimum possible length of the string t.\nAn anagram is formed by rearranging the letters of a string. For example, \"aab\", \"aba\", and, \"baa\" are anagrams of \"aab\".\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def minAnagramLength(self, s: str) -> int:\n```",
        "solutions": "class Solution:\n    def minAnagramLength(self, s: str) -> int:\n        def check(k: int) -> bool:\n            for i in range(0, n, k):\n                cnt1 = Counter(s[i : i + k])\n                for c, v in cnt.items():\n                    if cnt1[c] * (n // k) != v:\n                        return False\n            return True\n\n        cnt = Counter(s)\n        n = len(s)\n        for i in range(1, n + 1):\n            if n % i == 0 and check(i):\n                return i\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(s = \"abba\") == 2\n    assert candidate(s = \"cdef\") == 4\n\n\ncheck(Solution().minAnagramLength)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nA word is considered valid if:\n\nIt contains a minimum of 3 characters.\nIt contains only digits (0-9), and English letters (uppercase and lowercase).\nIt includes at least one vowel.\nIt includes at least one consonant.\n\nYou are given a string word.\nReturn true if word is valid, otherwise, return false.\nNotes:\n\n'a', 'e', 'i', 'o', 'u', and their uppercases are vowels.\nA consonant is an English letter that is not a vowel.\n\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def isValid(self, word: str) -> bool:\n```",
        "solutions": "class Solution:\n    def isValid(self, word: str) -> bool:\n        if len(word) < 3:\n            return False\n        has_vowel = has_consonant = False\n        vs = set(\"aeiouAEIOU\")\n        for c in word:\n            if not c.isalnum():\n                return False\n            if c.isalpha():\n                if c in vs:\n                    has_vowel = True\n                else:\n                    has_consonant = True\n        return has_vowel and has_consonant\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(word = \"234Adas\") == True\n    assert candidate(word = \"b3\") == False\n    assert candidate(word = \"a3$e\") == False\n\n\ncheck(Solution().isValid)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given two arrays of equal length, nums1 and nums2.\nEach element in nums1 has been increased (or decreased in the case of negative) by an integer, represented by the variable x.\nAs a result, nums1 becomes equal to nums2. Two arrays are considered equal when they contain the same integers with the same frequencies.\nReturn the integer x.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def addedInteger(self, nums1: List[int], nums2: List[int]) -> int:\n```",
        "solutions": "class Solution:\n    def addedInteger(self, nums1: List[int], nums2: List[int]) -> int:\n        return min(nums2) - min(nums1)\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(nums1 = [2,6,4], nums2 = [9,7,5]) == 3\n    assert candidate(nums1 = [10], nums2 = [5]) == -5\n    assert candidate(nums1 = [1,1,1,1], nums2 = [1,1,1,1]) == 0\n\n\ncheck(Solution().addedInteger)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given two integer arrays nums1 and nums2.\nFrom nums1 two elements have been removed, and all other elements have been increased (or decreased in the case of negative) by an integer, represented by the variable x.\nAs a result, nums1 becomes equal to nums2. Two arrays are considered equal when they contain the same integers with the same frequencies.\nReturn the minimum possible integer x that achieves this equivalence.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def minimumAddedInteger(self, nums1: List[int], nums2: List[int]) -> int:\n```",
        "solutions": "class Solution:\n    def minimumAddedInteger(self, nums1: List[int], nums2: List[int]) -> int:\n        def f(x: int) -> bool:\n            i = j = cnt = 0\n            while i < len(nums1) and j < len(nums2):\n                if nums2[j] - nums1[i] != x:\n                    cnt += 1\n                else:\n                    j += 1\n                i += 1\n            return cnt <= 2\n\n        nums1.sort()\n        nums2.sort()\n        return min(\n            x\n            for x in (nums2[0] - nums1[0], nums2[0] - nums1[1], nums2[0] - nums1[2])\n            if f(x)\n        )\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(nums1 = [4,20,16,12,8], nums2 = [14,18,10]) == -2\n    assert candidate(nums1 = [3,5,5,3], nums2 = [7,7]) == 2\n\n\ncheck(Solution().minimumAddedInteger)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given a 2D matrix grid of size m x n. In one operation, you can change the value of any cell to any non-negative number. You need to perform some operations such that each cell grid[i][j] is:\n\nEqual to the cell below it, i.e. grid[i][j] == grid[i + 1][j] (if it exists).\nDifferent from the cell to its right, i.e. grid[i][j] != grid[i][j + 1] (if it exists).\n\nReturn the minimum number of operations needed.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def minimumOperations(self, grid: List[List[int]]) -> int:\n```",
        "solutions": "class Solution:\n    def minimumOperations(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        f = [[inf] * 10 for _ in range(n)]\n        for i in range(n):\n            cnt = [0] * 10\n            for j in range(m):\n                cnt[grid[j][i]] += 1\n            if i == 0:\n                for j in range(10):\n                    f[i][j] = m - cnt[j]\n            else:\n                for j in range(10):\n                    for k in range(10):\n                        if k != j:\n                            f[i][j] = min(f[i][j], f[i - 1][k] + m - cnt[j])\n        return min(f[-1])\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(grid = [[1,0,2],[1,0,2]]) == 0\n    assert candidate(grid = [[1,1,1],[0,0,0]]) == 3\n    assert candidate(grid = [[1],[2],[3]]) == 2\n\n\ncheck(Solution().minimumOperations)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given a string word. A letter\u00a0c is called special if it appears both in lowercase and uppercase in word, and every lowercase occurrence of c appears before the first uppercase occurrence of c.\nReturn the number of special letters in word.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def numberOfSpecialChars(self, word: str) -> int:\n```",
        "solutions": "class Solution:\n    def numberOfSpecialChars(self, word: str) -> int:\n        first, last = {}, {}\n        for i, c in enumerate(word):\n            if c not in first:\n                first[c] = i\n            last[c] = i\n        return sum(\n            a in last and b in first and last[a] < first[b]\n            for a, b in zip(ascii_lowercase, ascii_uppercase)\n        )\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(word = \"aaAbcBC\") == 3\n    assert candidate(word = \"abc\") == 0\n    assert candidate(word = \"AbBCab\") == 0\n\n\ncheck(Solution().numberOfSpecialChars)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given a string word. A letter is called special if it appears both in lowercase and uppercase in word.\nReturn the number of special letters in word.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def numberOfSpecialChars(self, word: str) -> int:\n```",
        "solutions": "class Solution:\n    def numberOfSpecialChars(self, word: str) -> int:\n        s = set(word)\n        return sum(a in s and b in s for a, b in zip(ascii_lowercase, ascii_uppercase))\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(word = \"aaAbcBC\") == 3\n    assert candidate(word = \"abc\") == 0\n    assert candidate(word = \"abBCab\") == 1\n\n\ncheck(Solution().numberOfSpecialChars)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given two strings s and t such that every character occurs at most once in s and t is a permutation of s.\nThe permutation difference between s and t is defined as the sum of the absolute difference between the index of the occurrence of each character in s and the index of the occurrence of the same character in t.\nReturn the permutation difference between s and t.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def findPermutationDifference(self, s: str, t: str) -> int:\n```",
        "solutions": "class Solution:\n    def findPermutationDifference(self, s: str, t: str) -> int:\n        d = {c: i for i, c in enumerate(s)}\n        return sum(abs(d[c] - i) for i, c in enumerate(t))\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(s = \"abc\", t = \"bac\") == 2\n    assert candidate(s = \"abcde\", t = \"edbac\") == 12\n\n\ncheck(Solution().findPermutationDifference)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given an array nums consisting of positive integers where all integers have the same number of digits.\nThe digit difference between two integers is the count of different digits that are in the same position in the two integers.\nReturn the sum of the digit differences between all pairs of integers in nums.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def sumDigitDifferences(self, nums: List[int]) -> int:\n```",
        "solutions": "class Solution:\n    def sumDigitDifferences(self, nums: List[int]) -> int:\n        n = len(nums)\n        m = int(log10(nums[0])) + 1\n        ans = 0\n        for _ in range(m):\n            cnt = Counter()\n            for i, x in enumerate(nums):\n                nums[i], y = divmod(x, 10)\n                cnt[y] += 1\n            ans += sum(v * (n - v) for v in cnt.values()) // 2\n        return ans\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(nums = [13,23,12]) == 4\n    assert candidate(nums = [10,10,10,10]) == 0\n\n\ncheck(Solution().sumDigitDifferences)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nGiven an integer array hours representing times in hours, return an integer denoting the number of pairs i, j where i < j and hours[i] + hours[j] forms a complete day.\nA complete day is defined as a time duration that is an exact multiple of 24 hours.\nFor example, 1 day is 24 hours, 2 days is 48 hours, 3 days is 72 hours, and so on.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def countCompleteDayPairs(self, hours: List[int]) -> int:\n```",
        "solutions": "class Solution:\n    def countCompleteDayPairs(self, hours: List[int]) -> int:\n        cnt = Counter()\n        ans = 0\n        for x in hours:\n            ans += cnt[(24 - (x % 24)) % 24]\n            cnt[x % 24] += 1\n        return ans\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(hours = [12,12,30,24,24]) == 2\n    assert candidate(hours = [72,48,24,3]) == 3\n\n\ncheck(Solution().countCompleteDayPairs)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nGiven an integer array hours representing times in hours, return an integer denoting the number of pairs i, j where i < j and hours[i] + hours[j] forms a complete day.\nA complete day is defined as a time duration that is an exact multiple of 24 hours.\nFor example, 1 day is 24 hours, 2 days is 48 hours, 3 days is 72 hours, and so on.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def countCompleteDayPairs(self, hours: List[int]) -> int:\n```",
        "solutions": "class Solution:\n    def countCompleteDayPairs(self, hours: List[int]) -> int:\n        cnt = Counter()\n        ans = 0\n        for x in hours:\n            ans += cnt[(24 - (x % 24)) % 24]\n            cnt[x % 24] += 1\n        return ans\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(hours = [12,12,30,24,24]) == 2\n    assert candidate(hours = [72,48,24,3]) == 3\n\n\ncheck(Solution().countCompleteDayPairs)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given two integers n and k.\nInitially, you start with an array a of n integers where a[i] = 1 for all 0 <= i <= n - 1. After each second, you simultaneously update each element to be the sum of all its preceding elements plus the element itself. For example, after one second, a[0] remains the same, a[1] becomes a[0] + a[1], a[2] becomes a[0] + a[1] + a[2], and so on.\nReturn the value of a[n - 1] after k seconds.\nSince the answer may be very large, return it modulo 109 + 7.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def valueAfterKSeconds(self, n: int, k: int) -> int:\n```",
        "solutions": "class Solution:\n    def valueAfterKSeconds(self, n: int, k: int) -> int:\n        a = [1] * n\n        mod = 10**9 + 7\n        for _ in range(k):\n            for i in range(1, n):\n                a[i] = (a[i] + a[i - 1]) % mod\n        return a[n - 1]\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(n = 4, k = 5) == 56\n    assert candidate(n = 5, k = 3) == 35\n\n\ncheck(Solution().valueAfterKSeconds)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given an array nums consisting of integers. You are also given a 2D array queries, where queries[i] = [posi, xi].\nFor query i, we first set nums[posi] equal to xi, then we calculate the answer to query i which is the maximum sum of a subsequence of nums where no two adjacent elements are selected.\nReturn the sum of the answers to all queries.\nSince the final answer may be very large, return it modulo 109 + 7.\nA subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def maximumSumSubsequence(self, nums: List[int], queries: List[List[int]]) -> int:\n```",
        "solutions": "def max(a: int, b: int) -> int:\n    return a if a > b else b\n\n\nclass Node:\n    __slots__ = \"l\", \"r\", \"s00\", \"s01\", \"s10\", \"s11\"\n\n    def __init__(self, l: int, r: int):\n        self.l = l\n        self.r = r\n        self.s00 = self.s01 = self.s10 = self.s11 = 0\n\n\nclass SegmentTree:\n    __slots__ = \"tr\"\n\n    def __init__(self, n: int):\n        self.tr: List[Node | None] = [None] * (n << 2)\n        self.build(1, 1, n)\n\n    def build(self, u: int, l: int, r: int):\n        self.tr[u] = Node(l, r)\n        if l == r:\n            return\n        mid = (l + r) >> 1\n        self.build(u << 1, l, mid)\n        self.build(u << 1 | 1, mid + 1, r)\n\n    def query(self, u: int, l: int, r: int) -> int:\n        if self.tr[u].l >= l and self.tr[u].r <= r:\n            return self.tr[u].s11\n        mid = (self.tr[u].l + self.tr[u].r) >> 1\n        ans = 0\n        if r <= mid:\n            ans = self.query(u << 1, l, r)\n        if l > mid:\n            ans = max(ans, self.query(u << 1 | 1, l, r))\n        return ans\n\n    def pushup(self, u: int):\n        left, right = self.tr[u << 1], self.tr[u << 1 | 1]\n        self.tr[u].s00 = max(left.s00 + right.s10, left.s01 + right.s00)\n        self.tr[u].s01 = max(left.s00 + right.s11, left.s01 + right.s01)\n        self.tr[u].s10 = max(left.s10 + right.s10, left.s11 + right.s00)\n        self.tr[u].s11 = max(left.s10 + right.s11, left.s11 + right.s01)\n\n    def modify(self, u: int, x: int, v: int):\n        if self.tr[u].l == self.tr[u].r:\n            self.tr[u].s11 = max(0, v)\n            return\n        mid = (self.tr[u].l + self.tr[u].r) >> 1\n        if x <= mid:\n            self.modify(u << 1, x, v)\n        else:\n            self.modify(u << 1 | 1, x, v)\n        self.pushup(u)\n\n\nclass Solution:\n    def maximumSumSubsequence(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        tree = SegmentTree(n)\n        for i, x in enumerate(nums, 1):\n            tree.modify(1, i, x)\n        ans = 0\n        mod = 10**9 + 7\n        for i, x in queries:\n            tree.modify(1, i + 1, x)\n            ans = (ans + tree.query(1, 1, n)) % mod\n        return ans\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(nums = [3,5,9], queries = [[1,-2],[0,-3]]) == 21\n    assert candidate(nums = [0,-1], queries = [[0,-5]]) == 0\n\n\ncheck(Solution().maximumSumSubsequence)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given a string s. Simulate events at each second i:\n\nIf s[i] == 'E', a person enters the waiting room and takes one of the chairs in it.\nIf s[i] == 'L', a person leaves the waiting room, freeing up a chair.\n\nReturn the minimum number of chairs needed so that a chair is available for every person who enters the waiting room given that it is initially empty.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def minimumChairs(self, s: str) -> int:\n```",
        "solutions": "class Solution:\n    def minimumChairs(self, s: str) -> int:\n        cnt = left = 0\n        for c in s:\n            if c == \"E\":\n                if left:\n                    left -= 1\n                else:\n                    cnt += 1\n            else:\n                left += 1\n        return cnt\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(s = \"EEEEEEE\") == 7\n    assert candidate(s = \"ELELEEL\") == 2\n    assert candidate(s = \"ELEELEELLL\") == 3\n\n\ncheck(Solution().minimumChairs)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nAn array is considered special if every pair of its adjacent elements contains two numbers with different parity.\nYou are given an array of integer nums and a 2D integer matrix queries, where for queries[i] = [fromi, toi] your task is to check that subarray nums[fromi..toi] is special or not.\nReturn an array of booleans answer such that answer[i] is true if nums[fromi..toi] is special.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def isArraySpecial(self, nums: List[int], queries: List[List[int]]) -> List[bool]:\n```",
        "solutions": "class Solution:\n    def isArraySpecial(self, nums: List[int], queries: List[List[int]]) -> List[bool]:\n        n = len(nums)\n        d = list(range(n))\n        for i in range(1, n):\n            if nums[i] % 2 != nums[i - 1] % 2:\n                d[i] = d[i - 1]\n        return [d[t] <= f for f, t in queries]\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(nums = [3,4,1,2,6], queries = [[0,4]]) == [False]\n    assert candidate(nums = [4,3,1,6], queries = [[0,2],[2,3]]) == [False,True]\n\n\ncheck(Solution().isArraySpecial)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nAn array is considered special if every pair of its adjacent elements contains two numbers with different parity.\nYou are given an array of integers nums. Return true if nums is a special array, otherwise, return false.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def isArraySpecial(self, nums: List[int]) -> bool:\n```",
        "solutions": "class Solution:\n    def isArraySpecial(self, nums: List[int]) -> bool:\n        return all(a % 2 != b % 2 for a, b in pairwise(nums))\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(nums = [1]) == True\n    assert candidate(nums = [2,1,4]) == True\n    assert candidate(nums = [4,3,1,6]) == False\n\n\ncheck(Solution().isArraySpecial)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given a positive integer days representing the total number of days an employee is available for work (starting from day 1). You are also given a 2D array meetings of size n where, meetings[i] = [start_i, end_i] represents the starting and ending days of meeting i (inclusive).\nReturn the count of days when the employee is available for work but no meetings are scheduled.\nNote: The meetings may overlap.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def countDays(self, days: int, meetings: List[List[int]]) -> int:\n```",
        "solutions": "class Solution:\n    def countDays(self, days: int, meetings: List[List[int]]) -> int:\n        meetings.sort()\n        ans = last = 0\n        for st, ed in meetings:\n            if last < st:\n                ans += st - last - 1\n            last = max(last, ed)\n        ans += days - last\n        return ans\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(days = 10, meetings = [[5,7],[1,3],[9,10]]) == 2\n    assert candidate(days = 5, meetings = [[2,4],[1,3]]) == 1\n    assert candidate(days = 6, meetings = [[1,6]]) == 0\n\n\ncheck(Solution().countDays)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given an array nums and an integer k. You need to find a subarray of nums such that the absolute difference between k and the bitwise OR of the subarray elements is as small as possible. In other words, select a subarray nums[l..r] such that |k - (nums[l] OR nums[l + 1] ... OR nums[r])| is minimum.\nReturn the minimum possible value of the absolute difference.\nA subarray is a contiguous non-empty sequence of elements within an array.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def minimumDifference(self, nums: List[int], k: int) -> int:\n```",
        "solutions": "class Solution:\n    def minimumDifference(self, nums: List[int], k: int) -> int:\n        m = max(nums).bit_length()\n        cnt = [0] * m\n        s = i = 0\n        ans = inf\n        for j, x in enumerate(nums):\n            s |= x\n            ans = min(ans, abs(s - k))\n            for h in range(m):\n                if x >> h & 1:\n                    cnt[h] += 1\n            while i < j and s > k:\n                y = nums[i]\n                for h in range(m):\n                    if y >> h & 1:\n                        cnt[h] -= 1\n                        if cnt[h] == 0:\n                            s ^= 1 << h\n                i += 1\n                ans = min(ans, abs(s - k))\n        return ans\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(nums = [1,2,4,5], k = 3) == 0\n    assert candidate(nums = [1,3,1,3], k = 2) == 1\n    assert candidate(nums = [1], k = 10) == 9\n\n\ncheck(Solution().minimumDifference)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nA peak in an array arr is an element that is greater than its previous and next element in arr.\nYou are given an integer array nums and a 2D integer array queries.\nYou have to process queries of two types:\n\nqueries[i] = [1, li, ri], determine the count of peak elements in the subarray nums[li..ri].\nqueries[i] = [2, indexi, vali], change nums[indexi] to vali.\n\nReturn an array answer containing the results of the queries of the first type in order.\nNotes:\n\nThe first and the last element of an array or a subarray cannot be a peak.\n\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def countOfPeaks(self, nums: List[int], queries: List[List[int]]) -> List[int]:\n```",
        "solutions": "class BinaryIndexedTree:\n    __slots__ = \"n\", \"c\"\n\n    def __init__(self, n: int):\n        self.n = n\n        self.c = [0] * (n + 1)\n\n    def update(self, x: int, delta: int) -> None:\n        while x <= self.n:\n            self.c[x] += delta\n            x += x & -x\n\n    def query(self, x: int) -> int:\n        s = 0\n        while x:\n            s += self.c[x]\n            x -= x & -x\n        return s\n\n\nclass Solution:\n    def countOfPeaks(self, nums: List[int], queries: List[List[int]]) -> List[int]:\n        def update(i: int, val: int):\n            if i <= 0 or i >= n - 1:\n                return\n            if nums[i - 1] < nums[i] and nums[i] > nums[i + 1]:\n                tree.update(i, val)\n\n        n = len(nums)\n        tree = BinaryIndexedTree(n - 1)\n        for i in range(1, n - 1):\n            update(i, 1)\n        ans = []\n        for q in queries:\n            if q[0] == 1:\n                l, r = q[1] + 1, q[2] - 1\n                ans.append(0 if l > r else tree.query(r) - tree.query(l - 1))\n            else:\n                idx, val = q[1:]\n                for i in range(idx - 1, idx + 2):\n                    update(i, -1)\n                nums[idx] = val\n                for i in range(idx - 1, idx + 2):\n                    update(i, 1)\n        return ans\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(nums = [3,1,4,2,5], queries = [[2,3,4],[1,0,4]]) == [0]\n    assert candidate(nums = [4,1,4,2,1,5], queries = [[2,2,4],[1,0,2],[1,0,4]]) == [0,1]\n\n\ncheck(Solution().countOfPeaks)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nThere exist two undirected trees with n and m nodes, numbered from 0 to n - 1 and from 0 to m - 1, respectively. You are given two 2D integer arrays edges1 and edges2 of lengths n - 1 and m - 1, respectively, where edges1[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the first tree and edges2[i] = [ui, vi] indicates that there is an edge between nodes ui and vi in the second tree.\nYou must connect one node from the first tree with another node from the second tree with an edge.\nReturn the minimum possible diameter of the resulting tree.\nThe diameter of a tree is the length of the longest path between any two nodes in the tree.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def minimumDiameterAfterMerge(self, edges1: List[List[int]], edges2: List[List[int]]) -> int:\n```",
        "solutions": "class Solution:\n    def minimumDiameterAfterMerge(\n        self, edges1: List[List[int]], edges2: List[List[int]]\n    ) -> int:\n        d1 = self.treeDiameter(edges1)\n        d2 = self.treeDiameter(edges2)\n        return max(d1, d2, (d1 + 1) // 2 + (d2 + 1) // 2 + 1)\n\n    def treeDiameter(self, edges: List[List[int]]) -> int:\n        def dfs(i: int, fa: int, t: int):\n            for j in g[i]:\n                if j != fa:\n                    dfs(j, i, t + 1)\n            nonlocal ans, a\n            if ans < t:\n                ans = t\n                a = i\n\n        g = defaultdict(list)\n        for a, b in edges:\n            g[a].append(b)\n            g[b].append(a)\n        ans = a = 0\n        dfs(0, -1, 0)\n        dfs(a, -1, 0)\n        return ans\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(edges1 = [[0,1],[0,2],[0,3]], edges2 = [[0,1]]) == 3\n    assert candidate(edges1 = [[0,1],[0,2],[0,3],[2,4],[2,5],[3,6],[2,7]], edges2 = [[0,1],[0,2],[0,3],[2,4],[2,5],[3,6],[2,7]]) == 5\n\n\ncheck(Solution().minimumDiameterAfterMerge)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given an integer array rewardValues of length n, representing the values of rewards.\nInitially, your total reward x is 0, and all indices are unmarked. You are allowed to perform the following operation any number of times:\n\nChoose an unmarked index i from the range [0, n - 1].\nIf rewardValues[i] is greater than your current total reward x, then add rewardValues[i] to x (i.e., x = x + rewardValues[i]), and mark the index i.\n\nReturn an integer denoting the maximum total reward you can collect by performing the operations optimally.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def maxTotalReward(self, rewardValues: List[int]) -> int:\n```",
        "solutions": "class Solution:\n    def maxTotalReward(self, rewardValues: List[int]) -> int:\n        nums = sorted(set(rewardValues))\n        f = 1\n        for v in nums:\n            f |= (f & ((1 << v) - 1)) << v\n        return f.bit_length() - 1\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(rewardValues = [1,1,3,3]) == 4\n    assert candidate(rewardValues = [1,6,4,3,2]) == 11\n\n\ncheck(Solution().maxTotalReward)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given 2 integer arrays nums1 and nums2 of lengths n and m respectively. You are also given a positive integer k.\nA pair (i, j) is called good if nums1[i] is divisible by nums2[j] * k (0 <= i <= n - 1, 0 <= j <= m - 1).\nReturn the total number of good pairs.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def numberOfPairs(self, nums1: List[int], nums2: List[int], k: int) -> int:\n```",
        "solutions": "class Solution:\n    def numberOfPairs(self, nums1: List[int], nums2: List[int], k: int) -> int:\n        cnt1 = Counter(x // k for x in nums1 if x % k == 0)\n        if not cnt1:\n            return 0\n        cnt2 = Counter(nums2)\n        ans = 0\n        mx = max(cnt1)\n        for x, v in cnt2.items():\n            s = sum(cnt1[y] for y in range(x, mx + 1, x))\n            ans += s * v\n        return ans\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(nums1 = [1,3,4], nums2 = [1,3,4], k = 1) == 5\n    assert candidate(nums1 = [1,2,4,12], nums2 = [2,4], k = 3) == 2\n\n\ncheck(Solution().numberOfPairs)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given a string s. It may contain any number of '*' characters. Your task is to remove all '*' characters.\nWhile there is a '*', do the following operation:\n\nDelete the leftmost '*' and the smallest non-'*' character to its left. If there are several smallest characters, you can delete any of them.\n\nReturn the lexicographically smallest resulting string after removing all '*' characters.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def clearStars(self, s: str) -> str:\n```",
        "solutions": "class Solution:\n    def clearStars(self, s: str) -> str:\n        g = defaultdict(list)\n        n = len(s)\n        rem = [False] * n\n        for i, c in enumerate(s):\n            if c == \"*\":\n                rem[i] = True\n                for a in ascii_lowercase:\n                    if g[a]:\n                        rem[g[a].pop()] = True\n                        break\n            else:\n                g[c].append(i)\n        return \"\".join(c for i, c in enumerate(s) if not rem[i])\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(s = \"aaba*\") == \"aab\"\n    assert candidate(s = \"abc\") == \"abc\"\n\n\ncheck(Solution().clearStars)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given 2 integer arrays nums1 and nums2 of lengths n and m respectively. You are also given a positive integer k.\nA pair (i, j) is called good if nums1[i] is divisible by nums2[j] * k (0 <= i <= n - 1, 0 <= j <= m - 1).\nReturn the total number of good pairs.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def numberOfPairs(self, nums1: List[int], nums2: List[int], k: int) -> int:\n```",
        "solutions": "class Solution:\n    def numberOfPairs(self, nums1: List[int], nums2: List[int], k: int) -> int:\n        return sum(x % (y * k) == 0 for x in nums1 for y in nums2)\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(nums1 = [1,3,4], nums2 = [1,3,4], k = 1) == 5\n    assert candidate(nums1 = [1,2,4,12], nums2 = [2,4], k = 3) == 2\n\n\ncheck(Solution().numberOfPairs)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given two positive integers n and k. There are n children numbered from 0 to n - 1 standing in a queue in order from left to right.\nInitially, child 0 holds a ball and the direction of passing the ball is towards the right direction. After each second, the child holding the ball passes it to the child next to them. Once the ball reaches either end of the line, i.e. child 0 or child n - 1, the direction of passing is reversed.\nReturn the number of the child who receives the ball after k seconds.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def numberOfChild(self, n: int, k: int) -> int:\n```",
        "solutions": "class Solution:\n    def numberOfChild(self, n: int, k: int) -> int:\n        k, mod = divmod(k, n - 1)\n        return n - mod - 1 if k & 1 else mod\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(n = 3, k = 5) == 1\n    assert candidate(n = 5, k = 6) == 2\n    assert candidate(n = 4, k = 2) == 2\n\n\ncheck(Solution().numberOfChild)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nGiven a string word, compress it using the following algorithm:\n\nBegin with an empty string comp. While word is not empty, use the following operation:\n\n\t\nRemove a maximum length prefix of word made of a single character c repeating at most 9 times.\nAppend the length of the prefix followed by c to comp.\n\n\n\nReturn the string comp.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def compressedString(self, word: str) -> str:\n```",
        "solutions": "class Solution:\n    def compressedString(self, word: str) -> str:\n        g = groupby(word)\n        ans = []\n        for c, v in g:\n            k = len(list(v))\n            while k:\n                x = min(9, k)\n                ans.append(str(x) + c)\n                k -= x\n        return \"\".join(ans)\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(word = \"abcde\") == \"1a1b1c1d1e\"\n    assert candidate(word = \"aaaaaaaaaaaaaabb\") == \"9a5a2b\"\n\n\ncheck(Solution().compressedString)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given a positive integer n.\nA binary string x is valid if all substrings of x of length 2 contain at least one \"1\".\nReturn all valid strings with length n, in any order.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def validStrings(self, n: int) -> List[str]:\n```",
        "solutions": "class Solution:\n    def validStrings(self, n: int) -> List[str]:\n        def dfs(i: int):\n            if i >= n:\n                ans.append(\"\".join(t))\n                return\n            for j in range(2):\n                if (j == 0 and (i == 0 or t[i - 1] == \"1\")) or j == 1:\n                    t.append(str(j))\n                    dfs(i + 1)\n                    t.pop()\n\n        ans = []\n        t = []\n        dfs(0)\n        return ans\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(n = 3) == [\"010\",\"011\",\"101\",\"110\",\"111\"]\n    assert candidate(n = 1) == [\"0\",\"1\"]\n\n\ncheck(Solution().validStrings)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given two positive integer arrays nums and target, of the same length.\nIn a single operation, you can select any subarray of nums and increment each element within that subarray by 1 or decrement each element within that subarray by 1.\nReturn the minimum number of operations required to make nums equal to the array target.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def minimumOperations(self, nums: List[int], target: List[int]) -> int:\n```",
        "solutions": "class Solution:\n    def minimumOperations(self, nums: List[int], target: List[int]) -> int:\n        n = len(nums)\n        f = abs(target[0] - nums[0])\n        for i in range(1, n):\n            x = target[i] - nums[i]\n            y = target[i - 1] - nums[i - 1]\n            if x * y > 0:\n                d = abs(x) - abs(y)\n                if d > 0:\n                    f += d\n            else:\n                f += abs(x)\n        return f\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(nums = [3,5,1,2], target = [4,6,2,4]) == 2\n    assert candidate(nums = [1,3,2], target = [2,1,4]) == 5\n\n\ncheck(Solution().minimumOperations)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given a 2D binary array grid. You need to find 3 non-overlapping rectangles having non-zero areas with horizontal and vertical sides such that all the 1's in grid lie inside these rectangles.\nReturn the minimum possible sum of the area of these rectangles.\nNote that the rectangles are allowed to touch.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def minimumSum(self, grid: List[List[int]]) -> int:\n```",
        "solutions": "class Solution:\n    def minimumSum(self, grid: List[List[int]]) -> int:\n        def f(i1: int, j1: int, i2: int, j2: int) -> int:\n            x1 = y1 = inf\n            x2 = y2 = -inf\n            for i in range(i1, i2 + 1):\n                for j in range(j1, j2 + 1):\n                    if grid[i][j] == 1:\n                        x1 = min(x1, i)\n                        y1 = min(y1, j)\n                        x2 = max(x2, i)\n                        y2 = max(y2, j)\n            return (x2 - x1 + 1) * (y2 - y1 + 1)\n\n        m, n = len(grid), len(grid[0])\n        ans = m * n\n        for i1 in range(m - 1):\n            for i2 in range(i1 + 1, m - 1):\n                ans = min(\n                    ans,\n                    f(0, 0, i1, n - 1)\n                    + f(i1 + 1, 0, i2, n - 1)\n                    + f(i2 + 1, 0, m - 1, n - 1),\n                )\n        for j1 in range(n - 1):\n            for j2 in range(j1 + 1, n - 1):\n                ans = min(\n                    ans,\n                    f(0, 0, m - 1, j1)\n                    + f(0, j1 + 1, m - 1, j2)\n                    + f(0, j2 + 1, m - 1, n - 1),\n                )\n        for i in range(m - 1):\n            for j in range(n - 1):\n                ans = min(\n                    ans,\n                    f(0, 0, i, j) + f(0, j + 1, i, n - 1) + f(i + 1, 0, m - 1, n - 1),\n                )\n                ans = min(\n                    ans,\n                    f(0, 0, i, n - 1)\n                    + f(i + 1, 0, m - 1, j)\n                    + f(i + 1, j + 1, m - 1, n - 1),\n                )\n\n                ans = min(\n                    ans,\n                    f(0, 0, i, j) + f(i + 1, 0, m - 1, j) + f(0, j + 1, m - 1, n - 1),\n                )\n                ans = min(\n                    ans,\n                    f(0, 0, m - 1, j)\n                    + f(0, j + 1, i, n - 1)\n                    + f(i + 1, j + 1, m - 1, n - 1),\n                )\n        return ans\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(grid = [[1,0,1],[1,1,1]]) == 5\n    assert candidate(grid = [[1,0,1,0],[0,1,0,1]]) == 5\n\n\ncheck(Solution().minimumSum)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given a 2D binary array grid. Find a rectangle with horizontal and vertical sides with the smallest area, such that all the 1's in grid lie inside this rectangle.\nReturn the minimum possible area of the rectangle.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def minimumArea(self, grid: List[List[int]]) -> int:\n```",
        "solutions": "class Solution:\n    def minimumArea(self, grid: List[List[int]]) -> int:\n        x1 = y1 = inf\n        x2 = y2 = -inf\n        for i, row in enumerate(grid):\n            for j, x in enumerate(row):\n                if x == 1:\n                    x1 = min(x1, i)\n                    y1 = min(y1, j)\n                    x2 = max(x2, i)\n                    y2 = max(y2, j)\n        return (x2 - x1 + 1) * (y2 - y1 + 1)\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(grid = [[0,1,0],[1,0,1]]) == 6\n    assert candidate(grid = [[0,0],[1,0]]) == 1\n\n\ncheck(Solution().minimumArea)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nAlice and Bob are playing a game on a string.\nYou are given a string s, Alice and Bob will take turns playing the following game where Alice starts first:\n\nOn Alice's turn, she has to remove any non-empty substring from s that contains an odd number of vowels.\nOn Bob's turn, he has to remove any non-empty substring from s that contains an even number of vowels.\n\nThe first player who cannot make a move on their turn loses the game. We assume that both Alice and Bob play optimally.\nReturn true if Alice wins the game, and false otherwise.\nThe English vowels are: a, e, i, o, and u.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def doesAliceWin(self, s: str) -> bool:\n```",
        "solutions": "class Solution:\n    def doesAliceWin(self, s: str) -> bool:\n        vowels = set(\"aeiou\")\n        return any(c in vowels for c in s)\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(s = \"leetcoder\") == True\n    assert candidate(s = \"bbcd\") == False\n\n\ncheck(Solution().doesAliceWin)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given a string s and an integer k. Encrypt the string using the following algorithm:\n\nFor each character c in s, replace c with the kth character after c in the string (in a cyclic manner).\n\nReturn the encrypted string.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def getEncryptedString(self, s: str, k: int) -> str:\n```",
        "solutions": "class Solution:\n    def getEncryptedString(self, s: str, k: int) -> str:\n        cs = list(s)\n        n = len(s)\n        for i in range(n):\n            cs[i] = s[(i + k) % n]\n        return \"\".join(cs)\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(s = \"dart\", k = 3) == \"tdar\"\n    assert candidate(s = \"aaa\", k = 1) == \"aaa\"\n\n\ncheck(Solution().getEncryptedString)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given two integers red and blue representing the count of red and blue colored balls. You have to arrange these balls to form a triangle such that the 1st row will have 1 ball, the 2nd row will have 2 balls, the 3rd row will have 3 balls, and so on.\nAll the balls in a particular row should be the same color, and adjacent rows should have different colors.\nReturn the maximum height of the triangle that can be achieved.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def maxHeightOfTriangle(self, red: int, blue: int) -> int:\n```",
        "solutions": "class Solution:\n    def maxHeightOfTriangle(self, red: int, blue: int) -> int:\n        ans = 0\n        for k in range(2):\n            c = [red, blue]\n            i, j = 1, k\n            while i <= c[j]:\n                c[j] -= i\n                j ^= 1\n                ans = max(ans, i)\n                i += 1\n        return ans\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(red = 2, blue = 4) == 3\n    assert candidate(red = 2, blue = 1) == 2\n    assert candidate(red = 1, blue = 1) == 1\n    assert candidate(red = 10, blue = 1) == 2\n\n\ncheck(Solution().maxHeightOfTriangle)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou have an array of floating point numbers averages which is initially empty. You are given an array nums of n integers where n is even.\nYou repeat the following procedure n / 2 times:\n\nRemove the smallest element, minElement, and the largest element maxElement,\u00a0from nums.\nAdd (minElement + maxElement) / 2 to averages.\n\nReturn the minimum element in averages.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def minimumAverage(self, nums: List[int]) -> float:\n```",
        "solutions": "class Solution:\n    def minimumAverage(self, nums: List[int]) -> float:\n        nums.sort()\n        n = len(nums)\n        return min(nums[i] + nums[-i - 1] for i in range(n // 2)) / 2\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(nums = [7,8,3,4,15,13,4,1]) == 5.5\n    assert candidate(nums = [1,9,8,3,10,5]) == 5.5\n    assert candidate(nums = [1,2,3,7,8,9]) == 5.0\n\n\ncheck(Solution().minimumAverage)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given a string target, an array of strings words, and an integer array costs, both arrays of the same length.\nImagine an empty string s.\nYou can perform the following operation any number of times (including zero):\n\nChoose an index i in the range [0, words.length - 1].\nAppend words[i] to s.\nThe cost of operation is costs[i].\n\nReturn the minimum cost to make s equal to target. If it's not possible, return -1.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def minimumCost(self, target: str, words: List[str], costs: List[int]) -> int:\n```",
        "solutions": "class Solution:\n    def minimumCost(self, target: str, words: List[str], costs: List[int]) -> int:\n        base, mod = 13331, 998244353\n        n = len(target)\n        h = [0] * (n + 1)\n        p = [1] * (n + 1)\n        for i, c in enumerate(target, 1):\n            h[i] = (h[i - 1] * base + ord(c)) % mod\n            p[i] = (p[i - 1] * base) % mod\n        f = [0] + [inf] * n\n        ss = sorted(set(map(len, words)))\n        d = defaultdict(lambda: inf)\n        min = lambda a, b: a if a < b else b\n        for w, c in zip(words, costs):\n            x = 0\n            for ch in w:\n                x = (x * base + ord(ch)) % mod\n            d[x] = min(d[x], c)\n        for i in range(1, n + 1):\n            for j in ss:\n                if j > i:\n                    break\n                x = (h[i] - h[i - j] * p[j]) % mod\n                f[i] = min(f[i], f[i - j] + d[x])\n        return f[n] if f[n] < inf else -1\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(target = \"abcdef\", words = [\"abdef\",\"abc\",\"d\",\"def\",\"ef\"], costs = [100,1,1,10,5]) == 7\n    assert candidate(target = \"aaaa\", words = [\"z\",\"zz\",\"zzz\"], costs = [1,10,100]) == -1\n\n\ncheck(Solution().minimumCost)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nThere is an undirected tree with n nodes labeled from 0 to n - 1, and rooted at node 0. You are given a 2D integer array edges of length n - 1, where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree.\nA node is good if all the subtrees rooted at its children have the same size.\nReturn the number of good nodes in the given tree.\nA subtree of treeName is a tree consisting of a node in treeName and all of its descendants.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def countGoodNodes(self, edges: List[List[int]]) -> int:\n```",
        "solutions": "class Solution:\n    def countGoodNodes(self, edges: List[List[int]]) -> int:\n        def dfs(a: int, fa: int) -> int:\n            pre = -1\n            cnt = ok = 1\n            for b in g[a]:\n                if b != fa:\n                    cur = dfs(b, a)\n                    cnt += cur\n                    if pre < 0:\n                        pre = cur\n                    elif pre != cur:\n                        ok = 0\n            nonlocal ans\n            ans += ok\n            return cnt\n\n        g = defaultdict(list)\n        for a, b in edges:\n            g[a].append(b)\n            g[b].append(a)\n        ans = 0\n        dfs(0, -1)\n        return ans\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(edges = [[0,1],[0,2],[1,3],[1,4],[2,5],[2,6]]) == 7\n    assert candidate(edges = [[0,1],[1,2],[2,3],[3,4],[0,5],[1,6],[2,7],[3,8]]) == 6\n    assert candidate(edges = [[0,1],[1,2],[1,3],[1,4],[0,5],[5,6],[6,7],[7,8],[0,9],[9,10],[9,12],[10,11]]) == 12\n\n\ncheck(Solution().countGoodNodes)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given an integer array nums.\nA subsequence sub of nums with length x is called valid if it satisfies:\n\n(sub[0] + sub[1]) % 2 == (sub[1] + sub[2]) % 2 == ... == (sub[x - 2] + sub[x - 1]) % 2.\n\nReturn the length of the longest valid subsequence of nums.\nA subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def maximumLength(self, nums: List[int]) -> int:\n```",
        "solutions": "class Solution:\n    def maximumLength(self, nums: List[int]) -> int:\n        k = 2\n        f = [[0] * k for _ in range(k)]\n        ans = 0\n        for x in nums:\n            x %= k\n            for j in range(k):\n                y = (j - x + k) % k\n                f[x][y] = f[y][x] + 1\n                ans = max(ans, f[x][y])\n        return ans\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(nums = [1,2,3,4]) == 4\n    assert candidate(nums = [1,2,1,1,2,1,2]) == 6\n    assert candidate(nums = [1,3]) == 2\n\n\ncheck(Solution().maximumLength)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given an integer array nums and a positive integer k.\nA subsequence sub of nums with length x is called valid if it satisfies:\n\n(sub[0] + sub[1]) % k == (sub[1] + sub[2]) % k == ... == (sub[x - 2] + sub[x - 1]) % k.\n\nReturn the length of the longest valid subsequence of nums.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def maximumLength(self, nums: List[int], k: int) -> int:\n```",
        "solutions": "class Solution:\n    def maximumLength(self, nums: List[int], k: int) -> int:\n        f = [[0] * k for _ in range(k)]\n        ans = 0\n        for x in nums:\n            x %= k\n            for j in range(k):\n                y = (j - x + k) % k\n                f[x][y] = f[y][x] + 1\n                ans = max(ans, f[x][y])\n        return ans\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(nums = [1,2,3,4,5], k = 2) == 5\n    assert candidate(nums = [1,4,2,3,1,4], k = 3) == 4\n\n\ncheck(Solution().maximumLength)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nGiven a 2D character matrix grid, where grid[i][j] is either 'X', 'Y', or '.', return the number of submatrices that contain:\n\ngrid[0][0]\nan equal frequency of 'X' and 'Y'.\nat least one 'X'.\n\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def numberOfSubmatrices(self, grid: List[List[str]]) -> int:\n```",
        "solutions": "class Solution:\n    def numberOfSubmatrices(self, grid: List[List[str]]) -> int:\n        m, n = len(grid), len(grid[0])\n        s = [[[0] * 2 for _ in range(n + 1)] for _ in range(m + 1)]\n        ans = 0\n        for i, row in enumerate(grid, 1):\n            for j, x in enumerate(row, 1):\n                s[i][j][0] = s[i - 1][j][0] + s[i][j - 1][0] - s[i - 1][j - 1][0]\n                s[i][j][1] = s[i - 1][j][1] + s[i][j - 1][1] - s[i - 1][j - 1][1]\n                if x != \".\":\n                    s[i][j][ord(x) & 1] += 1\n                if s[i][j][0] > 0 and s[i][j][0] == s[i][j][1]:\n                    ans += 1\n        return ans\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(grid = [[\"X\",\"Y\",\".\"],[\"Y\",\".\",\".\"]]) == 3\n    assert candidate(grid = [[\"X\",\"X\"],[\"X\",\"Y\"]]) == 0\n    assert candidate(grid = [[\".\",\".\"],[\".\",\".\"]]) == 0\n\n\ncheck(Solution().numberOfSubmatrices)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given a binary string s.\nYou can perform the following operation on the string any number of times:\n\nChoose any index i from the string where i + 1 < s.length such that s[i] == '1' and s[i + 1] == '0'.\nMove the character s[i] to the right until it reaches the end of the string or another '1'. For example, for s = \"010010\", if we choose i = 1, the resulting string will be s = \"000110\".\n\nReturn the maximum number of operations that you can perform.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def maxOperations(self, s: str) -> int:\n```",
        "solutions": "class Solution:\n    def maxOperations(self, s: str) -> int:\n        ans = cnt = 0\n        for i, c in enumerate(s):\n            if c == \"1\":\n                cnt += 1\n            elif i and s[i - 1] == \"1\":\n                ans += cnt\n        return ans\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(s = \"1001101\") == 4\n    assert candidate(s = \"00111\") == 0\n\n\ncheck(Solution().maxOperations)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nThere is an m x n cake that needs to be cut into 1 x 1 pieces.\nYou are given integers m, n, and two arrays:\n\nhorizontalCut of size m - 1, where horizontalCut[i] represents the cost to cut along the horizontal line i.\nverticalCut of size n - 1, where verticalCut[j] represents the cost to cut along the vertical line j.\n\nIn one operation, you can choose any piece of cake that is not yet a 1 x 1 square and perform one of the following cuts:\n\nCut along a horizontal line i at a cost of horizontalCut[i].\nCut along a vertical line j at a cost of verticalCut[j].\n\nAfter the cut, the piece of cake is divided into two distinct pieces.\nThe cost of a cut depends only on the initial cost of the line and does not change.\nReturn the minimum total cost to cut the entire cake into 1 x 1 pieces.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def minimumCost(self, m: int, n: int, horizontalCut: List[int], verticalCut: List[int]) -> int:\n```",
        "solutions": "class Solution:\n    def minimumCost(\n        self, m: int, n: int, horizontalCut: List[int], verticalCut: List[int]\n    ) -> int:\n        horizontalCut.sort(reverse=True)\n        verticalCut.sort(reverse=True)\n        ans = i = j = 0\n        h = v = 1\n        while i < m - 1 or j < n - 1:\n            if j == n - 1 or (i < m - 1 and horizontalCut[i] > verticalCut[j]):\n                ans += horizontalCut[i] * v\n                h, i = h + 1, i + 1\n            else:\n                ans += verticalCut[j] * h\n                v, j = v + 1, j + 1\n        return ans\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(m = 3, n = 2, horizontalCut = [1,3], verticalCut = [5]) == 13\n    assert candidate(m = 2, n = 2, horizontalCut = [7], verticalCut = [4]) == 15\n\n\ncheck(Solution().minimumCost)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nThere is an m x n cake that needs to be cut into 1 x 1 pieces.\nYou are given integers m, n, and two arrays:\n\nhorizontalCut of size m - 1, where horizontalCut[i] represents the cost to cut along the horizontal line i.\nverticalCut of size n - 1, where verticalCut[j] represents the cost to cut along the vertical line j.\n\nIn one operation, you can choose any piece of cake that is not yet a 1 x 1 square and perform one of the following cuts:\n\nCut along a horizontal line i at a cost of horizontalCut[i].\nCut along a vertical line j at a cost of verticalCut[j].\n\nAfter the cut, the piece of cake is divided into two distinct pieces.\nThe cost of a cut depends only on the initial cost of the line and does not change.\nReturn the minimum total cost to cut the entire cake into 1 x 1 pieces.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def minimumCost(self, m: int, n: int, horizontalCut: List[int], verticalCut: List[int]) -> int:\n```",
        "solutions": "class Solution:\n    def minimumCost(\n        self, m: int, n: int, horizontalCut: List[int], verticalCut: List[int]\n    ) -> int:\n        horizontalCut.sort(reverse=True)\n        verticalCut.sort(reverse=True)\n        ans = i = j = 0\n        h = v = 1\n        while i < m - 1 or j < n - 1:\n            if j == n - 1 or (i < m - 1 and horizontalCut[i] > verticalCut[j]):\n                ans += horizontalCut[i] * v\n                h, i = h + 1, i + 1\n            else:\n                ans += verticalCut[j] * h\n                v, j = v + 1, j + 1\n        return ans\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(m = 3, n = 2, horizontalCut = [1,3], verticalCut = [5]) == 13\n    assert candidate(m = 2, n = 2, horizontalCut = [7], verticalCut = [4]) == 15\n\n\ncheck(Solution().minimumCost)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given 2 positive integers l and r. For any number x, all positive divisors of x except x are called the proper divisors of x.\nA number is called special if it has exactly 2 proper divisors. For example:\n\nThe number 4 is special because it has proper divisors 1 and 2.\nThe number 6 is not special because it has proper divisors 1, 2, and 3.\n\nReturn the count of numbers in the range [l, r] that are not special.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def nonSpecialCount(self, l: int, r: int) -> int:\n```",
        "solutions": "m = 31623\nprimes = [True] * (m + 1)\nprimes[0] = primes[1] = False\nfor i in range(2, m + 1):\n    if primes[i]:\n        for j in range(i + i, m + 1, i):\n            primes[j] = False\n\n\nclass Solution:\n    def nonSpecialCount(self, l: int, r: int) -> int:\n        lo = ceil(sqrt(l))\n        hi = floor(sqrt(r))\n        cnt = sum(primes[i] for i in range(lo, hi + 1))\n        return r - l + 1 - cnt\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(l = 5, r = 7) == 3\n    assert candidate(l = 4, r = 16) == 11\n\n\ncheck(Solution().nonSpecialCount)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given an integer n and a 2D integer array queries.\nThere are n cities numbered from 0 to n - 1. Initially, there is a unidirectional road from city i to city i + 1 for all 0 <= i < n - 1.\nqueries[i] = [ui, vi] represents the addition of a new unidirectional road from city ui to city vi. After each query, you need to find the length of the shortest path from city 0 to city n - 1.\nThere are no two queries such that queries[i][0] < queries[j][0] < queries[i][1] < queries[j][1].\nReturn an array answer where for each i in the range [0, queries.length - 1], answer[i] is the length of the shortest path from city 0 to city n - 1 after processing the first i + 1 queries.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n```",
        "solutions": "class Solution:\n    def shortestDistanceAfterQueries(\n        self, n: int, queries: List[List[int]]\n    ) -> List[int]:\n        nxt = list(range(1, n))\n        ans = []\n        cnt = n - 1\n        for u, v in queries:\n            if 0 < nxt[u] < v:\n                i = nxt[u]\n                while i < v:\n                    cnt -= 1\n                    nxt[i], i = 0, nxt[i]\n                nxt[u] = v\n            ans.append(cnt)\n        return ans\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(n = 5, queries = [[2, 4], [0, 2], [0, 4]]) == [3, 2, 1]\n    assert candidate(n = 4, queries = [[0, 3], [0, 2]]) == [1, 1]\n\n\ncheck(Solution().shortestDistanceAfterQueries)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given an array of positive integers nums.\nAlice and Bob are playing a game. In the game, Alice can choose either all single-digit numbers or all double-digit numbers from nums, and the rest of the numbers are given to Bob. Alice wins if the sum of her numbers is strictly greater than the sum of Bob's numbers.\nReturn true if Alice can win this game, otherwise, return false.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def canAliceWin(self, nums: List[int]) -> bool:\n```",
        "solutions": "class Solution:\n    def canAliceWin(self, nums: List[int]) -> bool:\n        a = sum(x for x in nums if x < 10)\n        b = sum(x for x in nums if x > 9)\n        return a != b\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(nums = [1,2,3,4,10]) == False\n    assert candidate(nums = [1,2,3,4,5,14]) == True\n    assert candidate(nums = [5,5,5,25]) == True\n\n\ncheck(Solution().canAliceWin)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given an integer n and a 2D integer array queries.\nThere are n cities numbered from 0 to n - 1. Initially, there is a unidirectional road from city i to city i + 1 for all 0 <= i < n - 1.\nqueries[i] = [ui, vi] represents the addition of a new unidirectional road from city ui to city vi. After each query, you need to find the length of the shortest path from city 0 to city n - 1.\nReturn an array answer where for each i in the range [0, queries.length - 1], answer[i] is the length of the shortest path from city 0 to city n - 1 after processing the first i + 1 queries.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n```",
        "solutions": "class Solution:\n    def shortestDistanceAfterQueries(\n        self, n: int, queries: List[List[int]]\n    ) -> List[int]:\n        def bfs(i: int) -> int:\n            q = deque([i])\n            vis = [False] * n\n            vis[i] = True\n            d = 0\n            while 1:\n                for _ in range(len(q)):\n                    u = q.popleft()\n                    if u == n - 1:\n                        return d\n                    for v in g[u]:\n                        if not vis[v]:\n                            vis[v] = True\n                            q.append(v)\n                d += 1\n\n        g = [[i + 1] for i in range(n - 1)]\n        ans = []\n        for u, v in queries:\n            g[u].append(v)\n            ans.append(bfs(0))\n        return ans\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(n = 5, queries = [[2, 4], [0, 2], [0, 4]]) == [3, 2, 1]\n    assert candidate(n = 4, queries = [[0, 3], [0, 2]]) == [1, 1]\n\n\ncheck(Solution().shortestDistanceAfterQueries)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given two integer arrays energyDrinkA and energyDrinkB of the same length n by a futuristic sports scientist. These arrays represent the energy boosts per hour provided by two different energy drinks, A and B, respectively.\nYou want to maximize your total energy boost by drinking one energy drink per hour. However, if you want to switch from consuming one energy drink to the other, you need to wait for one hour to cleanse your system (meaning you won't get any energy boost in that hour).\nReturn the maximum total energy boost you can gain in the next n hours.\nNote that you can start consuming either of the two energy drinks.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def maxEnergyBoost(self, energyDrinkA: List[int], energyDrinkB: List[int]) -> int:\n```",
        "solutions": "class Solution:\n    def maxEnergyBoost(self, energyDrinkA: List[int], energyDrinkB: List[int]) -> int:\n        n = len(energyDrinkA)\n        f = [[0] * 2 for _ in range(n)]\n        f[0][0] = energyDrinkA[0]\n        f[0][1] = energyDrinkB[0]\n        for i in range(1, n):\n            f[i][0] = max(f[i - 1][0] + energyDrinkA[i], f[i - 1][1])\n            f[i][1] = max(f[i - 1][1] + energyDrinkB[i], f[i - 1][0])\n        return max(f[n - 1])\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(energyDrinkA = [1,3,1], energyDrinkB = [3,1,1]) == 5\n    assert candidate(energyDrinkA = [4,1,1], energyDrinkB = [1,1,3]) == 7\n\n\ncheck(Solution().maxEnergyBoost)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given an array of positive integers nums of length n.\nWe call a pair of non-negative integer arrays (arr1, arr2) monotonic if:\n\nThe lengths of both arrays are n.\narr1 is monotonically non-decreasing, in other words, arr1[0] <= arr1[1] <= ... <= arr1[n - 1].\narr2 is monotonically non-increasing, in other words, arr2[0] >= arr2[1] >= ... >= arr2[n - 1].\narr1[i] + arr2[i] == nums[i] for all 0 <= i <= n - 1.\n\nReturn the count of monotonic pairs.\nSince the answer may be very large, return it modulo 109 + 7.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def countOfPairs(self, nums: List[int]) -> int:\n```",
        "solutions": "class Solution:\n    def countOfPairs(self, nums: List[int]) -> int:\n        mod = 10**9 + 7\n        n, m = len(nums), max(nums)\n        f = [[0] * (m + 1) for _ in range(n)]\n        for j in range(nums[0] + 1):\n            f[0][j] = 1\n        for i in range(1, n):\n            s = list(accumulate(f[i - 1]))\n            for j in range(nums[i] + 1):\n                k = min(j, j + nums[i - 1] - nums[i])\n                if k >= 0:\n                    f[i][j] = s[k] % mod\n        return sum(f[-1][: nums[-1] + 1]) % mod\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(nums = [2,3,2]) == 4\n    assert candidate(nums = [5,5,5,5]) == 126\n\n\ncheck(Solution().countOfPairs)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given an array of positive integers nums of length n.\nWe call a pair of non-negative integer arrays (arr1, arr2) monotonic if:\n\nThe lengths of both arrays are n.\narr1 is monotonically non-decreasing, in other words, arr1[0] <= arr1[1] <= ... <= arr1[n - 1].\narr2 is monotonically non-increasing, in other words, arr2[0] >= arr2[1] >= ... >= arr2[n - 1].\narr1[i] + arr2[i] == nums[i] for all 0 <= i <= n - 1.\n\nReturn the count of monotonic pairs.\nSince the answer may be very large, return it modulo 109 + 7.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def countOfPairs(self, nums: List[int]) -> int:\n```",
        "solutions": "class Solution:\n    def countOfPairs(self, nums: List[int]) -> int:\n        mod = 10**9 + 7\n        n, m = len(nums), max(nums)\n        f = [[0] * (m + 1) for _ in range(n)]\n        for j in range(nums[0] + 1):\n            f[0][j] = 1\n        for i in range(1, n):\n            s = list(accumulate(f[i - 1]))\n            for j in range(nums[i] + 1):\n                k = min(j, j + nums[i - 1] - nums[i])\n                if k >= 0:\n                    f[i][j] = s[k] % mod\n        return sum(f[-1][: nums[-1] + 1]) % mod\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(nums = [2,3,2]) == 4\n    assert candidate(nums = [5,5,5,5]) == 126\n\n\ncheck(Solution().countOfPairs)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given a binary string s and an integer k.\nA binary string satisfies the k-constraint if either of the following conditions holds:\n\nThe number of 0's in the string is at most k.\nThe number of 1's in the string is at most k.\n\nReturn an integer denoting the number of substrings of s that satisfy the k-constraint.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def countKConstraintSubstrings(self, s: str, k: int) -> int:\n```",
        "solutions": "class Solution:\n    def countKConstraintSubstrings(self, s: str, k: int) -> int:\n        cnt = [0, 0]\n        ans = l = 0\n        for r, x in enumerate(map(int, s)):\n            cnt[x] += 1\n            while cnt[0] > k and cnt[1] > k:\n                cnt[int(s[l])] -= 1\n                l += 1\n            ans += r - l + 1\n        return ans\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(s = \"10101\", k = 1) == 12\n    assert candidate(s = \"1010101\", k = 2) == 25\n    assert candidate(s = \"11111\", k = 1) == 15\n\n\ncheck(Solution().countKConstraintSubstrings)"
        }
    },
    {
        "problem": "Please solve the programming task below using a self-contained code snippet in a markdown code block.\n\nYou are given a binary string s and an integer k.\nYou are also given a 2D integer array queries, where queries[i] = [li, ri].\nA binary string satisfies the k-constraint if either of the following conditions holds:\n\nThe number of 0's in the string is at most k.\nThe number of 1's in the string is at most k.\n\nReturn an integer array answer, where answer[i] is the number of substrings of s[li..ri] that satisfy the k-constraint.\n\u00a0\nPlease complete the following python code precisely:\n```python\nclass Solution:\n    def countKConstraintSubstrings(self, s: str, k: int, queries: List[List[int]]) -> List[int]:\n```",
        "solutions": "class Solution:\n    def countKConstraintSubstrings(\n        self, s: str, k: int, queries: List[List[int]]\n    ) -> List[int]:\n        cnt = [0, 0]\n        i, n = 0, len(s)\n        d = [n] * n\n        pre = [0] * (n + 1)\n        for j, x in enumerate(map(int, s)):\n            cnt[x] += 1\n            while cnt[0] > k and cnt[1] > k:\n                d[i] = j\n                cnt[int(s[i])] -= 1\n                i += 1\n            pre[j + 1] = pre[j] + j - i + 1\n        ans = []\n        for l, r in queries:\n            p = min(r + 1, d[l])\n            a = (1 + p - l) * (p - l) // 2\n            b = pre[r + 1] - pre[p]\n            ans.append(a + b)\n        return ans\n",
        "tests": {
            "functional": "def check(candidate):\n    assert candidate(s = \"0001111\", k = 2, queries = [[0,6]]) == [26]\n    assert candidate(s = \"010101\", k = 1, queries = [[0,5],[1,4],[2,3]]) == [15,9,3]\n\n\ncheck(Solution().countKConstraintSubstrings)"
        }
    }
]